/*
* generated by Xtext
*/
package at.bestsolution.efxclipse.tooling.svgpath.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import at.bestsolution.efxclipse.tooling.svgpath.services.SvgPathGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public class SvgPathParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private SvgPathGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Svg_path_Moveto_drawto_command_groupsAssignment(this, this, 0, inst);
			case 1: return new Moveto_drawto_command_groups_CommandsAssignment(this, this, 1, inst);
			case 2: return new Moveto_drawto_command_group_Group(this, this, 2, inst);
			case 3: return new Moveto_Group(this, this, 3, inst);
			case 4: return new Lineto_argument_sequence_Group(this, this, 4, inst);
			case 5: return new Drawto_commands_Drawto_commandsAssignment(this, this, 5, inst);
			case 6: return new Drawto_command_Alternatives(this, this, 6, inst);
			case 7: return new Closepath_Group(this, this, 7, inst);
			case 8: return new Lineto_Group(this, this, 8, inst);
			case 9: return new Horizontal_lineto_Group(this, this, 9, inst);
			case 10: return new Horizontal_lineto_argument_sequence_Group(this, this, 10, inst);
			case 11: return new Vertical_lineto_Group(this, this, 11, inst);
			case 12: return new Vertical_lineto_argument_sequence_Group(this, this, 12, inst);
			case 13: return new Curveto_Group(this, this, 13, inst);
			case 14: return new Curveto_argument_sequence_Group(this, this, 14, inst);
			case 15: return new Curveto_argument_Group(this, this, 15, inst);
			case 16: return new Smooth_curveto_Group(this, this, 16, inst);
			case 17: return new Smooth_curveto_argument_sequence_Group(this, this, 17, inst);
			case 18: return new Smooth_curveto_argument_Group(this, this, 18, inst);
			case 19: return new Quadratic_bezier_curveto_Group(this, this, 19, inst);
			case 20: return new Quadratic_bezier_curveto_argument_sequence_Group(this, this, 20, inst);
			case 21: return new Quadratic_bezier_curveto_argument_Group(this, this, 21, inst);
			case 22: return new Smooth_quadratic_bezier_curveto_Group(this, this, 22, inst);
			case 23: return new Smooth_quadratic_bezier_curveto_argument_sequence_Group(this, this, 23, inst);
			case 24: return new Elliptical_arc_Group(this, this, 24, inst);
			case 25: return new Elliptical_arc_argument_sequence_Group(this, this, 25, inst);
			case 26: return new Elliptical_arc_argument_Group(this, this, 26, inst);
			case 27: return new Coordinate_pair_Group(this, this, 27, inst);
			case 28: return new Coordinate_NumberParserRuleCall(this, this, 28, inst);
			case 29: return new Number_Group(this, this, 29, inst);
			case 30: return new Nonnegative_number_Group(this, this, 30, inst);
			case 31: return new Exponent_Group(this, this, 31, inst);
			case 32: return new Digit_sequence_DigitsAssignment(this, this, 32, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule svg_path ****************
 *
 * svg_path:
 * 	moveto_drawto_command_groups=moveto_drawto_command_groups?;
 *
 **/

// moveto_drawto_command_groups=moveto_drawto_command_groups?
protected class Svg_path_Moveto_drawto_command_groupsAssignment extends AssignmentToken  {
	
	public Svg_path_Moveto_drawto_command_groupsAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSvg_pathAccess().getMoveto_drawto_command_groupsAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Moveto_drawto_command_groups_CommandsAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSvg_pathRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("moveto_drawto_command_groups",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("moveto_drawto_command_groups");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMoveto_drawto_command_groupsRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSvg_pathAccess().getMoveto_drawto_command_groupsMoveto_drawto_command_groupsParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule svg_path ****************/


/************ begin Rule moveto_drawto_command_groups ****************
 *
 * moveto_drawto_command_groups:
 * 	commands+=moveto_drawto_command_group;
 *
 **/

// commands+=moveto_drawto_command_group
protected class Moveto_drawto_command_groups_CommandsAssignment extends AssignmentToken  {
	
	public Moveto_drawto_command_groups_CommandsAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMoveto_drawto_command_groupsAccess().getCommandsAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Moveto_drawto_command_group_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMoveto_drawto_command_groupsRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("commands",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("commands");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMoveto_drawto_command_groupRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMoveto_drawto_command_groupsAccess().getCommandsMoveto_drawto_command_groupParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule moveto_drawto_command_groups ****************/


/************ begin Rule moveto_drawto_command_group ****************
 *
 * moveto_drawto_command_group:
 * 	moveto=moveto drawto_commands=drawto_commands?;
 *
 **/

// moveto=moveto drawto_commands=drawto_commands?
protected class Moveto_drawto_command_group_Group extends GroupToken {
	
	public Moveto_drawto_command_group_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMoveto_drawto_command_groupAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Moveto_drawto_command_group_Drawto_commandsAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Moveto_drawto_command_group_MovetoAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMoveto_drawto_command_groupRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// moveto=moveto
protected class Moveto_drawto_command_group_MovetoAssignment_0 extends AssignmentToken  {
	
	public Moveto_drawto_command_group_MovetoAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMoveto_drawto_command_groupAccess().getMovetoAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Moveto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("moveto",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("moveto");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMovetoRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMoveto_drawto_command_groupAccess().getMovetoMovetoParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// drawto_commands=drawto_commands?
protected class Moveto_drawto_command_group_Drawto_commandsAssignment_1 extends AssignmentToken  {
	
	public Moveto_drawto_command_group_Drawto_commandsAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMoveto_drawto_command_groupAccess().getDrawto_commandsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Drawto_commands_Drawto_commandsAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("drawto_commands",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("drawto_commands");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDrawto_commandsRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMoveto_drawto_command_groupAccess().getDrawto_commandsDrawto_commandsParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Moveto_drawto_command_group_MovetoAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule moveto_drawto_command_group ****************/


/************ begin Rule moveto ****************
 *
 * moveto:
 * 	("M" | "m") point=coordinate_pair comma? lineto_argument_sequence=lineto_argument_sequence;
 *
 **/

// ("M" | "m") point=coordinate_pair comma? lineto_argument_sequence=lineto_argument_sequence
protected class Moveto_Group extends GroupToken {
	
	public Moveto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMovetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Moveto_Lineto_argument_sequenceAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getMovetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "M" | "m"
protected class Moveto_Alternatives_0 extends AlternativesToken {

	public Moveto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMovetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Moveto_MKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "M"
protected class Moveto_MKeyword_0_0 extends KeywordToken  {
	
	public Moveto_MKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMovetoAccess().getMKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// point=coordinate_pair
protected class Moveto_PointAssignment_1 extends AssignmentToken  {
	
	public Moveto_PointAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMovetoAccess().getPointAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("point",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("point");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMovetoAccess().getPointCoordinate_pairParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Moveto_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// lineto_argument_sequence=lineto_argument_sequence
protected class Moveto_Lineto_argument_sequenceAssignment_3 extends AssignmentToken  {
	
	public Moveto_Lineto_argument_sequenceAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMovetoAccess().getLineto_argument_sequenceAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lineto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("lineto_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("lineto_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLineto_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getMovetoAccess().getLineto_argument_sequenceLineto_argument_sequenceParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Moveto_PointAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule moveto ****************/


/************ begin Rule lineto_argument_sequence ****************
 *
 * lineto_argument_sequence:
 * 	pairs+=coordinate_pair (comma? pairs+=coordinate_pair)*;
 *
 **/

// pairs+=coordinate_pair (comma? pairs+=coordinate_pair)*
protected class Lineto_argument_sequence_Group extends GroupToken {
	
	public Lineto_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLineto_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lineto_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Lineto_argument_sequence_PairsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getLineto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// pairs+=coordinate_pair
protected class Lineto_argument_sequence_PairsAssignment_0 extends AssignmentToken  {
	
	public Lineto_argument_sequence_PairsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLineto_argument_sequenceAccess().getPairsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("pairs",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("pairs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getLineto_argument_sequenceAccess().getPairsCoordinate_pairParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? pairs+=coordinate_pair)*
protected class Lineto_argument_sequence_Group_1 extends GroupToken {
	
	public Lineto_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLineto_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lineto_argument_sequence_PairsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// pairs+=coordinate_pair
protected class Lineto_argument_sequence_PairsAssignment_1_1 extends AssignmentToken  {
	
	public Lineto_argument_sequence_PairsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLineto_argument_sequenceAccess().getPairsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("pairs",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("pairs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getLineto_argument_sequenceAccess().getPairsCoordinate_pairParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Lineto_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Lineto_argument_sequence_PairsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule lineto_argument_sequence ****************/


/************ begin Rule drawto_commands ****************
 *
 * drawto_commands:
 * 	drawto_commands+=drawto_command+;
 *
 **/

// drawto_commands+=drawto_command+
protected class Drawto_commands_Drawto_commandsAssignment extends AssignmentToken  {
	
	public Drawto_commands_Drawto_commandsAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDrawto_commandsAccess().getDrawto_commandsAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Drawto_command_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("drawto_commands",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("drawto_commands");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDrawto_commandRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getDrawto_commandsAccess().getDrawto_commandsDrawto_commandParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Drawto_commands_Drawto_commandsAssignment(lastRuleCallOrigin, next, actIndex, consumed);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule drawto_commands ****************/


/************ begin Rule drawto_command ****************
 *
 * drawto_command:
 * 	closepath | lineto | horizontal_lineto | vertical_lineto | curveto | smooth_curveto | quadratic_bezier_curveto |
 * 	smooth_quadratic_bezier_curveto | elliptical_arc;
 *
 **/

// closepath | lineto | horizontal_lineto | vertical_lineto | curveto | smooth_curveto | quadratic_bezier_curveto |
// smooth_quadratic_bezier_curveto | elliptical_arc
protected class Drawto_command_Alternatives extends AlternativesToken {

	public Drawto_command_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Drawto_command_ClosepathParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Drawto_command_LinetoParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Drawto_command_Horizontal_linetoParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			case 3: return new Drawto_command_Vertical_linetoParserRuleCall_3(lastRuleCallOrigin, this, 3, inst);
			case 4: return new Drawto_command_CurvetoParserRuleCall_4(lastRuleCallOrigin, this, 4, inst);
			case 5: return new Drawto_command_Smooth_curvetoParserRuleCall_5(lastRuleCallOrigin, this, 5, inst);
			case 6: return new Drawto_command_Quadratic_bezier_curvetoParserRuleCall_6(lastRuleCallOrigin, this, 6, inst);
			case 7: return new Drawto_command_Smooth_quadratic_bezier_curvetoParserRuleCall_7(lastRuleCallOrigin, this, 7, inst);
			case 8: return new Drawto_command_Elliptical_arcParserRuleCall_8(lastRuleCallOrigin, this, 8, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getClosepathAccess().getClosepathAction_0().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getCurvetoRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getElliptical_arcRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getHorizontal_linetoRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getLinetoRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getQuadratic_bezier_curveto_argument_sequenceRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSmooth_curvetoRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getSmooth_quadratic_bezier_curvetoRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getVertical_linetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// closepath
protected class Drawto_command_ClosepathParserRuleCall_0 extends RuleCallToken {
	
	public Drawto_command_ClosepathParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getClosepathParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Closepath_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getClosepathAccess().getClosepathAction_0().getType().getClassifier())
			return null;
		if(checkForRecursion(Closepath_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// lineto
protected class Drawto_command_LinetoParserRuleCall_1 extends RuleCallToken {
	
	public Drawto_command_LinetoParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getLinetoParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lineto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getLinetoRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Lineto_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// horizontal_lineto
protected class Drawto_command_Horizontal_linetoParserRuleCall_2 extends RuleCallToken {
	
	public Drawto_command_Horizontal_linetoParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getHorizontal_linetoParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Horizontal_lineto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHorizontal_linetoRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Horizontal_lineto_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// vertical_lineto
protected class Drawto_command_Vertical_linetoParserRuleCall_3 extends RuleCallToken {
	
	public Drawto_command_Vertical_linetoParserRuleCall_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getVertical_linetoParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vertical_lineto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVertical_linetoRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Vertical_lineto_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// curveto
protected class Drawto_command_CurvetoParserRuleCall_4 extends RuleCallToken {
	
	public Drawto_command_CurvetoParserRuleCall_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getCurvetoParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCurvetoRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Curveto_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// smooth_curveto
protected class Drawto_command_Smooth_curvetoParserRuleCall_5 extends RuleCallToken {
	
	public Drawto_command_Smooth_curvetoParserRuleCall_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getSmooth_curvetoParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSmooth_curvetoRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Smooth_curveto_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// quadratic_bezier_curveto
protected class Drawto_command_Quadratic_bezier_curvetoParserRuleCall_6 extends RuleCallToken {
	
	public Drawto_command_Quadratic_bezier_curvetoParserRuleCall_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getQuadratic_bezier_curvetoParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getQuadratic_bezier_curveto_argument_sequenceRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Quadratic_bezier_curveto_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// smooth_quadratic_bezier_curveto
protected class Drawto_command_Smooth_quadratic_bezier_curvetoParserRuleCall_7 extends RuleCallToken {
	
	public Drawto_command_Smooth_quadratic_bezier_curvetoParserRuleCall_7(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getSmooth_quadratic_bezier_curvetoParserRuleCall_7();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSmooth_quadratic_bezier_curvetoRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Smooth_quadratic_bezier_curveto_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// elliptical_arc
protected class Drawto_command_Elliptical_arcParserRuleCall_8 extends RuleCallToken {
	
	public Drawto_command_Elliptical_arcParserRuleCall_8(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDrawto_commandAccess().getElliptical_arcParserRuleCall_8();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getElliptical_arcRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Elliptical_arc_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule drawto_command ****************/


/************ begin Rule closepath ****************
 *
 * closepath:
 * 	{closepath} ("Z" | "z");
 *
 **/

// {closepath} ("Z" | "z")
protected class Closepath_Group extends GroupToken {
	
	public Closepath_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosepathAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Closepath_Alternatives_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getClosepathAccess().getClosepathAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {closepath}
protected class Closepath_ClosepathAction_0 extends ActionToken  {

	public Closepath_ClosepathAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getClosepathAccess().getClosepathAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "Z" | "z"
protected class Closepath_Alternatives_1 extends AlternativesToken {

	public Closepath_Alternatives_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getClosepathAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Closepath_ZKeyword_1_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "Z"
protected class Closepath_ZKeyword_1_0 extends KeywordToken  {
	
	public Closepath_ZKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosepathAccess().getZKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Closepath_ClosepathAction_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule closepath ****************/


/************ begin Rule lineto ****************
 *
 * lineto:
 * 	("L" | "l") lineto_argument_sequence=lineto_argument_sequence;
 *
 **/

// ("L" | "l") lineto_argument_sequence=lineto_argument_sequence
protected class Lineto_Group extends GroupToken {
	
	public Lineto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLinetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lineto_Lineto_argument_sequenceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getLinetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "L" | "l"
protected class Lineto_Alternatives_0 extends AlternativesToken {

	public Lineto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLinetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lineto_LKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "L"
protected class Lineto_LKeyword_0_0 extends KeywordToken  {
	
	public Lineto_LKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLinetoAccess().getLKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// lineto_argument_sequence=lineto_argument_sequence
protected class Lineto_Lineto_argument_sequenceAssignment_1 extends AssignmentToken  {
	
	public Lineto_Lineto_argument_sequenceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLinetoAccess().getLineto_argument_sequenceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Lineto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("lineto_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("lineto_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLineto_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getLinetoAccess().getLineto_argument_sequenceLineto_argument_sequenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Lineto_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule lineto ****************/


/************ begin Rule horizontal_lineto ****************
 *
 * horizontal_lineto:
 * 	("H" | "h") horizontal_lineto_argument_sequence=horizontal_lineto_argument_sequence;
 *
 **/

// ("H" | "h") horizontal_lineto_argument_sequence=horizontal_lineto_argument_sequence
protected class Horizontal_lineto_Group extends GroupToken {
	
	public Horizontal_lineto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getHorizontal_linetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Horizontal_lineto_Horizontal_lineto_argument_sequenceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHorizontal_linetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "H" | "h"
protected class Horizontal_lineto_Alternatives_0 extends AlternativesToken {

	public Horizontal_lineto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getHorizontal_linetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Horizontal_lineto_HKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "H"
protected class Horizontal_lineto_HKeyword_0_0 extends KeywordToken  {
	
	public Horizontal_lineto_HKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getHorizontal_linetoAccess().getHKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// horizontal_lineto_argument_sequence=horizontal_lineto_argument_sequence
protected class Horizontal_lineto_Horizontal_lineto_argument_sequenceAssignment_1 extends AssignmentToken  {
	
	public Horizontal_lineto_Horizontal_lineto_argument_sequenceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHorizontal_linetoAccess().getHorizontal_lineto_argument_sequenceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Horizontal_lineto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("horizontal_lineto_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("horizontal_lineto_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHorizontal_lineto_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getHorizontal_linetoAccess().getHorizontal_lineto_argument_sequenceHorizontal_lineto_argument_sequenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Horizontal_lineto_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule horizontal_lineto ****************/


/************ begin Rule horizontal_lineto_argument_sequence ****************
 *
 * horizontal_lineto_argument_sequence:
 * 	coordinates+=coordinate (comma? coordinates+=coordinate)*;
 *
 **/

// coordinates+=coordinate (comma? coordinates+=coordinate)*
protected class Horizontal_lineto_argument_sequence_Group extends GroupToken {
	
	public Horizontal_lineto_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getHorizontal_lineto_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Horizontal_lineto_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Horizontal_lineto_argument_sequence_CoordinatesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getHorizontal_lineto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// coordinates+=coordinate
protected class Horizontal_lineto_argument_sequence_CoordinatesAssignment_0 extends AssignmentToken  {
	
	public Horizontal_lineto_argument_sequence_CoordinatesAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHorizontal_lineto_argument_sequenceAccess().getCoordinatesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_NumberParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("coordinates",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("coordinates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getHorizontal_lineto_argument_sequenceAccess().getCoordinatesCoordinateParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? coordinates+=coordinate)*
protected class Horizontal_lineto_argument_sequence_Group_1 extends GroupToken {
	
	public Horizontal_lineto_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getHorizontal_lineto_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Horizontal_lineto_argument_sequence_CoordinatesAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// coordinates+=coordinate
protected class Horizontal_lineto_argument_sequence_CoordinatesAssignment_1_1 extends AssignmentToken  {
	
	public Horizontal_lineto_argument_sequence_CoordinatesAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHorizontal_lineto_argument_sequenceAccess().getCoordinatesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_NumberParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("coordinates",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("coordinates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getHorizontal_lineto_argument_sequenceAccess().getCoordinatesCoordinateParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Horizontal_lineto_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Horizontal_lineto_argument_sequence_CoordinatesAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule horizontal_lineto_argument_sequence ****************/


/************ begin Rule vertical_lineto ****************
 *
 * vertical_lineto:
 * 	("V" | "v") vertical_lineto_argument_sequence=vertical_lineto_argument_sequence;
 *
 **/

// ("V" | "v") vertical_lineto_argument_sequence=vertical_lineto_argument_sequence
protected class Vertical_lineto_Group extends GroupToken {
	
	public Vertical_lineto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVertical_linetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vertical_lineto_Vertical_lineto_argument_sequenceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVertical_linetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "V" | "v"
protected class Vertical_lineto_Alternatives_0 extends AlternativesToken {

	public Vertical_lineto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getVertical_linetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vertical_lineto_VKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "V"
protected class Vertical_lineto_VKeyword_0_0 extends KeywordToken  {
	
	public Vertical_lineto_VKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVertical_linetoAccess().getVKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// vertical_lineto_argument_sequence=vertical_lineto_argument_sequence
protected class Vertical_lineto_Vertical_lineto_argument_sequenceAssignment_1 extends AssignmentToken  {
	
	public Vertical_lineto_Vertical_lineto_argument_sequenceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVertical_linetoAccess().getVertical_lineto_argument_sequenceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vertical_lineto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("vertical_lineto_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("vertical_lineto_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVertical_lineto_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVertical_linetoAccess().getVertical_lineto_argument_sequenceVertical_lineto_argument_sequenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Vertical_lineto_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule vertical_lineto ****************/


/************ begin Rule vertical_lineto_argument_sequence ****************
 *
 * vertical_lineto_argument_sequence:
 * 	coordinates+=coordinate (comma? coordinates+=coordinate)*;
 *
 **/

// coordinates+=coordinate (comma? coordinates+=coordinate)*
protected class Vertical_lineto_argument_sequence_Group extends GroupToken {
	
	public Vertical_lineto_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVertical_lineto_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vertical_lineto_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Vertical_lineto_argument_sequence_CoordinatesAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getVertical_lineto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// coordinates+=coordinate
protected class Vertical_lineto_argument_sequence_CoordinatesAssignment_0 extends AssignmentToken  {
	
	public Vertical_lineto_argument_sequence_CoordinatesAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVertical_lineto_argument_sequenceAccess().getCoordinatesAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_NumberParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("coordinates",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("coordinates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVertical_lineto_argument_sequenceAccess().getCoordinatesCoordinateParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? coordinates+=coordinate)*
protected class Vertical_lineto_argument_sequence_Group_1 extends GroupToken {
	
	public Vertical_lineto_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVertical_lineto_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Vertical_lineto_argument_sequence_CoordinatesAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// coordinates+=coordinate
protected class Vertical_lineto_argument_sequence_CoordinatesAssignment_1_1 extends AssignmentToken  {
	
	public Vertical_lineto_argument_sequence_CoordinatesAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVertical_lineto_argument_sequenceAccess().getCoordinatesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_NumberParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("coordinates",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("coordinates");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getVertical_lineto_argument_sequenceAccess().getCoordinatesCoordinateParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Vertical_lineto_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Vertical_lineto_argument_sequence_CoordinatesAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule vertical_lineto_argument_sequence ****************/


/************ begin Rule curveto ****************
 *
 * curveto:
 * 	("C" | "c") curveto_argument_sequence=curveto_argument_sequence;
 *
 **/

// ("C" | "c") curveto_argument_sequence=curveto_argument_sequence
protected class Curveto_Group extends GroupToken {
	
	public Curveto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCurvetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_Curveto_argument_sequenceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCurvetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "C" | "c"
protected class Curveto_Alternatives_0 extends AlternativesToken {

	public Curveto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCurvetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_CKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "C"
protected class Curveto_CKeyword_0_0 extends KeywordToken  {
	
	public Curveto_CKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCurvetoAccess().getCKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// curveto_argument_sequence=curveto_argument_sequence
protected class Curveto_Curveto_argument_sequenceAssignment_1 extends AssignmentToken  {
	
	public Curveto_Curveto_argument_sequenceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCurvetoAccess().getCurveto_argument_sequenceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("curveto_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("curveto_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCurveto_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCurvetoAccess().getCurveto_argument_sequenceCurveto_argument_sequenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Curveto_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule curveto ****************/


/************ begin Rule curveto_argument_sequence ****************
 *
 * curveto_argument_sequence:
 * 	curveto_arguments+=curveto_argument (comma? curveto_arguments+=curveto_argument)*;
 *
 **/

// curveto_arguments+=curveto_argument (comma? curveto_arguments+=curveto_argument)*
protected class Curveto_argument_sequence_Group extends GroupToken {
	
	public Curveto_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCurveto_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Curveto_argument_sequence_Curveto_argumentsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCurveto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// curveto_arguments+=curveto_argument
protected class Curveto_argument_sequence_Curveto_argumentsAssignment_0 extends AssignmentToken  {
	
	public Curveto_argument_sequence_Curveto_argumentsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCurveto_argument_sequenceAccess().getCurveto_argumentsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("curveto_arguments",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("curveto_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCurveto_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCurveto_argument_sequenceAccess().getCurveto_argumentsCurveto_argumentParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? curveto_arguments+=curveto_argument)*
protected class Curveto_argument_sequence_Group_1 extends GroupToken {
	
	public Curveto_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCurveto_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_argument_sequence_Curveto_argumentsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// curveto_arguments+=curveto_argument
protected class Curveto_argument_sequence_Curveto_argumentsAssignment_1_1 extends AssignmentToken  {
	
	public Curveto_argument_sequence_Curveto_argumentsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCurveto_argument_sequenceAccess().getCurveto_argumentsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("curveto_arguments",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("curveto_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCurveto_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCurveto_argument_sequenceAccess().getCurveto_argumentsCurveto_argumentParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Curveto_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Curveto_argument_sequence_Curveto_argumentsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule curveto_argument_sequence ****************/


/************ begin Rule curveto_argument ****************
 *
 * curveto_argument:
 * 	c1=coordinate_pair comma? c2=coordinate_pair comma? c3=coordinate_pair;
 *
 **/

// c1=coordinate_pair comma? c2=coordinate_pair comma? c3=coordinate_pair
protected class Curveto_argument_Group extends GroupToken {
	
	public Curveto_argument_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCurveto_argumentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Curveto_argument_C3Assignment_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCurveto_argumentRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// c1=coordinate_pair
protected class Curveto_argument_C1Assignment_0 extends AssignmentToken  {
	
	public Curveto_argument_C1Assignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCurveto_argumentAccess().getC1Assignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c1",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCurveto_argumentAccess().getC1Coordinate_pairParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// c2=coordinate_pair
protected class Curveto_argument_C2Assignment_2 extends AssignmentToken  {
	
	public Curveto_argument_C2Assignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCurveto_argumentAccess().getC2Assignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c2",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCurveto_argumentAccess().getC2Coordinate_pairParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Curveto_argument_C1Assignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// c3=coordinate_pair
protected class Curveto_argument_C3Assignment_4 extends AssignmentToken  {
	
	public Curveto_argument_C3Assignment_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCurveto_argumentAccess().getC3Assignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c3",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c3");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCurveto_argumentAccess().getC3Coordinate_pairParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Curveto_argument_C2Assignment_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule curveto_argument ****************/


/************ begin Rule smooth_curveto ****************
 *
 * smooth_curveto:
 * 	("S" | "s") smooth_curveto_argument_sequence=smooth_curveto_argument_sequence;
 *
 **/

// ("S" | "s") smooth_curveto_argument_sequence=smooth_curveto_argument_sequence
protected class Smooth_curveto_Group extends GroupToken {
	
	public Smooth_curveto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSmooth_curvetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_Smooth_curveto_argument_sequenceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSmooth_curvetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "S" | "s"
protected class Smooth_curveto_Alternatives_0 extends AlternativesToken {

	public Smooth_curveto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSmooth_curvetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_SKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "S"
protected class Smooth_curveto_SKeyword_0_0 extends KeywordToken  {
	
	public Smooth_curveto_SKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSmooth_curvetoAccess().getSKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// smooth_curveto_argument_sequence=smooth_curveto_argument_sequence
protected class Smooth_curveto_Smooth_curveto_argument_sequenceAssignment_1 extends AssignmentToken  {
	
	public Smooth_curveto_Smooth_curveto_argument_sequenceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_curvetoAccess().getSmooth_curveto_argument_sequenceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("smooth_curveto_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("smooth_curveto_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSmooth_curveto_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_curvetoAccess().getSmooth_curveto_argument_sequenceSmooth_curveto_argument_sequenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Smooth_curveto_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule smooth_curveto ****************/


/************ begin Rule smooth_curveto_argument_sequence ****************
 *
 * smooth_curveto_argument_sequence:
 * 	smooth_curveto_arguments+=smooth_curveto_argument (comma? smooth_curveto_arguments+=smooth_curveto_argument)*;
 *
 **/

// smooth_curveto_arguments+=smooth_curveto_argument (comma? smooth_curveto_arguments+=smooth_curveto_argument)*
protected class Smooth_curveto_argument_sequence_Group extends GroupToken {
	
	public Smooth_curveto_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSmooth_curveto_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Smooth_curveto_argument_sequence_Smooth_curveto_argumentsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSmooth_curveto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// smooth_curveto_arguments+=smooth_curveto_argument
protected class Smooth_curveto_argument_sequence_Smooth_curveto_argumentsAssignment_0 extends AssignmentToken  {
	
	public Smooth_curveto_argument_sequence_Smooth_curveto_argumentsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_curveto_argument_sequenceAccess().getSmooth_curveto_argumentsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("smooth_curveto_arguments",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("smooth_curveto_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSmooth_curveto_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_curveto_argument_sequenceAccess().getSmooth_curveto_argumentsSmooth_curveto_argumentParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? smooth_curveto_arguments+=smooth_curveto_argument)*
protected class Smooth_curveto_argument_sequence_Group_1 extends GroupToken {
	
	public Smooth_curveto_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSmooth_curveto_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_argument_sequence_Smooth_curveto_argumentsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// smooth_curveto_arguments+=smooth_curveto_argument
protected class Smooth_curveto_argument_sequence_Smooth_curveto_argumentsAssignment_1_1 extends AssignmentToken  {
	
	public Smooth_curveto_argument_sequence_Smooth_curveto_argumentsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_curveto_argument_sequenceAccess().getSmooth_curveto_argumentsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("smooth_curveto_arguments",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("smooth_curveto_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSmooth_curveto_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_curveto_argument_sequenceAccess().getSmooth_curveto_argumentsSmooth_curveto_argumentParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Smooth_curveto_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Smooth_curveto_argument_sequence_Smooth_curveto_argumentsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule smooth_curveto_argument_sequence ****************/


/************ begin Rule smooth_curveto_argument ****************
 *
 * smooth_curveto_argument:
 * 	c1=coordinate_pair comma? c2=coordinate_pair;
 *
 **/

// c1=coordinate_pair comma? c2=coordinate_pair
protected class Smooth_curveto_argument_Group extends GroupToken {
	
	public Smooth_curveto_argument_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSmooth_curveto_argumentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_curveto_argument_C2Assignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSmooth_curveto_argumentRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// c1=coordinate_pair
protected class Smooth_curveto_argument_C1Assignment_0 extends AssignmentToken  {
	
	public Smooth_curveto_argument_C1Assignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_curveto_argumentAccess().getC1Assignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c1",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_curveto_argumentAccess().getC1Coordinate_pairParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// c2=coordinate_pair
protected class Smooth_curveto_argument_C2Assignment_2 extends AssignmentToken  {
	
	public Smooth_curveto_argument_C2Assignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_curveto_argumentAccess().getC2Assignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c2",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_curveto_argumentAccess().getC2Coordinate_pairParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Smooth_curveto_argument_C1Assignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule smooth_curveto_argument ****************/


/************ begin Rule quadratic_bezier_curveto ****************
 *
 * quadratic_bezier_curveto:
 * 	("Q" | "q") quadratic_bezier_curveto_argument_sequence;
 *
 **/

// ("Q" | "q") quadratic_bezier_curveto_argument_sequence
protected class Quadratic_bezier_curveto_Group extends GroupToken {
	
	public Quadratic_bezier_curveto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curvetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_Quadratic_bezier_curveto_argument_sequenceParserRuleCall_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getQuadratic_bezier_curveto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "Q" | "q"
protected class Quadratic_bezier_curveto_Alternatives_0 extends AlternativesToken {

	public Quadratic_bezier_curveto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curvetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_QKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "Q"
protected class Quadratic_bezier_curveto_QKeyword_0_0 extends KeywordToken  {
	
	public Quadratic_bezier_curveto_QKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curvetoAccess().getQKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// quadratic_bezier_curveto_argument_sequence
protected class Quadratic_bezier_curveto_Quadratic_bezier_curveto_argument_sequenceParserRuleCall_1 extends RuleCallToken {
	
	public Quadratic_bezier_curveto_Quadratic_bezier_curveto_argument_sequenceParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curvetoAccess().getQuadratic_bezier_curveto_argument_sequenceParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(Quadratic_bezier_curveto_argument_sequence_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_Alternatives_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}


/************ end Rule quadratic_bezier_curveto ****************/


/************ begin Rule quadratic_bezier_curveto_argument_sequence ****************
 *
 * quadratic_bezier_curveto_argument_sequence:
 * 	quadratic_bezier_curveto_arguments+=quadratic_bezier_curveto_argument (comma?
 * 	quadratic_bezier_curveto_arguments+=quadratic_bezier_curveto_argument)*;
 *
 **/

// quadratic_bezier_curveto_arguments+=quadratic_bezier_curveto_argument (comma?
// quadratic_bezier_curveto_arguments+=quadratic_bezier_curveto_argument)*
protected class Quadratic_bezier_curveto_argument_sequence_Group extends GroupToken {
	
	public Quadratic_bezier_curveto_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curveto_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Quadratic_bezier_curveto_argument_sequence_Quadratic_bezier_curveto_argumentsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getQuadratic_bezier_curveto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// quadratic_bezier_curveto_arguments+=quadratic_bezier_curveto_argument
protected class Quadratic_bezier_curveto_argument_sequence_Quadratic_bezier_curveto_argumentsAssignment_0 extends AssignmentToken  {
	
	public Quadratic_bezier_curveto_argument_sequence_Quadratic_bezier_curveto_argumentsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curveto_argument_sequenceAccess().getQuadratic_bezier_curveto_argumentsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("quadratic_bezier_curveto_arguments",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("quadratic_bezier_curveto_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQuadratic_bezier_curveto_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getQuadratic_bezier_curveto_argument_sequenceAccess().getQuadratic_bezier_curveto_argumentsQuadratic_bezier_curveto_argumentParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? quadratic_bezier_curveto_arguments+=quadratic_bezier_curveto_argument)*
protected class Quadratic_bezier_curveto_argument_sequence_Group_1 extends GroupToken {
	
	public Quadratic_bezier_curveto_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curveto_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_sequence_Quadratic_bezier_curveto_argumentsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// quadratic_bezier_curveto_arguments+=quadratic_bezier_curveto_argument
protected class Quadratic_bezier_curveto_argument_sequence_Quadratic_bezier_curveto_argumentsAssignment_1_1 extends AssignmentToken  {
	
	public Quadratic_bezier_curveto_argument_sequence_Quadratic_bezier_curveto_argumentsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curveto_argument_sequenceAccess().getQuadratic_bezier_curveto_argumentsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("quadratic_bezier_curveto_arguments",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("quadratic_bezier_curveto_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQuadratic_bezier_curveto_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getQuadratic_bezier_curveto_argument_sequenceAccess().getQuadratic_bezier_curveto_argumentsQuadratic_bezier_curveto_argumentParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Quadratic_bezier_curveto_argument_sequence_Quadratic_bezier_curveto_argumentsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule quadratic_bezier_curveto_argument_sequence ****************/


/************ begin Rule quadratic_bezier_curveto_argument ****************
 *
 * quadratic_bezier_curveto_argument:
 * 	c1=coordinate_pair comma? c2=coordinate_pair;
 *
 **/

// c1=coordinate_pair comma? c2=coordinate_pair
protected class Quadratic_bezier_curveto_argument_Group extends GroupToken {
	
	public Quadratic_bezier_curveto_argument_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curveto_argumentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_C2Assignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getQuadratic_bezier_curveto_argumentRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// c1=coordinate_pair
protected class Quadratic_bezier_curveto_argument_C1Assignment_0 extends AssignmentToken  {
	
	public Quadratic_bezier_curveto_argument_C1Assignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curveto_argumentAccess().getC1Assignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c1",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getQuadratic_bezier_curveto_argumentAccess().getC1Coordinate_pairParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// c2=coordinate_pair
protected class Quadratic_bezier_curveto_argument_C2Assignment_2 extends AssignmentToken  {
	
	public Quadratic_bezier_curveto_argument_C2Assignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQuadratic_bezier_curveto_argumentAccess().getC2Assignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c2",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getQuadratic_bezier_curveto_argumentAccess().getC2Coordinate_pairParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Quadratic_bezier_curveto_argument_C1Assignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule quadratic_bezier_curveto_argument ****************/


/************ begin Rule smooth_quadratic_bezier_curveto ****************
 *
 * smooth_quadratic_bezier_curveto:
 * 	("T" | "t") smooth_quadratic_bezier_curveto_argument_sequence=smooth_quadratic_bezier_curveto_argument_sequence;
 *
 **/

// ("T" | "t") smooth_quadratic_bezier_curveto_argument_sequence=smooth_quadratic_bezier_curveto_argument_sequence
protected class Smooth_quadratic_bezier_curveto_Group extends GroupToken {
	
	public Smooth_quadratic_bezier_curveto_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curvetoAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_Smooth_quadratic_bezier_curveto_argument_sequenceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSmooth_quadratic_bezier_curvetoRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "T" | "t"
protected class Smooth_quadratic_bezier_curveto_Alternatives_0 extends AlternativesToken {

	public Smooth_quadratic_bezier_curveto_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curvetoAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_TKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "T"
protected class Smooth_quadratic_bezier_curveto_TKeyword_0_0 extends KeywordToken  {
	
	public Smooth_quadratic_bezier_curveto_TKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curvetoAccess().getTKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// smooth_quadratic_bezier_curveto_argument_sequence=smooth_quadratic_bezier_curveto_argument_sequence
protected class Smooth_quadratic_bezier_curveto_Smooth_quadratic_bezier_curveto_argument_sequenceAssignment_1 extends AssignmentToken  {
	
	public Smooth_quadratic_bezier_curveto_Smooth_quadratic_bezier_curveto_argument_sequenceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curvetoAccess().getSmooth_quadratic_bezier_curveto_argument_sequenceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("smooth_quadratic_bezier_curveto_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("smooth_quadratic_bezier_curveto_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_quadratic_bezier_curvetoAccess().getSmooth_quadratic_bezier_curveto_argument_sequenceSmooth_quadratic_bezier_curveto_argument_sequenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule smooth_quadratic_bezier_curveto ****************/


/************ begin Rule smooth_quadratic_bezier_curveto_argument_sequence ****************
 *
 * smooth_quadratic_bezier_curveto_argument_sequence:
 * 	coordinate_pairs+=coordinate_pair (comma? coordinate_pairs+=coordinate_pair)*;
 *
 **/

// coordinate_pairs+=coordinate_pair (comma? coordinate_pairs+=coordinate_pair)*
protected class Smooth_quadratic_bezier_curveto_argument_sequence_Group extends GroupToken {
	
	public Smooth_quadratic_bezier_curveto_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Smooth_quadratic_bezier_curveto_argument_sequence_Coordinate_pairsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// coordinate_pairs+=coordinate_pair
protected class Smooth_quadratic_bezier_curveto_argument_sequence_Coordinate_pairsAssignment_0 extends AssignmentToken  {
	
	public Smooth_quadratic_bezier_curveto_argument_sequence_Coordinate_pairsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceAccess().getCoordinate_pairsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("coordinate_pairs",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("coordinate_pairs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceAccess().getCoordinate_pairsCoordinate_pairParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? coordinate_pairs+=coordinate_pair)*
protected class Smooth_quadratic_bezier_curveto_argument_sequence_Group_1 extends GroupToken {
	
	public Smooth_quadratic_bezier_curveto_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_argument_sequence_Coordinate_pairsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// coordinate_pairs+=coordinate_pair
protected class Smooth_quadratic_bezier_curveto_argument_sequence_Coordinate_pairsAssignment_1_1 extends AssignmentToken  {
	
	public Smooth_quadratic_bezier_curveto_argument_sequence_Coordinate_pairsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceAccess().getCoordinate_pairsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("coordinate_pairs",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("coordinate_pairs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getSmooth_quadratic_bezier_curveto_argument_sequenceAccess().getCoordinate_pairsCoordinate_pairParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Smooth_quadratic_bezier_curveto_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Smooth_quadratic_bezier_curveto_argument_sequence_Coordinate_pairsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule smooth_quadratic_bezier_curveto_argument_sequence ****************/


/************ begin Rule elliptical_arc ****************
 *
 * elliptical_arc:
 * 	("A" | "a") elliptical_arc_argument_sequence=elliptical_arc_argument_sequence;
 *
 **/

// ("A" | "a") elliptical_arc_argument_sequence=elliptical_arc_argument_sequence
protected class Elliptical_arc_Group extends GroupToken {
	
	public Elliptical_arc_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getElliptical_arcAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_Elliptical_arc_argument_sequenceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getElliptical_arcRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "A" | "a"
protected class Elliptical_arc_Alternatives_0 extends AlternativesToken {

	public Elliptical_arc_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getElliptical_arcAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_AKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "A"
protected class Elliptical_arc_AKeyword_0_0 extends KeywordToken  {
	
	public Elliptical_arc_AKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getElliptical_arcAccess().getAKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// elliptical_arc_argument_sequence=elliptical_arc_argument_sequence
protected class Elliptical_arc_Elliptical_arc_argument_sequenceAssignment_1 extends AssignmentToken  {
	
	public Elliptical_arc_Elliptical_arc_argument_sequenceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arcAccess().getElliptical_arc_argument_sequenceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_sequence_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("elliptical_arc_argument_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("elliptical_arc_argument_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getElliptical_arc_argument_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getElliptical_arcAccess().getElliptical_arc_argument_sequenceElliptical_arc_argument_sequenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Elliptical_arc_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule elliptical_arc ****************/


/************ begin Rule elliptical_arc_argument_sequence ****************
 *
 * elliptical_arc_argument_sequence:
 * 	elliptical_arc_arguments+=elliptical_arc_argument (comma? elliptical_arc_arguments+=elliptical_arc_argument)*;
 *
 **/

// elliptical_arc_arguments+=elliptical_arc_argument (comma? elliptical_arc_arguments+=elliptical_arc_argument)*
protected class Elliptical_arc_argument_sequence_Group extends GroupToken {
	
	public Elliptical_arc_argument_sequence_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getElliptical_arc_argument_sequenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_sequence_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Elliptical_arc_argument_sequence_Elliptical_arc_argumentsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getElliptical_arc_argument_sequenceRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// elliptical_arc_arguments+=elliptical_arc_argument
protected class Elliptical_arc_argument_sequence_Elliptical_arc_argumentsAssignment_0 extends AssignmentToken  {
	
	public Elliptical_arc_argument_sequence_Elliptical_arc_argumentsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argument_sequenceAccess().getElliptical_arc_argumentsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("elliptical_arc_arguments",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("elliptical_arc_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getElliptical_arc_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getElliptical_arc_argument_sequenceAccess().getElliptical_arc_argumentsElliptical_arc_argumentParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// (comma? elliptical_arc_arguments+=elliptical_arc_argument)*
protected class Elliptical_arc_argument_sequence_Group_1 extends GroupToken {
	
	public Elliptical_arc_argument_sequence_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getElliptical_arc_argument_sequenceAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_sequence_Elliptical_arc_argumentsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// elliptical_arc_arguments+=elliptical_arc_argument
protected class Elliptical_arc_argument_sequence_Elliptical_arc_argumentsAssignment_1_1 extends AssignmentToken  {
	
	public Elliptical_arc_argument_sequence_Elliptical_arc_argumentsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argument_sequenceAccess().getElliptical_arc_argumentsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("elliptical_arc_arguments",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("elliptical_arc_arguments");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getElliptical_arc_argumentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getElliptical_arc_argument_sequenceAccess().getElliptical_arc_argumentsElliptical_arc_argumentParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Elliptical_arc_argument_sequence_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Elliptical_arc_argument_sequence_Elliptical_arc_argumentsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule elliptical_arc_argument_sequence ****************/


/************ begin Rule elliptical_arc_argument ****************
 *
 * elliptical_arc_argument:
 * 	rx=nonnegative_number comma? ry=nonnegative_number comma? rotation=number comma largearcflag=flag comma?
 * 	sweepflag=flag comma? coordinate_pair=coordinate_pair;
 *
 **/

// rx=nonnegative_number comma? ry=nonnegative_number comma? rotation=number comma largearcflag=flag comma? sweepflag=flag
// comma? coordinate_pair=coordinate_pair
protected class Elliptical_arc_argument_Group extends GroupToken {
	
	public Elliptical_arc_argument_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_Coordinate_pairAssignment_10(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getElliptical_arc_argumentRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// rx=nonnegative_number
protected class Elliptical_arc_argument_RxAssignment_0 extends AssignmentToken  {
	
	public Elliptical_arc_argument_RxAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getRxAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Nonnegative_number_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rx",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rx");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNonnegative_numberRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getElliptical_arc_argumentAccess().getRxNonnegative_numberParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ry=nonnegative_number
protected class Elliptical_arc_argument_RyAssignment_2 extends AssignmentToken  {
	
	public Elliptical_arc_argument_RyAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getRyAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Nonnegative_number_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ry",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ry");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNonnegative_numberRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getElliptical_arc_argumentAccess().getRyNonnegative_numberParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Elliptical_arc_argument_RxAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// rotation=number
protected class Elliptical_arc_argument_RotationAssignment_4 extends AssignmentToken  {
	
	public Elliptical_arc_argument_RotationAssignment_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getRotationAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Number_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rotation",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rotation");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNumberRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getElliptical_arc_argumentAccess().getRotationNumberParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Elliptical_arc_argument_RyAssignment_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// comma
protected class Elliptical_arc_argument_CommaParserRuleCall_5 extends UnassignedTextToken {

	public Elliptical_arc_argument_CommaParserRuleCall_5(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getCommaParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_RotationAssignment_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// largearcflag=flag
protected class Elliptical_arc_argument_LargearcflagAssignment_6 extends AssignmentToken  {
	
	public Elliptical_arc_argument_LargearcflagAssignment_6(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getLargearcflagAssignment_6();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_CommaParserRuleCall_5(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("largearcflag",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("largearcflag");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getElliptical_arc_argumentAccess().getLargearcflagFlagParserRuleCall_6_0(), value, null)) {
			type = AssignmentType.DATATYPE_RULE_CALL;
			element = grammarAccess.getElliptical_arc_argumentAccess().getLargearcflagFlagParserRuleCall_6_0();
			return obj;
		}
		return null;
	}

}

// sweepflag=flag
protected class Elliptical_arc_argument_SweepflagAssignment_8 extends AssignmentToken  {
	
	public Elliptical_arc_argument_SweepflagAssignment_8(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getSweepflagAssignment_8();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Elliptical_arc_argument_LargearcflagAssignment_6(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("sweepflag",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("sweepflag");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getElliptical_arc_argumentAccess().getSweepflagFlagParserRuleCall_8_0(), value, null)) {
			type = AssignmentType.DATATYPE_RULE_CALL;
			element = grammarAccess.getElliptical_arc_argumentAccess().getSweepflagFlagParserRuleCall_8_0();
			return obj;
		}
		return null;
	}

}

// coordinate_pair=coordinate_pair
protected class Elliptical_arc_argument_Coordinate_pairAssignment_10 extends AssignmentToken  {
	
	public Elliptical_arc_argument_Coordinate_pairAssignment_10(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElliptical_arc_argumentAccess().getCoordinate_pairAssignment_10();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("coordinate_pair",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("coordinate_pair");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinate_pairRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getElliptical_arc_argumentAccess().getCoordinate_pairCoordinate_pairParserRuleCall_10_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Elliptical_arc_argument_SweepflagAssignment_8(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule elliptical_arc_argument ****************/


/************ begin Rule coordinate_pair ****************
 *
 * coordinate_pair:
 * 	c1=coordinate comma? c2=coordinate;
 *
 **/

// c1=coordinate comma? c2=coordinate
protected class Coordinate_pair_Group extends GroupToken {
	
	public Coordinate_pair_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCoordinate_pairAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_pair_C2Assignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCoordinate_pairRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// c1=coordinate
protected class Coordinate_pair_C1Assignment_0 extends AssignmentToken  {
	
	public Coordinate_pair_C1Assignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCoordinate_pairAccess().getC1Assignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_NumberParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c1",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCoordinate_pairAccess().getC1CoordinateParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// c2=coordinate
protected class Coordinate_pair_C2Assignment_2 extends AssignmentToken  {
	
	public Coordinate_pair_C2Assignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCoordinate_pairAccess().getC2Assignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Coordinate_NumberParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c2",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCoordinateRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCoordinate_pairAccess().getC2CoordinateParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Coordinate_pair_C1Assignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule coordinate_pair ****************/



/************ begin Rule coordinate ****************
 *
 * coordinate:
 * 	number;
 *
 **/

// number
protected class Coordinate_NumberParserRuleCall extends RuleCallToken {
	
	public Coordinate_NumberParserRuleCall(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCoordinateAccess().getNumberParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Number_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNumberRule().getType().getClassifier())
			return null;
		if(checkForRecursion(Number_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule coordinate ****************/


/************ begin Rule number ****************
 *
 * number:
 * 	sign=sign? nonnegative_number=nonnegative_number;
 *
 **/

// sign=sign? nonnegative_number=nonnegative_number
protected class Number_Group extends GroupToken {
	
	public Number_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNumberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Number_Nonnegative_numberAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNumberRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// sign=sign?
protected class Number_SignAssignment_0 extends AssignmentToken  {
	
	public Number_SignAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNumberAccess().getSignAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("sign",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("sign");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getNumberAccess().getSignSignParserRuleCall_0_0(), value, null)) {
			type = AssignmentType.DATATYPE_RULE_CALL;
			element = grammarAccess.getNumberAccess().getSignSignParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// nonnegative_number=nonnegative_number
protected class Number_Nonnegative_numberAssignment_1 extends AssignmentToken  {
	
	public Number_Nonnegative_numberAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNumberAccess().getNonnegative_numberAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Nonnegative_number_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("nonnegative_number",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nonnegative_number");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNonnegative_numberRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNumberAccess().getNonnegative_numberNonnegative_numberParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Number_SignAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule number ****************/


/************ begin Rule nonnegative_number ****************
 *
 * nonnegative_number:
 * 	intseq=digit_sequence ("." floatseq=digit_sequence)? exponent=exponent?;
 *
 **/

// intseq=digit_sequence ("." floatseq=digit_sequence)? exponent=exponent?
protected class Nonnegative_number_Group extends GroupToken {
	
	public Nonnegative_number_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNonnegative_numberAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Nonnegative_number_ExponentAssignment_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Nonnegative_number_Group_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Nonnegative_number_IntseqAssignment_0(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNonnegative_numberRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// intseq=digit_sequence
protected class Nonnegative_number_IntseqAssignment_0 extends AssignmentToken  {
	
	public Nonnegative_number_IntseqAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNonnegative_numberAccess().getIntseqAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Digit_sequence_DigitsAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("intseq",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("intseq");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDigit_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNonnegative_numberAccess().getIntseqDigit_sequenceParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("." floatseq=digit_sequence)?
protected class Nonnegative_number_Group_1 extends GroupToken {
	
	public Nonnegative_number_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNonnegative_numberAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Nonnegative_number_FloatseqAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "."
protected class Nonnegative_number_FullStopKeyword_1_0 extends KeywordToken  {
	
	public Nonnegative_number_FullStopKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNonnegative_numberAccess().getFullStopKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Nonnegative_number_IntseqAssignment_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// floatseq=digit_sequence
protected class Nonnegative_number_FloatseqAssignment_1_1 extends AssignmentToken  {
	
	public Nonnegative_number_FloatseqAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNonnegative_numberAccess().getFloatseqAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Digit_sequence_DigitsAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("floatseq",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("floatseq");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDigit_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNonnegative_numberAccess().getFloatseqDigit_sequenceParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Nonnegative_number_FullStopKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// exponent=exponent?
protected class Nonnegative_number_ExponentAssignment_2 extends AssignmentToken  {
	
	public Nonnegative_number_ExponentAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNonnegative_numberAccess().getExponentAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Exponent_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("exponent",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("exponent");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExponentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNonnegative_numberAccess().getExponentExponentParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Nonnegative_number_Group_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Nonnegative_number_IntseqAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule nonnegative_number ****************/


/************ begin Rule exponent ****************
 *
 * exponent:
 * 	("e" | "E") sign=sign? digit_sequence=digit_sequence;
 *
 **/

// ("e" | "E") sign=sign? digit_sequence=digit_sequence
protected class Exponent_Group extends GroupToken {
	
	public Exponent_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExponentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Exponent_Digit_sequenceAssignment_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getExponentRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "e" | "E"
protected class Exponent_Alternatives_0 extends AlternativesToken {

	public Exponent_Alternatives_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExponentAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Exponent_EKeyword_0_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "e"
protected class Exponent_EKeyword_0_0 extends KeywordToken  {
	
	public Exponent_EKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExponentAccess().getEKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


// sign=sign?
protected class Exponent_SignAssignment_1 extends AssignmentToken  {
	
	public Exponent_SignAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExponentAccess().getSignAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Exponent_Alternatives_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("sign",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("sign");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getExponentAccess().getSignSignParserRuleCall_1_0(), value, null)) {
			type = AssignmentType.DATATYPE_RULE_CALL;
			element = grammarAccess.getExponentAccess().getSignSignParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// digit_sequence=digit_sequence
protected class Exponent_Digit_sequenceAssignment_2 extends AssignmentToken  {
	
	public Exponent_Digit_sequenceAssignment_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExponentAccess().getDigit_sequenceAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Digit_sequence_DigitsAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("digit_sequence",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("digit_sequence");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDigit_sequenceRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getExponentAccess().getDigit_sequenceDigit_sequenceParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Exponent_SignAssignment_1(lastRuleCallOrigin, next, actIndex, consumed);
			case 1: return new Exponent_Alternatives_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule exponent ****************/


/************ begin Rule digit_sequence ****************
 *
 * digit_sequence:
 * 	digits+=digit;
 *
 **/

// digits+=digit
protected class Digit_sequence_DigitsAssignment extends AssignmentToken  {
	
	public Digit_sequence_DigitsAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDigit_sequenceAccess().getDigitsAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getDigit_sequenceRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("digits",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("digits");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getDigit_sequenceAccess().getDigitsDigitParserRuleCall_0(), value, null)) {
			type = AssignmentType.DATATYPE_RULE_CALL;
			element = grammarAccess.getDigit_sequenceAccess().getDigitsDigitParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule digit_sequence ****************/




}
