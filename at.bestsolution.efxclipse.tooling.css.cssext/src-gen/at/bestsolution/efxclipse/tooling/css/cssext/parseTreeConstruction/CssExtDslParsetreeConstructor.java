/*
* generated by Xtext
*/
package at.bestsolution.efxclipse.tooling.css.cssext.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import at.bestsolution.efxclipse.tooling.css.cssext.services.CssExtDslGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public class CssExtDslParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private CssExtDslGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CssExtension_Group(this, this, 0, inst);
			case 1: return new Import_Group(this, this, 1, inst);
			case 2: return new PackageDeclaration_Group(this, this, 2, inst);
			case 3: return new CSSRuleSet_RulesAssignment(this, this, 3, inst);
			case 4: return new CSSRuleId_NameAssignment(this, this, 4, inst);
			case 5: return new CSSRuleRef_Group(this, this, 5, inst);
			case 6: return new CSSRuleAssignment_Group(this, this, 6, inst);
			case 7: return new CSSRuleOrExpression_Group(this, this, 7, inst);
			case 8: return new CSSRuleXorExpression_Group(this, this, 8, inst);
			case 9: return new CSSRuleBracketExpression_Group(this, this, 9, inst);
			case 10: return new CSSRulePostfixExpression_Group(this, this, 10, inst);
			case 11: return new CSSRuleConcat_Group(this, this, 11, inst);
			case 12: return new CSSRulePrimaryExpression_Alternatives(this, this, 12, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule CssExtension ****************
 *
 * //	packageDef=PackageDeclaration?
 * //	rule=CSSRuleSet
 * CssExtension:
 * 	imports+=Import* packageDef=PackageDeclaration?;
 *
 **/

// imports+=Import* packageDef=PackageDeclaration?
protected class CssExtension_Group extends GroupToken {
	
	public CssExtension_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCssExtensionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CssExtension_PackageDefAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CssExtension_ImportsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index - 2, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCssExtensionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// imports+=Import*
protected class CssExtension_ImportsAssignment_0 extends AssignmentToken  {
	
	public CssExtension_ImportsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCssExtensionAccess().getImportsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Import_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("imports",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("imports");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCssExtensionAccess().getImportsImportParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CssExtension_ImportsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index - 1, consumed);
		}	
	}	
}

// packageDef=PackageDeclaration?
protected class CssExtension_PackageDefAssignment_1 extends AssignmentToken  {
	
	public CssExtension_PackageDefAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCssExtensionAccess().getPackageDefAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PackageDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("packageDef",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("packageDef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPackageDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCssExtensionAccess().getPackageDefPackageDeclarationParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CssExtension_ImportsAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule CssExtension ****************/


/************ begin Rule Import ****************
 *
 * Import:
 * 	"import" importedNamespace=QualifiedNameWithWildCard;
 *
 **/

// "import" importedNamespace=QualifiedNameWithWildCard
protected class Import_Group extends GroupToken {
	
	public Import_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImportAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Import_ImportedNamespaceAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getImportRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "import"
protected class Import_ImportKeyword_0 extends KeywordToken  {
	
	public Import_ImportKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getImportAccess().getImportKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// importedNamespace=QualifiedNameWithWildCard
protected class Import_ImportedNamespaceAssignment_1 extends AssignmentToken  {
	
	public Import_ImportedNamespaceAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImportAccess().getImportedNamespaceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Import_ImportKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("importedNamespace",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("importedNamespace");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0(), value, null)) {
			type = AssignmentType.DATATYPE_RULE_CALL;
			element = grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Import ****************/





/************ begin Rule PackageDeclaration ****************
 *
 * PackageDeclaration:
 * 	"package" name=QualifiedName "{" rule=CSSRuleSet? "}";
 *
 **/

// "package" name=QualifiedName "{" rule=CSSRuleSet? "}"
protected class PackageDeclaration_Group extends GroupToken {
	
	public PackageDeclaration_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPackageDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PackageDeclaration_RightCurlyBracketKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getPackageDeclarationRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "package"
protected class PackageDeclaration_PackageKeyword_0 extends KeywordToken  {
	
	public PackageDeclaration_PackageKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageDeclarationAccess().getPackageKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// name=QualifiedName
protected class PackageDeclaration_NameAssignment_1 extends AssignmentToken  {
	
	public PackageDeclaration_NameAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPackageDeclarationAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PackageDeclaration_PackageKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getPackageDeclarationAccess().getNameQualifiedNameParserRuleCall_1_0(), value, null)) {
			type = AssignmentType.DATATYPE_RULE_CALL;
			element = grammarAccess.getPackageDeclarationAccess().getNameQualifiedNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class PackageDeclaration_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public PackageDeclaration_LeftCurlyBracketKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageDeclarationAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PackageDeclaration_NameAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// rule=CSSRuleSet?
protected class PackageDeclaration_RuleAssignment_3 extends AssignmentToken  {
	
	public PackageDeclaration_RuleAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPackageDeclarationAccess().getRuleAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleSet_RulesAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rule",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rule");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRuleSetRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getPackageDeclarationAccess().getRuleCSSRuleSetParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PackageDeclaration_LeftCurlyBracketKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class PackageDeclaration_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public PackageDeclaration_RightCurlyBracketKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageDeclarationAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new PackageDeclaration_RuleAssignment_3(lastRuleCallOrigin, this, 0, inst);
			case 1: return new PackageDeclaration_LeftCurlyBracketKeyword_2(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}


/************ end Rule PackageDeclaration ****************/


/************ begin Rule CSSRuleSet ****************
 *
 * //PackageDeclaration:
 * //	'package' name=QualifiedName '{'
 * //		typDefs+=TypeDef? (',' typDefs+=TypeDef)*
 * //		elementDefs+=ElementDef? (',' elementDefs+=ElementDef)*
 * //		subpackages+=PackageDeclaration*
 * //	'}';
 * //
 * //TypeDef:
 * //	GenericTypeDef | EnumTypeDef
 * //;
 * CSSRuleSet:
 * 	rules+=CSSRuleAssignment+;
 *
 **/

// rules+=CSSRuleAssignment+
protected class CSSRuleSet_RulesAssignment extends AssignmentToken  {
	
	public CSSRuleSet_RulesAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleSetAccess().getRulesAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleAssignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("rules",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("rules");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRuleAssignmentRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleSetAccess().getRulesCSSRuleAssignmentParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CSSRuleSet_RulesAssignment(lastRuleCallOrigin, next, actIndex, consumed);
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule CSSRuleSet ****************/


/************ begin Rule CSSRuleId ****************
 *
 * CSSRuleId:
 * 	name=ID;
 *
 **/

// name=ID
protected class CSSRuleId_NameAssignment extends AssignmentToken  {
	
	public CSSRuleId_NameAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleIdAccess().getNameAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleIdRule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("name",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("name");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getCSSRuleIdAccess().getNameIDTerminalRuleCall_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getCSSRuleIdAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule CSSRuleId ****************/


/************ begin Rule CSSRuleRef ****************
 *
 * CSSRuleRef:
 * 	"<" ref=[CSSRuleId] ">";
 *
 **/

// "<" ref=[CSSRuleId] ">"
protected class CSSRuleRef_Group extends GroupToken {
	
	public CSSRuleRef_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleRef_GreaterThanSignKeyword_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "<"
protected class CSSRuleRef_LessThanSignKeyword_0 extends KeywordToken  {
	
	public CSSRuleRef_LessThanSignKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleRefAccess().getLessThanSignKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// ref=[CSSRuleId]
protected class CSSRuleRef_RefAssignment_1 extends AssignmentToken  {
	
	public CSSRuleRef_RefAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleRefAccess().getRefAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleRef_LessThanSignKeyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ref",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ref");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRuleRefAccess().getRefCSSRuleIdCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CROSS_REFERENCE;
				element = grammarAccess.getCSSRuleRefAccess().getRefCSSRuleIdCrossReference_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ">"
protected class CSSRuleRef_GreaterThanSignKeyword_2 extends KeywordToken  {
	
	public CSSRuleRef_GreaterThanSignKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleRefAccess().getGreaterThanSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleRef_RefAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule CSSRuleRef ****************/


/************ begin Rule CSSRuleAssignment ****************
 *
 * CSSRuleAssignment:
 * 	{CSSRuleAssignment} id=CSSRuleId "=" r=CSSRuleOrExpression ";";
 *
 **/

// {CSSRuleAssignment} id=CSSRuleId "=" r=CSSRuleOrExpression ";"
protected class CSSRuleAssignment_Group extends GroupToken {
	
	public CSSRuleAssignment_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleAssignmentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleAssignment_SemicolonKeyword_4(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleAssignmentAccess().getCSSRuleAssignmentAction_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {CSSRuleAssignment}
protected class CSSRuleAssignment_CSSRuleAssignmentAction_0 extends ActionToken  {

	public CSSRuleAssignment_CSSRuleAssignmentAction_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCSSRuleAssignmentAccess().getCSSRuleAssignmentAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// id=CSSRuleId
protected class CSSRuleAssignment_IdAssignment_1 extends AssignmentToken  {
	
	public CSSRuleAssignment_IdAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleAssignmentAccess().getIdAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleId_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("id",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("id");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRuleIdRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleAssignmentAccess().getIdCSSRuleIdParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CSSRuleAssignment_CSSRuleAssignmentAction_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "="
protected class CSSRuleAssignment_EqualsSignKeyword_2 extends KeywordToken  {
	
	public CSSRuleAssignment_EqualsSignKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleAssignmentAccess().getEqualsSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleAssignment_IdAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// r=CSSRuleOrExpression
protected class CSSRuleAssignment_RAssignment_3 extends AssignmentToken  {
	
	public CSSRuleAssignment_RAssignment_3(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleAssignmentAccess().getRAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("r",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("r");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRuleOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleAssignmentAccess().getRCSSRuleOrExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CSSRuleAssignment_EqualsSignKeyword_2(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class CSSRuleAssignment_SemicolonKeyword_4 extends KeywordToken  {
	
	public CSSRuleAssignment_SemicolonKeyword_4(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleAssignmentAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleAssignment_RAssignment_3(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule CSSRuleAssignment ****************/


/************ begin Rule CSSRuleOrExpression ****************
 *
 * CSSRuleOrExpression returns CSSRuleExpression:
 * 	ors+=CSSRuleXorExpression ("|" ors+=CSSRuleXorExpression)*;
 *
 **/

// ors+=CSSRuleXorExpression ("|" ors+=CSSRuleXorExpression)*
protected class CSSRuleOrExpression_Group extends GroupToken {
	
	public CSSRuleOrExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleOrExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CSSRuleOrExpression_OrsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleOrExpressionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ors+=CSSRuleXorExpression
protected class CSSRuleOrExpression_OrsAssignment_0 extends AssignmentToken  {
	
	public CSSRuleOrExpression_OrsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleOrExpressionAccess().getOrsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleXorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ors",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ors");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRuleXorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleOrExpressionAccess().getOrsCSSRuleXorExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("|" ors+=CSSRuleXorExpression)*
protected class CSSRuleOrExpression_Group_1 extends GroupToken {
	
	public CSSRuleOrExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleOrExpression_OrsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "|"
protected class CSSRuleOrExpression_VerticalLineKeyword_1_0 extends KeywordToken  {
	
	public CSSRuleOrExpression_VerticalLineKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleOrExpressionAccess().getVerticalLineKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleOrExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CSSRuleOrExpression_OrsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// ors+=CSSRuleXorExpression
protected class CSSRuleOrExpression_OrsAssignment_1_1 extends AssignmentToken  {
	
	public CSSRuleOrExpression_OrsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleOrExpressionAccess().getOrsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleXorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("ors",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("ors");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRuleXorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleOrExpressionAccess().getOrsCSSRuleXorExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CSSRuleOrExpression_VerticalLineKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CSSRuleOrExpression ****************/


/************ begin Rule CSSRuleXorExpression ****************
 *
 * CSSRuleXorExpression:
 * 	xors+=CSSRulePostfixExpression ("||" xors+=CSSRulePostfixExpression)*;
 *
 **/

// xors+=CSSRulePostfixExpression ("||" xors+=CSSRulePostfixExpression)*
protected class CSSRuleXorExpression_Group extends GroupToken {
	
	public CSSRuleXorExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleXorExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleXorExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CSSRuleXorExpression_XorsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleXorExpressionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// xors+=CSSRulePostfixExpression
protected class CSSRuleXorExpression_XorsAssignment_0 extends AssignmentToken  {
	
	public CSSRuleXorExpression_XorsAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleXorExpressionAccess().getXorsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRulePostfixExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("xors",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("xors");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRulePostfixExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleXorExpressionAccess().getXorsCSSRulePostfixExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// ("||" xors+=CSSRulePostfixExpression)*
protected class CSSRuleXorExpression_Group_1 extends GroupToken {
	
	public CSSRuleXorExpression_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleXorExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleXorExpression_XorsAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "||"
protected class CSSRuleXorExpression_VerticalLineVerticalLineKeyword_1_0 extends KeywordToken  {
	
	public CSSRuleXorExpression_VerticalLineVerticalLineKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleXorExpressionAccess().getVerticalLineVerticalLineKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleXorExpression_Group_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CSSRuleXorExpression_XorsAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

}

// xors+=CSSRulePostfixExpression
protected class CSSRuleXorExpression_XorsAssignment_1_1 extends AssignmentToken  {
	
	public CSSRuleXorExpression_XorsAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleXorExpressionAccess().getXorsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRulePostfixExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("xors",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("xors");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRulePostfixExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleXorExpressionAccess().getXorsCSSRulePostfixExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CSSRuleXorExpression_VerticalLineVerticalLineKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CSSRuleXorExpression ****************/


/************ begin Rule CSSRuleBracketExpression ****************
 *
 * CSSRuleBracketExpression:
 * 	"[" CSSRuleOrExpression "]";
 *
 **/

// "[" CSSRuleOrExpression "]"
protected class CSSRuleBracketExpression_Group extends GroupToken {
	
	public CSSRuleBracketExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleBracketExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleBracketExpression_RightSquareBracketKeyword_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleOrExpressionRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "["
protected class CSSRuleBracketExpression_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public CSSRuleBracketExpression_LeftSquareBracketKeyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleBracketExpressionAccess().getLeftSquareBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// CSSRuleOrExpression
protected class CSSRuleBracketExpression_CSSRuleOrExpressionParserRuleCall_1 extends RuleCallToken {
	
	public CSSRuleBracketExpression_CSSRuleOrExpressionParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCSSRuleBracketExpressionAccess().getCSSRuleOrExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(CSSRuleOrExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleBracketExpression_LeftSquareBracketKeyword_0(lastRuleCallOrigin, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// "]"
protected class CSSRuleBracketExpression_RightSquareBracketKeyword_2 extends KeywordToken  {
	
	public CSSRuleBracketExpression_RightSquareBracketKeyword_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCSSRuleBracketExpressionAccess().getRightSquareBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleBracketExpression_CSSRuleOrExpressionParserRuleCall_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}


/************ end Rule CSSRuleBracketExpression ****************/


/************ begin Rule CSSRulePostfixExpression ****************
 *
 * CSSRulePostfixExpression:
 * 	CSSRuleConcat c=("*" | "+" | "?")?;
 *
 **/

// CSSRuleConcat c=("*" | "+" | "?")?
protected class CSSRulePostfixExpression_Group extends GroupToken {
	
	public CSSRulePostfixExpression_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRulePostfixExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRulePostfixExpression_CAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CSSRulePostfixExpression_CSSRuleConcatParserRuleCall_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleConcatRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// CSSRuleConcat
protected class CSSRulePostfixExpression_CSSRuleConcatParserRuleCall_0 extends RuleCallToken {
	
	public CSSRulePostfixExpression_CSSRuleConcatParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCSSRulePostfixExpressionAccess().getCSSRuleConcatParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleConcat_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(checkForRecursion(CSSRuleConcat_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// c=("*" | "+" | "?")?
protected class CSSRulePostfixExpression_CAssignment_1 extends AssignmentToken  {
	
	public CSSRulePostfixExpression_CAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRulePostfixExpressionAccess().getCAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRulePostfixExpression_CSSRuleConcatParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("c",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("c");
		if(keywordSerializer.isValid(obj.getEObject(), grammarAccess.getCSSRulePostfixExpressionAccess().getCAsteriskKeyword_1_0_0(), value, null)) {
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getCSSRulePostfixExpressionAccess().getCAsteriskKeyword_1_0_0();
			return obj;
		}
		if(keywordSerializer.isValid(obj.getEObject(), grammarAccess.getCSSRulePostfixExpressionAccess().getCPlusSignKeyword_1_0_1(), value, null)) {
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getCSSRulePostfixExpressionAccess().getCPlusSignKeyword_1_0_1();
			return obj;
		}
		if(keywordSerializer.isValid(obj.getEObject(), grammarAccess.getCSSRulePostfixExpressionAccess().getCQuestionMarkKeyword_1_0_2(), value, null)) {
			type = AssignmentType.KEYWORD;
			element = grammarAccess.getCSSRulePostfixExpressionAccess().getCQuestionMarkKeyword_1_0_2();
			return obj;
		}
		return null;
	}

}


/************ end Rule CSSRulePostfixExpression ****************/


/************ begin Rule CSSRuleConcat ****************
 *
 * CSSRuleConcat:
 * 	conc+=CSSRulePrimaryExpression conc+=CSSRulePrimaryExpression?;
 *
 **/

// conc+=CSSRulePrimaryExpression conc+=CSSRulePrimaryExpression?
protected class CSSRuleConcat_Group extends GroupToken {
	
	public CSSRuleConcat_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCSSRuleConcatAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleConcat_ConcAssignment_1(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CSSRuleConcat_ConcAssignment_0(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleConcatRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// conc+=CSSRulePrimaryExpression
protected class CSSRuleConcat_ConcAssignment_0 extends AssignmentToken  {
	
	public CSSRuleConcat_ConcAssignment_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleConcatAccess().getConcAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRulePrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("conc",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("conc");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRulePrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleConcatAccess().getConcCSSRulePrimaryExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

// conc+=CSSRulePrimaryExpression?
protected class CSSRuleConcat_ConcAssignment_1 extends AssignmentToken  {
	
	public CSSRuleConcat_ConcAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCSSRuleConcatAccess().getConcAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRulePrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("conc",false)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("conc");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCSSRulePrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getCSSRuleConcatAccess().getConcCSSRulePrimaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CSSRuleConcat_ConcAssignment_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule CSSRuleConcat ****************/



/************ begin Rule CSSRulePrimaryExpression ****************
 *
 * CSSRulePrimaryExpression:
 * 	CSSRuleRef | CSSRuleBracketExpression | CSSRuleLiteral;
 *
 **/

// CSSRuleRef | CSSRuleBracketExpression | CSSRuleLiteral
protected class CSSRulePrimaryExpression_Alternatives extends AlternativesToken {

	public CSSRulePrimaryExpression_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCSSRulePrimaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRulePrimaryExpression_CSSRuleRefParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new CSSRulePrimaryExpression_CSSRuleBracketExpressionParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new CSSRulePrimaryExpression_CSSRuleLiteralParserRuleCall_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleOrExpressionRule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getCSSRuleRefRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// CSSRuleRef
protected class CSSRulePrimaryExpression_CSSRuleRefParserRuleCall_0 extends RuleCallToken {
	
	public CSSRulePrimaryExpression_CSSRuleRefParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCSSRulePrimaryExpressionAccess().getCSSRuleRefParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleRefRule().getType().getClassifier())
			return null;
		if(checkForRecursion(CSSRuleRef_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// CSSRuleBracketExpression
protected class CSSRulePrimaryExpression_CSSRuleBracketExpressionParserRuleCall_1 extends RuleCallToken {
	
	public CSSRulePrimaryExpression_CSSRuleBracketExpressionParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCSSRulePrimaryExpressionAccess().getCSSRuleBracketExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new CSSRuleBracketExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getCSSRuleOrExpressionRule().getType().getClassifier())
			return null;
		if(checkForRecursion(CSSRuleBracketExpression_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// CSSRuleLiteral
protected class CSSRulePrimaryExpression_CSSRuleLiteralParserRuleCall_2 extends UnassignedTextToken {

	public CSSRulePrimaryExpression_CSSRuleLiteralParserRuleCall_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCSSRulePrimaryExpressionAccess().getCSSRuleLiteralParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}


/************ end Rule CSSRulePrimaryExpression ****************/

}
