/*
* generated by Xtext
*/

package at.bestsolution.efxclipse.tooling.decora.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class DecoraDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class Field_selectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "field_selection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cRAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cRRGBA_FIELDSParserRuleCall_0_0 = (RuleCall)cRAssignment_0.eContents().get(0);
		private final Assignment cXAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cXXYZW_FIELDSTerminalRuleCall_1_0 = (RuleCall)cXAssignment_1.eContents().get(0);
		
		////Model:
		////	expr=translation_unit
		//////	greetings+=Greeting*
		////;
		//// returns [String fields]
		//field_selection:
		//	r= // { $fields = $r.text; }
		//	RGBA_FIELDS | x= // { $fields = $x.text; }
		//	XYZW_FIELDS;
		public ParserRule getRule() { return rule; }

		//r= // { $fields = $r.text; }
		//RGBA_FIELDS | x= // { $fields = $x.text; }
		//XYZW_FIELDS
		public Alternatives getAlternatives() { return cAlternatives; }

		//r= // { $fields = $r.text; }
		//RGBA_FIELDS
		public Assignment getRAssignment_0() { return cRAssignment_0; }

		//// { $fields = $r.text; }
		//RGBA_FIELDS
		public RuleCall getRRGBA_FIELDSParserRuleCall_0_0() { return cRRGBA_FIELDSParserRuleCall_0_0; }

		//x= // { $fields = $x.text; }
		//XYZW_FIELDS
		public Assignment getXAssignment_1() { return cXAssignment_1; }

		//// { $fields = $x.text; }
		//XYZW_FIELDS
		public RuleCall getXXYZW_FIELDSTerminalRuleCall_1_0() { return cXXYZW_FIELDSTerminalRuleCall_1_0; }
	}

	public class TYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFloat2Keyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFloat3Keyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFloat4Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cFloatKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cInt2Keyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cInt3Keyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cInt4Keyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cIntKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cBool2Keyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cBool3Keyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cBool4Keyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cBoolKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cSamplerKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cLsamplerKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cFsamplerKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		
		////primary_expression// returns [Expr expr]
		////        : {primary_expression} IDENTIFIER//    { $expr = tm.variable($IDENTIFIER.text); }
		////        | {primary_expression} INTCONSTANT//   { $expr = tm.literal(Type.INT, Integer.valueOf($INTCONSTANT.text)); }
		////        | {primary_expression} FLOATCONSTANT// { $expr = tm.literal(Type.FLOAT, Float.valueOf($FLOATCONSTANT.text)); }
		////        | {primary_expression} BOOLCONSTANT//  { $expr = tm.literal(Type.BOOL, Boolean.valueOf($BOOLCONSTANT.text)); }
		////        | (LEFT_PAREN e=expression RIGHT_PAREN) //{ $expr = tm.parenExpr($e.expr); }
		////        ;
		////
		////primary_or_call // returns [Expr expr]
		////        : e=primary_expression //{ $expr = $e.expr; }
		////        | f=function_call      //{ $expr = $f.expr; }
		////        ;
		////
		//////
		////// TODO: not sure how to do this properly without mutual left-recursion;
		////// for now we hack it to allow:
		//////   arr[3].rgb
		//////   arr[3]
		//////   val.rgb
		//////   val++
		//////   val--
		//////   val
		////// but not things like:
		//////   arr[3].r++
		//////
		////postfix_expression //returns [Expr expr]
		////        : (e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET fs=field_selection)
		////              //{ $expr = tm.fieldSelect(tm.arrayAccess($e.expr, $ae.expr), $fs.fields); }
		////        | (e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET)
		////              //{ $expr = tm.arrayAccess($e.expr, $ae.expr); }
		////        | (e=primary_or_call fs=field_selection)
		////              //{ $expr = tm.fieldSelect($e.expr, $fs.fields); }
		////        | (e=primary_or_call INC)
		////              //{ $expr = tm.unary(UnaryOpType.INC, $e.expr); }
		////        | (e=primary_or_call DEC)
		////              //{ $expr = tm.unary(UnaryOpType.DEC, $e.expr); }
		////        | (e=primary_or_call)
		////              //{ $expr = $e.expr; }
		////        ;
		////
		////// From the GLSL spec...
		////// Grammar Note: Constructors look like functions, but lexical
		////// analysis recognized most of them as keywords.  They are now
		////// recognized through "type_specifier".
		////
		////function_call //returns [Expr expr]
		////        : (id=IDENTIFIER LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN)
		//////            {
		//////                $expr = tm.call($id.text, p!=null ? $p.exprList : null);
		//////            }
		////        | (ts=type_specifier LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN)
		//////            {
		//////                Type type = Type.fromToken($ts.text);
		//////                $expr = tm.vectorCtor(type, p!=null ? $p.exprList : null);
		//////            }
		////        ;
		////        
		////function_call_parameter_list //returns [List<Expr> exprList = new ArrayList<Expr>()]
		////        : a+=assignment_expression //{ $exprList.add($a.expr); }
		////          (COMMA a+=assignment_expression //{$exprList.add($a.expr); }
		////          )*
		////        ;
		////        
		////unary_expression //returns [Expr expr]
		////        : (p=postfix_expression)     //{ $expr = $p.expr; }
		////        | (INC   u=unary_expression) //{ $expr = tm.unary(UnaryOpType.INC,     $u.expr); }
		////        | (DEC   u=unary_expression) //{ $expr = tm.unary(UnaryOpType.DEC,     $u.expr); }
		////        | (PLUS  u=unary_expression) //{ $expr = tm.unary(UnaryOpType.PLUS,    $u.expr); }
		////        | (DASH  u=unary_expression) //{ $expr = tm.unary(UnaryOpType.MINUS,   $u.expr); }
		////        |( BANG  u=unary_expression) //{ $expr = tm.unary(UnaryOpType.NOT,     $u.expr); }
		////        ;
		////
		////// From the GLSL spec...
		////// Grammar Note:  No traditional style type casts.
		////
		////// From the GLSL spec...
		////// Grammar Note:  No '*' or '&' unary ops.  Pointers are not supported.
		////
		////multiplicative_expression //returns [Expr expr]
		////        : a=unary_expression //{ $expr = $a.expr; }
		////          ((STAR  b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.MUL, $expr, $b.expr); }
		////          |(SLASH b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.DIV, $expr, $b.expr); }
		////          )*
		////        ;
		////        
		////additive_expression //returns [Expr expr]
		////        : a=multiplicative_expression //{ $expr = $a.expr; }
		////          ((PLUS b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.ADD, $expr, $b.expr); }
		////          |(DASH b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.SUB, $expr, $b.expr); }
		////          )*
		////        ;
		////
		////relational_expression //returns [Expr expr]
		////        : a=additive_expression //{ $expr = $a.expr; }
		////          ((LTEQ b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.LTEQ, $expr, $b.expr); }
		////          |(GTEQ b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.GTEQ, $expr, $b.expr); }
		////          |(LT   b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.LT,   $expr, $b.expr); }
		////          |(GT   b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.GT,   $expr, $b.expr); }
		////          )*
		////        ;
		////
		////equality_expression //returns [Expr expr]
		////        : a=relational_expression //{ $expr = $a.expr; }
		////          ((EQEQ b+=relational_expression) //{ $expr = tm.binary(BinaryOpType.EQEQ, $expr, $b.expr); }
		////          | (NEQ b+=relational_expression) //{ $expr = tm.binary(BinaryOpType.NEQ,  $expr, $b.expr); }
		////          )*
		////        ;
		////        
		////logical_and_expression //returns [Expr expr]
		////        : a=equality_expression //{ $expr = $a.expr; }
		////          (AND b+=equality_expression //{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
		////          )*
		////        ;
		////        
		////logical_xor_expression //returns [Expr expr]
		////        : a=logical_and_expression //{ $expr = $a.expr; }
		////          (XOR b+=logical_and_expression //{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
		////          )*
		////        ;
		////        
		////logical_or_expression //returns [Expr expr]
		////        : a=logical_xor_expression //{ $expr = $a.expr; }
		////          (OR b+=logical_xor_expression //{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
		////          )*
		////        ;
		////        
		////ternary_part
		////        : QUESTION expression COLON a=assignment_expression
		////        ;
		////
		////// TODO: handle ternary
		////conditional_expression //returns [Expr expr]
		////        : a=logical_or_expression t=ternary_part? //{ $expr = $a.expr; }
		////        ;
		////
		////assignment_expression //returns [Expr expr]
		////        : (a=unary_expression op=assignment_operator b=assignment_expression)
		////              //{ $expr = tm.binary(BinaryOpType.forSymbol($op.text), $a.expr, $b.expr); }
		////        | (c=conditional_expression)
		////              //{ $expr = $c.expr; }
		////        ;
		////
		////assignment_operator
		////        : EQUAL
		////        | STAREQ
		////        | SLASHEQ
		////        | PLUSEQ
		////        | DASHEQ
		////        ;
		////
		////// TODO: handle expression lists?
		//////expression returns [List<Expr> exprList = new ArrayList<Expr>()]
		//////        : e=assignment_expression { $exprList.add($e.expr); }
		//////          (COMMA e=assignment_expression { $exprList.add($e.expr); })*
		//////        ;
		////
		////expression //returns [Expr expr]
		////        : e=assignment_expression //{ $expr = $e.expr; }
		////        ;
		////
		////function_prototype //returns [Function func]
		////        : t=type_specifier id=IDENTIFIER LEFT_PAREN p=parameter_declaration_list? RIGHT_PAREN
		//////            {
		//////                Type type = Type.fromToken($t.text);
		//////                $func = symbols.declareFunction($id.text, type, (p != null) ? $p.paramList : null);
		//////            }
		////        ;
		////        
		////parameter_declaration //returns [Param param]
		////        : t=type_specifier id=IDENTIFIER
		//////            {
		//////                Type type = Type.fromToken($t.text);
		//////                $param = new Param($id.text, type);
		//////            }
		////        ;
		////
		////parameter_declaration_list //returns [List<Param> paramList = new ArrayList<Param>()]
		////        : p+=parameter_declaration //{ $paramList.add($p.param); }
		////          (COMMA p+=parameter_declaration / *{ $paramList.add($p.param); }* / )*
		////        ;
		////        
		////declaration_identifier_and_init //returns [String name, Expr arrayInit, Expr init]
		////        : id=IDENTIFIER //{ $name = $id.text; }
		////          (LEFT_BRACKET ae=constant_expression / *{ $arrayInit = $ae.expr; }* / RIGHT_BRACKET)?
		////          (EQUAL e=initializer / *{ $init = $e.expr; }* /)?
		////        ;
		////
		////single_declaration //returns [VarDecl decl]
		////        : t=fully_specified_type d=declaration_identifier_and_init
		//////          {
		//////              int arraySize = -1;
		//////              Expr ainit = $d.arrayInit;
		//////              if (ainit != null) {
		//////                  if (ainit instanceof LiteralExpr) {
		//////                      Object val = ((LiteralExpr)ainit).getValue();
		//////                      if (!(val instanceof Integer)) {
		//////                          throw new RuntimeException("Array size must be an integer");
		//////                      }
		//////                      arraySize = ((Integer)val).intValue();
		//////                  } else if (ainit instanceof VariableExpr) {
		//////                      Variable var = ((VariableExpr)ainit).getVariable();
		//////                      Object val = var.getConstValue();
		//////                      if (!(val instanceof Integer) || var.getQualifier() != Qualifier.CONST) {
		//////                          throw new RuntimeException("Array size must be a constant integer");
		//////                      }
		//////                      arraySize = ((Integer)val).intValue();
		//////                  }
		//////              }
		//////
		//////              Object constValue = null;
		//////              if ($t.qual == Qualifier.CONST) {
		//////                  Expr cinit = $d.init;
		//////                  if (cinit == null) {
		//////                      throw new RuntimeException("Constant value must be initialized");
		//////                  }
		//////                  // TODO: for now, allow some basic expressions on the rhs
		//////                  // of the constant declaration...
		//////                  //if (!(cinit instanceof LiteralExpr)) {
		//////                  //    throw new RuntimeException("Constant initializer must be a literal (for now)");
		//////                  //}
		//////                  Type ctype = cinit.getResultType();
		//////                  if (ctype != $t.type) {
		//////                      throw new RuntimeException("Constant type must match that of initializer");
		//////                  }
		//////                  if (cinit instanceof LiteralExpr) {
		//////                      constValue = ((LiteralExpr)cinit).getValue();
		//////                  } else {
		//////                      // TODO: This is gross, but to support complex constant
		//////                      // initializers (such as "const FOO = BAR / 42.0;") we
		//////                      // will just save the full text of the rhs and hope that
		//////                      // the backend does the right thing with it.  The real
		//////                      // solution obviously would be to evaluate the expression
		//////                      // now and reduce it to a single value.
		//////                      constValue = $d.init.toString();
		//////                  }
		//////              }
		//////
		//////              Variable var =
		//////                  symbols.declareVariable($d.name,
		//////                                          $t.type, $t.qual, $t.precision,
		//////                                          arraySize, constValue);
		//////              $decl = tm.varDecl(var, $d.init);
		//////          }
		////        ;
		////        
		////declaration //returns [List<VarDecl> declList = new ArrayList<VarDecl>()]
		////        : s=single_declaration //{ $declList.add($s.decl); }
		////          (COMMA d+=declaration_identifier_and_init
		//////          {
		//////              Variable base = $s.decl.getVariable();
		//////              Variable var =
		//////                  symbols.declareVariable($d.name,
		//////                                          base.getType(),
		//////                                          base.getQualifier(),
		//////                                          base.getPrecision());
		//////              $declList.add(tm.varDecl(var, $d.init));
		//////          }
		////          )* SEMICOLON
		////        ;
		////        
		////// From GLSL spec...
		////// Grammar Note:  No 'enum', or 'typedef'. 
		////
		////fully_specified_type //returns [Qualifier qual, Precision precision, Type type]
		////        : (tq=type_qualifier tp=type_precision ts=type_specifier)
		//////            {
		//////                $qual = Qualifier.fromToken($tq.text);
		//////                $precision = Precision.fromToken($tp.text);
		//////                $type = Type.fromToken($ts.text);
		//////            }
		////        | (tq=type_qualifier ts=type_specifier)
		//////            {
		//////                $qual = Qualifier.fromToken($tq.text);
		//////                $type = Type.fromToken($ts.text);
		//////            }
		////        | (tp=type_precision ts=type_specifier)
		//////            {
		//////                $precision = Precision.fromToken($tp.text);
		//////                $type = Type.fromToken($ts.text);
		//////            }
		////        | (ts=type_specifier)
		//////            {
		//////                $type = Type.fromToken($ts.text);
		//////            }
		////        ;
		////        
		////type_qualifier
		////        : 'const'
		////        | 'param'
		////        ;
		////
		////type_precision
		////        : 'lowp'
		////        | 'mediump'
		////        | 'highp'
		////        ;
		////        
		////type_specifier
		////        : {type_specifier} type_specifier_nonarray array_brackets? 
		////        ;
		////        
		////array_brackets
		////        : LEFT_BRACKET constant_expression RIGHT_BRACKET
		////        ;
		////       
		////type_specifier_nonarray
		////        : TYPE
		////        | VOID
		////        ;
		////        
		////initializer //returns [Expr expr]
		////        : e=assignment_expression //{ $expr = $e.expr; }
		////        ;
		////        
		////declaration_statement //returns [Stmt stmt]
		////        : d=declaration //{ $stmt = tm.declStmt($d.declList); }
		////        ;
		////        
		////statement //returns [Stmt stmt]
		////        : c=compound_statement //{ $stmt = $c.stmt; }
		////        | s=simple_statement   //{ $stmt = $s.stmt; }
		////        ;
		////
		////// From GLSL spec...
		////// Grammar Note:  No labeled statements; 'goto' is not supported. 
		////
		////simple_statement //returns [Stmt stmt]
		////        : d=declaration_statement //{ $stmt = $d.stmt; }
		////        | e=expression_statement  //{ $stmt = $e.stmt; }
		////        | s=selection_statement   //{ $stmt = $s.stmt; }
		////        | i=iteration_statement   //{ $stmt = $i.stmt; }
		////        | j=jump_statement        //{ $stmt = $j.stmt; }
		////        ;
		////        
		////compound_statement //returns [Stmt stmt]
		//////@init {
		//////    List<Stmt> stmtList = new ArrayList<Stmt>();
		//////}
		////        : {compound_statement} LEFT_BRACE (s+=statement / *{ stmtList.add($s.stmt); }* /)* RIGHT_BRACE
		////          //{ $stmt = tm.compoundStmt(stmtList); }
		////        ;
		////        
		////statement_no_new_scope //returns [Stmt stmt]
		////        : c=compound_statement_no_new_scope //{ $stmt = $c.stmt; }
		////        | s=simple_statement                //{ $stmt = $s.stmt; }
		////        ;
		////        
		////compound_statement_no_new_scope //returns [Stmt stmt]
		//////@init {
		//////    List<Stmt> stmtList = new ArrayList<Stmt>();
		//////}
		////        : {compound_statement_no_new_scope} LEFT_BRACE (s+=statement / *{ stmtList.add($s.stmt); }* /)* RIGHT_BRACE
		////          //{ $stmt = tm.compoundStmt(stmtList); }
		////        ;
		////        
		////expression_statement //returns [Stmt stmt]
		////        : {expression_statement} SEMICOLON              //{ $stmt = tm.exprStmt(null); }
		////        | e=expression SEMICOLON //{ $stmt = tm.exprStmt($e.expr); }
		////        ;
		////        
		////constant_expression //returns [Expr expr]
		////        : c=conditional_expression //{ $expr = $c.expr; }
		////        ;
		////
		////selection_statement //returns [Stmt stmt]
		////        : IF LEFT_PAREN e=expression RIGHT_PAREN a=statement (ELSE b=statement)?
		////              //{ $stmt = tm.selectStmt($e.expr, $a.stmt, (b != null) ? $b.stmt : null); }
		////        ;
		////
		////// TODO: implement second half?
		////condition //returns [Expr expr]
		////        : e=expression //{$expr = $e.expr; }
		//////        | fully_specified_type IDENTIFIER EQUAL initializer
		////        ;
		////
		////iteration_statement //returns [Stmt stmt]
		////        : (WHILE LEFT_PAREN c=condition RIGHT_PAREN snns=statement_no_new_scope)
		////              //{ $stmt = tm.whileStmt($c.expr, $snns.stmt); }
		////        | (DO s=statement WHILE LEFT_PAREN e=expression RIGHT_PAREN SEMICOLON)
		////              //{ $stmt = tm.doWhileStmt($s.stmt, $e.expr); }
		////        | (u=unroll_modifier FOR LEFT_PAREN init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope)
		////              //{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, $u.max, $u.check); }
		////        | (FOR LEFT_PAREN init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope)
		////              //{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, -1, -1); }
		////        ;
		////
		////unroll_modifier //returns [int max, int check]
		////        : UNROLL LEFT_PAREN m=INTCONSTANT COMMA c=INTCONSTANT RIGHT_PAREN
		////              //{ $max = Integer.valueOf($m.text); $check = Integer.valueOf($c.text); }
		////        ;
		////
		////for_init_statement //returns [Stmt stmt]
		////        : e=expression_statement  //{ $stmt = $e.stmt; }
		////        | d=declaration_statement //{ $stmt = $d.stmt; }
		////        ;
		////        
		////for_rest_statement //returns [Expr cond, Expr expr]
		////        : ({for_rest_statement} c=condition SEMICOLON e=expression?) //{ $cond = $c.expr; if (e != null) $expr = $e.expr; }
		////        | ({for_rest_statement} SEMICOLON e=expression?) //{ if (e != null) $expr = $e.expr; }
		////        ;
		////        
		////jump_statement //returns [Stmt stmt]
		////        : {jump_statement} CONTINUE SEMICOLON            //{ $stmt = tm.continueStmt(); }
		////        | {jump_statement}BREAK SEMICOLON               //{ $stmt = tm.breakStmt(); }
		////        | {jump_statement}DISCARD SEMICOLON             //{ $stmt = tm.discardStmt(); }
		////        | {jump_statement}RETURN SEMICOLON              //{ $stmt = tm.returnStmt(null); }
		////        | RETURN e=expression SEMICOLON //{ $stmt = tm.returnStmt($e.expr); }
		////        ;
		////        
		////// From GLSL spec...
		////// Grammar Note:  No 'goto'.  Gotos are not supported. 
		////
		////translation_unit //returns [ProgramUnit prog]
		//////@init {
		//////    List<ExtDecl> declList = new ArrayList<ExtDecl>();
		//////}
		////        : (e+=external_declaration / *{ declList.addAll($e.res); }* / )+
		////            //{ $prog = tm.programUnit(declList); }
		////        ;
		////        
		////external_declaration //returns [List<ExtDecl> res = new ArrayList<ExtDecl>()]
		////        : f=function_definition //{ $res.add($f.def); }
		////        | d=declaration         //{ $res.addAll($d.declList); }
		////        | g=glue_block          //{ $res.add($g.block); }
		////        ;
		////
		////// From GLSL spec...
		////// Grammar Note:  No 'switch'.  Switch statements not supported. 
		////
		////function_definition //returns [FuncDef def]
		//////@init {
		//////	symbols.enterFrame();
		//////}
		////        : p=function_prototype s=compound_statement_no_new_scope //{ $def = tm.funcDef($p.func, $s.stmt); }
		////        ;
		//////finally {
		//////        symbols.exitFrame();
		//////}
		////
		////glue_block //returns [GlueBlock block]
		////        : g=T_GLUE_BLOCK //{ $block = tm.glueBlock($g.text.substring(2, $g.text.length()-2)); }
		////        ;
		////              
		//TYPE:
		//	"float2" | "float3" | "float4" | "float" | "int2" | "int3" | "int4" | "int" | "bool2" | "bool3" | "bool4" | "bool" |
		//	"sampler" | "lsampler" | "fsampler";
		public ParserRule getRule() { return rule; }

		//"float2" | "float3" | "float4" | "float" | "int2" | "int3" | "int4" | "int" | "bool2" | "bool3" | "bool4" | "bool" |
		//"sampler" | "lsampler" | "fsampler"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"float2"
		public Keyword getFloat2Keyword_0() { return cFloat2Keyword_0; }

		//"float3"
		public Keyword getFloat3Keyword_1() { return cFloat3Keyword_1; }

		//"float4"
		public Keyword getFloat4Keyword_2() { return cFloat4Keyword_2; }

		//"float"
		public Keyword getFloatKeyword_3() { return cFloatKeyword_3; }

		//"int2"
		public Keyword getInt2Keyword_4() { return cInt2Keyword_4; }

		//"int3"
		public Keyword getInt3Keyword_5() { return cInt3Keyword_5; }

		//"int4"
		public Keyword getInt4Keyword_6() { return cInt4Keyword_6; }

		//"int"
		public Keyword getIntKeyword_7() { return cIntKeyword_7; }

		//"bool2"
		public Keyword getBool2Keyword_8() { return cBool2Keyword_8; }

		//"bool3"
		public Keyword getBool3Keyword_9() { return cBool3Keyword_9; }

		//"bool4"
		public Keyword getBool4Keyword_10() { return cBool4Keyword_10; }

		//"bool"
		public Keyword getBoolKeyword_11() { return cBoolKeyword_11; }

		//"sampler"
		public Keyword getSamplerKeyword_12() { return cSamplerKeyword_12; }

		//"lsampler"
		public Keyword getLsamplerKeyword_13() { return cLsamplerKeyword_13; }

		//"fsampler"
		public Keyword getFsamplerKeyword_14() { return cFsamplerKeyword_14; }
	}

	public class BOOLCONSTANTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLCONSTANT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BOOLCONSTANT:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class RGBA_FIELDSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RGBA_FIELDS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cRFIELDTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final RuleCall cRFIELDTerminalRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final RuleCall cRFIELDTerminalRuleCall_0_4 = (RuleCall)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cDOTTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cRFIELDTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cRFIELDTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cDOTTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cRFIELDTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cDOTTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		
		//RGBA_FIELDS:
		//	DOT RFIELD RFIELD RFIELD RFIELD | DOT RFIELD RFIELD RFIELD | DOT RFIELD RFIELD | DOT RFIELD;
		public ParserRule getRule() { return rule; }

		//DOT RFIELD RFIELD RFIELD RFIELD | DOT RFIELD RFIELD RFIELD | DOT RFIELD RFIELD | DOT RFIELD
		public Alternatives getAlternatives() { return cAlternatives; }

		//DOT RFIELD RFIELD RFIELD RFIELD
		public Group getGroup_0() { return cGroup_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_0() { return cDOTTerminalRuleCall_0_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_1() { return cRFIELDTerminalRuleCall_0_1; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_2() { return cRFIELDTerminalRuleCall_0_2; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_3() { return cRFIELDTerminalRuleCall_0_3; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_4() { return cRFIELDTerminalRuleCall_0_4; }

		//DOT RFIELD RFIELD RFIELD
		public Group getGroup_1() { return cGroup_1; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_1_0() { return cDOTTerminalRuleCall_1_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_1_1() { return cRFIELDTerminalRuleCall_1_1; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_1_2() { return cRFIELDTerminalRuleCall_1_2; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_1_3() { return cRFIELDTerminalRuleCall_1_3; }

		//DOT RFIELD RFIELD
		public Group getGroup_2() { return cGroup_2; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_2_0() { return cDOTTerminalRuleCall_2_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_2_1() { return cRFIELDTerminalRuleCall_2_1; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_2_2() { return cRFIELDTerminalRuleCall_2_2; }

		//DOT RFIELD
		public Group getGroup_3() { return cGroup_3; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_3_0() { return cDOTTerminalRuleCall_3_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_3_1() { return cRFIELDTerminalRuleCall_3_1; }
	}

	public class IDENTIFIERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IDENTIFIER");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLETTERTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cLETTERTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cDIGITTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//IDENTIFIER:
		//	LETTER (LETTER | DIGIT)*;
		public ParserRule getRule() { return rule; }

		//LETTER (LETTER | DIGIT)*
		public Group getGroup() { return cGroup; }

		//LETTER
		public RuleCall getLETTERTerminalRuleCall_0() { return cLETTERTerminalRuleCall_0; }

		//(LETTER | DIGIT)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//LETTER
		public RuleCall getLETTERTerminalRuleCall_1_0() { return cLETTERTerminalRuleCall_1_0; }

		//DIGIT
		public RuleCall getDIGITTerminalRuleCall_1_1() { return cDIGITTerminalRuleCall_1_1; }
	}
	
	
	private Field_selectionElements pField_selection;
	private TYPEElements pTYPE;
	private BOOLCONSTANTElements pBOOLCONSTANT;
	private RGBA_FIELDSElements pRGBA_FIELDS;
	private TerminalRule tRFIELD;
	private TerminalRule tXYZW_FIELDS;
	private TerminalRule tXFIELD;
	private IDENTIFIERElements pIDENTIFIER;
	private TerminalRule tLETTER;
	private TerminalRule tDIGIT;
	private TerminalRule tINTCONSTANT;
	private TerminalRule tFLOATCONSTANT;
	private TerminalRule tWS;
	private TerminalRule tCOMMENT;
	private TerminalRule tLINE_COMMENT;
	private TerminalRule tT_GLUE_BLOCK;
	private TerminalRule tSTAR;
	private TerminalRule tSLASH;
	private TerminalRule tPLUS;
	private TerminalRule tDASH;
	private TerminalRule tLT;
	private TerminalRule tGT;
	private TerminalRule tLTEQ;
	private TerminalRule tGTEQ;
	private TerminalRule tEQEQ;
	private TerminalRule tNEQ;
	private TerminalRule tAND;
	private TerminalRule tXOR;
	private TerminalRule tOR;
	private TerminalRule tINC;
	private TerminalRule tDEC;
	private TerminalRule tSTAREQ;
	private TerminalRule tSLASHEQ;
	private TerminalRule tPLUSEQ;
	private TerminalRule tDASHEQ;
	private TerminalRule tLEFT_PAREN;
	private TerminalRule tRIGHT_PAREN;
	private TerminalRule tLEFT_BRACKET;
	private TerminalRule tRIGHT_BRACKET;
	private TerminalRule tLEFT_BRACE;
	private TerminalRule tRIGHT_BRACE;
	private TerminalRule tLEFT_FRENCH;
	private TerminalRule tRIGHT_FRENCH;
	private TerminalRule tDOT;
	private TerminalRule tCOMMA;
	private TerminalRule tEQUAL;
	private TerminalRule tBANG;
	private TerminalRule tTILDE;
	private TerminalRule tQUESTION;
	private TerminalRule tCOLON;
	private TerminalRule tSEMICOLON;
	private TerminalRule tIF;
	private TerminalRule tELSE;
	private TerminalRule tWHILE;
	private TerminalRule tDO;
	private TerminalRule tFOR;
	private TerminalRule tUNROLL;
	private TerminalRule tCONTINUE;
	private TerminalRule tBREAK;
	private TerminalRule tDISCARD;
	private TerminalRule tRETURN;
	private TerminalRule tVOID;
	
	private final Grammar grammar;

	@Inject
	public DecoraDslGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("at.bestsolution.efxclipse.tooling.decora.DecoraDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	////Model:
	////	expr=translation_unit
	//////	greetings+=Greeting*
	////;
	//// returns [String fields]
	//field_selection:
	//	r= // { $fields = $r.text; }
	//	RGBA_FIELDS | x= // { $fields = $x.text; }
	//	XYZW_FIELDS;
	public Field_selectionElements getField_selectionAccess() {
		return (pField_selection != null) ? pField_selection : (pField_selection = new Field_selectionElements());
	}
	
	public ParserRule getField_selectionRule() {
		return getField_selectionAccess().getRule();
	}

	////primary_expression// returns [Expr expr]
	////        : {primary_expression} IDENTIFIER//    { $expr = tm.variable($IDENTIFIER.text); }
	////        | {primary_expression} INTCONSTANT//   { $expr = tm.literal(Type.INT, Integer.valueOf($INTCONSTANT.text)); }
	////        | {primary_expression} FLOATCONSTANT// { $expr = tm.literal(Type.FLOAT, Float.valueOf($FLOATCONSTANT.text)); }
	////        | {primary_expression} BOOLCONSTANT//  { $expr = tm.literal(Type.BOOL, Boolean.valueOf($BOOLCONSTANT.text)); }
	////        | (LEFT_PAREN e=expression RIGHT_PAREN) //{ $expr = tm.parenExpr($e.expr); }
	////        ;
	////
	////primary_or_call // returns [Expr expr]
	////        : e=primary_expression //{ $expr = $e.expr; }
	////        | f=function_call      //{ $expr = $f.expr; }
	////        ;
	////
	//////
	////// TODO: not sure how to do this properly without mutual left-recursion;
	////// for now we hack it to allow:
	//////   arr[3].rgb
	//////   arr[3]
	//////   val.rgb
	//////   val++
	//////   val--
	//////   val
	////// but not things like:
	//////   arr[3].r++
	//////
	////postfix_expression //returns [Expr expr]
	////        : (e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET fs=field_selection)
	////              //{ $expr = tm.fieldSelect(tm.arrayAccess($e.expr, $ae.expr), $fs.fields); }
	////        | (e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET)
	////              //{ $expr = tm.arrayAccess($e.expr, $ae.expr); }
	////        | (e=primary_or_call fs=field_selection)
	////              //{ $expr = tm.fieldSelect($e.expr, $fs.fields); }
	////        | (e=primary_or_call INC)
	////              //{ $expr = tm.unary(UnaryOpType.INC, $e.expr); }
	////        | (e=primary_or_call DEC)
	////              //{ $expr = tm.unary(UnaryOpType.DEC, $e.expr); }
	////        | (e=primary_or_call)
	////              //{ $expr = $e.expr; }
	////        ;
	////
	////// From the GLSL spec...
	////// Grammar Note: Constructors look like functions, but lexical
	////// analysis recognized most of them as keywords.  They are now
	////// recognized through "type_specifier".
	////
	////function_call //returns [Expr expr]
	////        : (id=IDENTIFIER LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN)
	//////            {
	//////                $expr = tm.call($id.text, p!=null ? $p.exprList : null);
	//////            }
	////        | (ts=type_specifier LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN)
	//////            {
	//////                Type type = Type.fromToken($ts.text);
	//////                $expr = tm.vectorCtor(type, p!=null ? $p.exprList : null);
	//////            }
	////        ;
	////        
	////function_call_parameter_list //returns [List<Expr> exprList = new ArrayList<Expr>()]
	////        : a+=assignment_expression //{ $exprList.add($a.expr); }
	////          (COMMA a+=assignment_expression //{$exprList.add($a.expr); }
	////          )*
	////        ;
	////        
	////unary_expression //returns [Expr expr]
	////        : (p=postfix_expression)     //{ $expr = $p.expr; }
	////        | (INC   u=unary_expression) //{ $expr = tm.unary(UnaryOpType.INC,     $u.expr); }
	////        | (DEC   u=unary_expression) //{ $expr = tm.unary(UnaryOpType.DEC,     $u.expr); }
	////        | (PLUS  u=unary_expression) //{ $expr = tm.unary(UnaryOpType.PLUS,    $u.expr); }
	////        | (DASH  u=unary_expression) //{ $expr = tm.unary(UnaryOpType.MINUS,   $u.expr); }
	////        |( BANG  u=unary_expression) //{ $expr = tm.unary(UnaryOpType.NOT,     $u.expr); }
	////        ;
	////
	////// From the GLSL spec...
	////// Grammar Note:  No traditional style type casts.
	////
	////// From the GLSL spec...
	////// Grammar Note:  No '*' or '&' unary ops.  Pointers are not supported.
	////
	////multiplicative_expression //returns [Expr expr]
	////        : a=unary_expression //{ $expr = $a.expr; }
	////          ((STAR  b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.MUL, $expr, $b.expr); }
	////          |(SLASH b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.DIV, $expr, $b.expr); }
	////          )*
	////        ;
	////        
	////additive_expression //returns [Expr expr]
	////        : a=multiplicative_expression //{ $expr = $a.expr; }
	////          ((PLUS b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.ADD, $expr, $b.expr); }
	////          |(DASH b+=multiplicative_expression) //{ $expr = tm.binary(BinaryOpType.SUB, $expr, $b.expr); }
	////          )*
	////        ;
	////
	////relational_expression //returns [Expr expr]
	////        : a=additive_expression //{ $expr = $a.expr; }
	////          ((LTEQ b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.LTEQ, $expr, $b.expr); }
	////          |(GTEQ b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.GTEQ, $expr, $b.expr); }
	////          |(LT   b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.LT,   $expr, $b.expr); }
	////          |(GT   b+=additive_expression) //{ $expr = tm.binary(BinaryOpType.GT,   $expr, $b.expr); }
	////          )*
	////        ;
	////
	////equality_expression //returns [Expr expr]
	////        : a=relational_expression //{ $expr = $a.expr; }
	////          ((EQEQ b+=relational_expression) //{ $expr = tm.binary(BinaryOpType.EQEQ, $expr, $b.expr); }
	////          | (NEQ b+=relational_expression) //{ $expr = tm.binary(BinaryOpType.NEQ,  $expr, $b.expr); }
	////          )*
	////        ;
	////        
	////logical_and_expression //returns [Expr expr]
	////        : a=equality_expression //{ $expr = $a.expr; }
	////          (AND b+=equality_expression //{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
	////          )*
	////        ;
	////        
	////logical_xor_expression //returns [Expr expr]
	////        : a=logical_and_expression //{ $expr = $a.expr; }
	////          (XOR b+=logical_and_expression //{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
	////          )*
	////        ;
	////        
	////logical_or_expression //returns [Expr expr]
	////        : a=logical_xor_expression //{ $expr = $a.expr; }
	////          (OR b+=logical_xor_expression //{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
	////          )*
	////        ;
	////        
	////ternary_part
	////        : QUESTION expression COLON a=assignment_expression
	////        ;
	////
	////// TODO: handle ternary
	////conditional_expression //returns [Expr expr]
	////        : a=logical_or_expression t=ternary_part? //{ $expr = $a.expr; }
	////        ;
	////
	////assignment_expression //returns [Expr expr]
	////        : (a=unary_expression op=assignment_operator b=assignment_expression)
	////              //{ $expr = tm.binary(BinaryOpType.forSymbol($op.text), $a.expr, $b.expr); }
	////        | (c=conditional_expression)
	////              //{ $expr = $c.expr; }
	////        ;
	////
	////assignment_operator
	////        : EQUAL
	////        | STAREQ
	////        | SLASHEQ
	////        | PLUSEQ
	////        | DASHEQ
	////        ;
	////
	////// TODO: handle expression lists?
	//////expression returns [List<Expr> exprList = new ArrayList<Expr>()]
	//////        : e=assignment_expression { $exprList.add($e.expr); }
	//////          (COMMA e=assignment_expression { $exprList.add($e.expr); })*
	//////        ;
	////
	////expression //returns [Expr expr]
	////        : e=assignment_expression //{ $expr = $e.expr; }
	////        ;
	////
	////function_prototype //returns [Function func]
	////        : t=type_specifier id=IDENTIFIER LEFT_PAREN p=parameter_declaration_list? RIGHT_PAREN
	//////            {
	//////                Type type = Type.fromToken($t.text);
	//////                $func = symbols.declareFunction($id.text, type, (p != null) ? $p.paramList : null);
	//////            }
	////        ;
	////        
	////parameter_declaration //returns [Param param]
	////        : t=type_specifier id=IDENTIFIER
	//////            {
	//////                Type type = Type.fromToken($t.text);
	//////                $param = new Param($id.text, type);
	//////            }
	////        ;
	////
	////parameter_declaration_list //returns [List<Param> paramList = new ArrayList<Param>()]
	////        : p+=parameter_declaration //{ $paramList.add($p.param); }
	////          (COMMA p+=parameter_declaration / *{ $paramList.add($p.param); }* / )*
	////        ;
	////        
	////declaration_identifier_and_init //returns [String name, Expr arrayInit, Expr init]
	////        : id=IDENTIFIER //{ $name = $id.text; }
	////          (LEFT_BRACKET ae=constant_expression / *{ $arrayInit = $ae.expr; }* / RIGHT_BRACKET)?
	////          (EQUAL e=initializer / *{ $init = $e.expr; }* /)?
	////        ;
	////
	////single_declaration //returns [VarDecl decl]
	////        : t=fully_specified_type d=declaration_identifier_and_init
	//////          {
	//////              int arraySize = -1;
	//////              Expr ainit = $d.arrayInit;
	//////              if (ainit != null) {
	//////                  if (ainit instanceof LiteralExpr) {
	//////                      Object val = ((LiteralExpr)ainit).getValue();
	//////                      if (!(val instanceof Integer)) {
	//////                          throw new RuntimeException("Array size must be an integer");
	//////                      }
	//////                      arraySize = ((Integer)val).intValue();
	//////                  } else if (ainit instanceof VariableExpr) {
	//////                      Variable var = ((VariableExpr)ainit).getVariable();
	//////                      Object val = var.getConstValue();
	//////                      if (!(val instanceof Integer) || var.getQualifier() != Qualifier.CONST) {
	//////                          throw new RuntimeException("Array size must be a constant integer");
	//////                      }
	//////                      arraySize = ((Integer)val).intValue();
	//////                  }
	//////              }
	//////
	//////              Object constValue = null;
	//////              if ($t.qual == Qualifier.CONST) {
	//////                  Expr cinit = $d.init;
	//////                  if (cinit == null) {
	//////                      throw new RuntimeException("Constant value must be initialized");
	//////                  }
	//////                  // TODO: for now, allow some basic expressions on the rhs
	//////                  // of the constant declaration...
	//////                  //if (!(cinit instanceof LiteralExpr)) {
	//////                  //    throw new RuntimeException("Constant initializer must be a literal (for now)");
	//////                  //}
	//////                  Type ctype = cinit.getResultType();
	//////                  if (ctype != $t.type) {
	//////                      throw new RuntimeException("Constant type must match that of initializer");
	//////                  }
	//////                  if (cinit instanceof LiteralExpr) {
	//////                      constValue = ((LiteralExpr)cinit).getValue();
	//////                  } else {
	//////                      // TODO: This is gross, but to support complex constant
	//////                      // initializers (such as "const FOO = BAR / 42.0;") we
	//////                      // will just save the full text of the rhs and hope that
	//////                      // the backend does the right thing with it.  The real
	//////                      // solution obviously would be to evaluate the expression
	//////                      // now and reduce it to a single value.
	//////                      constValue = $d.init.toString();
	//////                  }
	//////              }
	//////
	//////              Variable var =
	//////                  symbols.declareVariable($d.name,
	//////                                          $t.type, $t.qual, $t.precision,
	//////                                          arraySize, constValue);
	//////              $decl = tm.varDecl(var, $d.init);
	//////          }
	////        ;
	////        
	////declaration //returns [List<VarDecl> declList = new ArrayList<VarDecl>()]
	////        : s=single_declaration //{ $declList.add($s.decl); }
	////          (COMMA d+=declaration_identifier_and_init
	//////          {
	//////              Variable base = $s.decl.getVariable();
	//////              Variable var =
	//////                  symbols.declareVariable($d.name,
	//////                                          base.getType(),
	//////                                          base.getQualifier(),
	//////                                          base.getPrecision());
	//////              $declList.add(tm.varDecl(var, $d.init));
	//////          }
	////          )* SEMICOLON
	////        ;
	////        
	////// From GLSL spec...
	////// Grammar Note:  No 'enum', or 'typedef'. 
	////
	////fully_specified_type //returns [Qualifier qual, Precision precision, Type type]
	////        : (tq=type_qualifier tp=type_precision ts=type_specifier)
	//////            {
	//////                $qual = Qualifier.fromToken($tq.text);
	//////                $precision = Precision.fromToken($tp.text);
	//////                $type = Type.fromToken($ts.text);
	//////            }
	////        | (tq=type_qualifier ts=type_specifier)
	//////            {
	//////                $qual = Qualifier.fromToken($tq.text);
	//////                $type = Type.fromToken($ts.text);
	//////            }
	////        | (tp=type_precision ts=type_specifier)
	//////            {
	//////                $precision = Precision.fromToken($tp.text);
	//////                $type = Type.fromToken($ts.text);
	//////            }
	////        | (ts=type_specifier)
	//////            {
	//////                $type = Type.fromToken($ts.text);
	//////            }
	////        ;
	////        
	////type_qualifier
	////        : 'const'
	////        | 'param'
	////        ;
	////
	////type_precision
	////        : 'lowp'
	////        | 'mediump'
	////        | 'highp'
	////        ;
	////        
	////type_specifier
	////        : {type_specifier} type_specifier_nonarray array_brackets? 
	////        ;
	////        
	////array_brackets
	////        : LEFT_BRACKET constant_expression RIGHT_BRACKET
	////        ;
	////       
	////type_specifier_nonarray
	////        : TYPE
	////        | VOID
	////        ;
	////        
	////initializer //returns [Expr expr]
	////        : e=assignment_expression //{ $expr = $e.expr; }
	////        ;
	////        
	////declaration_statement //returns [Stmt stmt]
	////        : d=declaration //{ $stmt = tm.declStmt($d.declList); }
	////        ;
	////        
	////statement //returns [Stmt stmt]
	////        : c=compound_statement //{ $stmt = $c.stmt; }
	////        | s=simple_statement   //{ $stmt = $s.stmt; }
	////        ;
	////
	////// From GLSL spec...
	////// Grammar Note:  No labeled statements; 'goto' is not supported. 
	////
	////simple_statement //returns [Stmt stmt]
	////        : d=declaration_statement //{ $stmt = $d.stmt; }
	////        | e=expression_statement  //{ $stmt = $e.stmt; }
	////        | s=selection_statement   //{ $stmt = $s.stmt; }
	////        | i=iteration_statement   //{ $stmt = $i.stmt; }
	////        | j=jump_statement        //{ $stmt = $j.stmt; }
	////        ;
	////        
	////compound_statement //returns [Stmt stmt]
	//////@init {
	//////    List<Stmt> stmtList = new ArrayList<Stmt>();
	//////}
	////        : {compound_statement} LEFT_BRACE (s+=statement / *{ stmtList.add($s.stmt); }* /)* RIGHT_BRACE
	////          //{ $stmt = tm.compoundStmt(stmtList); }
	////        ;
	////        
	////statement_no_new_scope //returns [Stmt stmt]
	////        : c=compound_statement_no_new_scope //{ $stmt = $c.stmt; }
	////        | s=simple_statement                //{ $stmt = $s.stmt; }
	////        ;
	////        
	////compound_statement_no_new_scope //returns [Stmt stmt]
	//////@init {
	//////    List<Stmt> stmtList = new ArrayList<Stmt>();
	//////}
	////        : {compound_statement_no_new_scope} LEFT_BRACE (s+=statement / *{ stmtList.add($s.stmt); }* /)* RIGHT_BRACE
	////          //{ $stmt = tm.compoundStmt(stmtList); }
	////        ;
	////        
	////expression_statement //returns [Stmt stmt]
	////        : {expression_statement} SEMICOLON              //{ $stmt = tm.exprStmt(null); }
	////        | e=expression SEMICOLON //{ $stmt = tm.exprStmt($e.expr); }
	////        ;
	////        
	////constant_expression //returns [Expr expr]
	////        : c=conditional_expression //{ $expr = $c.expr; }
	////        ;
	////
	////selection_statement //returns [Stmt stmt]
	////        : IF LEFT_PAREN e=expression RIGHT_PAREN a=statement (ELSE b=statement)?
	////              //{ $stmt = tm.selectStmt($e.expr, $a.stmt, (b != null) ? $b.stmt : null); }
	////        ;
	////
	////// TODO: implement second half?
	////condition //returns [Expr expr]
	////        : e=expression //{$expr = $e.expr; }
	//////        | fully_specified_type IDENTIFIER EQUAL initializer
	////        ;
	////
	////iteration_statement //returns [Stmt stmt]
	////        : (WHILE LEFT_PAREN c=condition RIGHT_PAREN snns=statement_no_new_scope)
	////              //{ $stmt = tm.whileStmt($c.expr, $snns.stmt); }
	////        | (DO s=statement WHILE LEFT_PAREN e=expression RIGHT_PAREN SEMICOLON)
	////              //{ $stmt = tm.doWhileStmt($s.stmt, $e.expr); }
	////        | (u=unroll_modifier FOR LEFT_PAREN init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope)
	////              //{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, $u.max, $u.check); }
	////        | (FOR LEFT_PAREN init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope)
	////              //{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, -1, -1); }
	////        ;
	////
	////unroll_modifier //returns [int max, int check]
	////        : UNROLL LEFT_PAREN m=INTCONSTANT COMMA c=INTCONSTANT RIGHT_PAREN
	////              //{ $max = Integer.valueOf($m.text); $check = Integer.valueOf($c.text); }
	////        ;
	////
	////for_init_statement //returns [Stmt stmt]
	////        : e=expression_statement  //{ $stmt = $e.stmt; }
	////        | d=declaration_statement //{ $stmt = $d.stmt; }
	////        ;
	////        
	////for_rest_statement //returns [Expr cond, Expr expr]
	////        : ({for_rest_statement} c=condition SEMICOLON e=expression?) //{ $cond = $c.expr; if (e != null) $expr = $e.expr; }
	////        | ({for_rest_statement} SEMICOLON e=expression?) //{ if (e != null) $expr = $e.expr; }
	////        ;
	////        
	////jump_statement //returns [Stmt stmt]
	////        : {jump_statement} CONTINUE SEMICOLON            //{ $stmt = tm.continueStmt(); }
	////        | {jump_statement}BREAK SEMICOLON               //{ $stmt = tm.breakStmt(); }
	////        | {jump_statement}DISCARD SEMICOLON             //{ $stmt = tm.discardStmt(); }
	////        | {jump_statement}RETURN SEMICOLON              //{ $stmt = tm.returnStmt(null); }
	////        | RETURN e=expression SEMICOLON //{ $stmt = tm.returnStmt($e.expr); }
	////        ;
	////        
	////// From GLSL spec...
	////// Grammar Note:  No 'goto'.  Gotos are not supported. 
	////
	////translation_unit //returns [ProgramUnit prog]
	//////@init {
	//////    List<ExtDecl> declList = new ArrayList<ExtDecl>();
	//////}
	////        : (e+=external_declaration / *{ declList.addAll($e.res); }* / )+
	////            //{ $prog = tm.programUnit(declList); }
	////        ;
	////        
	////external_declaration //returns [List<ExtDecl> res = new ArrayList<ExtDecl>()]
	////        : f=function_definition //{ $res.add($f.def); }
	////        | d=declaration         //{ $res.addAll($d.declList); }
	////        | g=glue_block          //{ $res.add($g.block); }
	////        ;
	////
	////// From GLSL spec...
	////// Grammar Note:  No 'switch'.  Switch statements not supported. 
	////
	////function_definition //returns [FuncDef def]
	//////@init {
	//////	symbols.enterFrame();
	//////}
	////        : p=function_prototype s=compound_statement_no_new_scope //{ $def = tm.funcDef($p.func, $s.stmt); }
	////        ;
	//////finally {
	//////        symbols.exitFrame();
	//////}
	////
	////glue_block //returns [GlueBlock block]
	////        : g=T_GLUE_BLOCK //{ $block = tm.glueBlock($g.text.substring(2, $g.text.length()-2)); }
	////        ;
	////              
	//TYPE:
	//	"float2" | "float3" | "float4" | "float" | "int2" | "int3" | "int4" | "int" | "bool2" | "bool3" | "bool4" | "bool" |
	//	"sampler" | "lsampler" | "fsampler";
	public TYPEElements getTYPEAccess() {
		return (pTYPE != null) ? pTYPE : (pTYPE = new TYPEElements());
	}
	
	public ParserRule getTYPERule() {
		return getTYPEAccess().getRule();
	}

	//BOOLCONSTANT:
	//	"true" | "false";
	public BOOLCONSTANTElements getBOOLCONSTANTAccess() {
		return (pBOOLCONSTANT != null) ? pBOOLCONSTANT : (pBOOLCONSTANT = new BOOLCONSTANTElements());
	}
	
	public ParserRule getBOOLCONSTANTRule() {
		return getBOOLCONSTANTAccess().getRule();
	}

	//RGBA_FIELDS:
	//	DOT RFIELD RFIELD RFIELD RFIELD | DOT RFIELD RFIELD RFIELD | DOT RFIELD RFIELD | DOT RFIELD;
	public RGBA_FIELDSElements getRGBA_FIELDSAccess() {
		return (pRGBA_FIELDS != null) ? pRGBA_FIELDS : (pRGBA_FIELDS = new RGBA_FIELDSElements());
	}
	
	public ParserRule getRGBA_FIELDSRule() {
		return getRGBA_FIELDSAccess().getRule();
	}

	//// fragment
	//terminal RFIELD:
	//	"r" | "g" | "b" | "a";
	public TerminalRule getRFIELDRule() {
		return (tRFIELD != null) ? tRFIELD : (tRFIELD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RFIELD"));
	} 

	//terminal XYZW_FIELDS:
	//	DOT XFIELD XFIELD XFIELD XFIELD | DOT XFIELD XFIELD XFIELD | DOT XFIELD XFIELD | DOT XFIELD;
	public TerminalRule getXYZW_FIELDSRule() {
		return (tXYZW_FIELDS != null) ? tXYZW_FIELDS : (tXYZW_FIELDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "XYZW_FIELDS"));
	} 

	//terminal XFIELD:
	//	"x" | "y" | "z" | "w";
	public TerminalRule getXFIELDRule() {
		return (tXFIELD != null) ? tXFIELD : (tXFIELD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "XFIELD"));
	} 

	//IDENTIFIER:
	//	LETTER (LETTER | DIGIT)*;
	public IDENTIFIERElements getIDENTIFIERAccess() {
		return (pIDENTIFIER != null) ? pIDENTIFIER : (pIDENTIFIER = new IDENTIFIERElements());
	}
	
	public ParserRule getIDENTIFIERRule() {
		return getIDENTIFIERAccess().getRule();
	}

	//terminal LETTER:
	//	"$" | "A".."Z" | "a".."z" | "_";
	public TerminalRule getLETTERRule() {
		return (tLETTER != null) ? tLETTER : (tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LETTER"));
	} 

	////fragment
	//terminal DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return (tDIGIT != null) ? tDIGIT : (tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT"));
	} 

	//terminal INTCONSTANT:
	//	"0" | "1".."9" DIGIT*;
	public TerminalRule getINTCONSTANTRule() {
		return (tINTCONSTANT != null) ? tINTCONSTANT : (tINTCONSTANT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTCONSTANT"));
	} 

	//terminal FLOATCONSTANT:
	//	DIGIT+ "." DIGIT* | "." DIGIT+;
	public TerminalRule getFLOATCONSTANTRule() {
		return (tFLOATCONSTANT != null) ? tFLOATCONSTANT : (tFLOATCONSTANT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOATCONSTANT"));
	} 

	//terminal WS:
	//	" " / * |'\u000C'* / | "\r" | "\t" | "\n";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getCOMMENTRule() {
		return (tCOMMENT != null) ? tCOMMENT : (tCOMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMENT"));
	} 

	//terminal LINE_COMMENT:
	//	"//" !("\n" | "\r")* "\r"? "\n";
	public TerminalRule getLINE_COMMENTRule() {
		return (tLINE_COMMENT != null) ? tLINE_COMMENT : (tLINE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LINE_COMMENT"));
	} 

	//terminal T_GLUE_BLOCK:
	//	LEFT_FRENCH .* RIGHT_FRENCH;
	public TerminalRule getT_GLUE_BLOCKRule() {
		return (tT_GLUE_BLOCK != null) ? tT_GLUE_BLOCK : (tT_GLUE_BLOCK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "T_GLUE_BLOCK"));
	} 

	//terminal STAR:
	//	"*";
	public TerminalRule getSTARRule() {
		return (tSTAR != null) ? tSTAR : (tSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STAR"));
	} 

	//terminal SLASH:
	//	"/";
	public TerminalRule getSLASHRule() {
		return (tSLASH != null) ? tSLASH : (tSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASH"));
	} 

	//terminal PLUS:
	//	"+";
	public TerminalRule getPLUSRule() {
		return (tPLUS != null) ? tPLUS : (tPLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUS"));
	} 

	//terminal DASH:
	//	"-";
	public TerminalRule getDASHRule() {
		return (tDASH != null) ? tDASH : (tDASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DASH"));
	} 

	//terminal LT:
	//	"<";
	public TerminalRule getLTRule() {
		return (tLT != null) ? tLT : (tLT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LT"));
	} 

	//terminal GT:
	//	">";
	public TerminalRule getGTRule() {
		return (tGT != null) ? tGT : (tGT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GT"));
	} 

	//terminal LTEQ:
	//	"<=";
	public TerminalRule getLTEQRule() {
		return (tLTEQ != null) ? tLTEQ : (tLTEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LTEQ"));
	} 

	//terminal GTEQ:
	//	">=";
	public TerminalRule getGTEQRule() {
		return (tGTEQ != null) ? tGTEQ : (tGTEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GTEQ"));
	} 

	//terminal EQEQ:
	//	"==";
	public TerminalRule getEQEQRule() {
		return (tEQEQ != null) ? tEQEQ : (tEQEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQEQ"));
	} 

	//terminal NEQ:
	//	"!=";
	public TerminalRule getNEQRule() {
		return (tNEQ != null) ? tNEQ : (tNEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NEQ"));
	} 

	//terminal AND:
	//	"&&";
	public TerminalRule getANDRule() {
		return (tAND != null) ? tAND : (tAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AND"));
	} 

	//terminal XOR:
	//	"^^";
	public TerminalRule getXORRule() {
		return (tXOR != null) ? tXOR : (tXOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "XOR"));
	} 

	//terminal OR:
	//	"||";
	public TerminalRule getORRule() {
		return (tOR != null) ? tOR : (tOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OR"));
	} 

	//terminal INC:
	//	"++";
	public TerminalRule getINCRule() {
		return (tINC != null) ? tINC : (tINC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INC"));
	} 

	//terminal DEC:
	//	"--";
	public TerminalRule getDECRule() {
		return (tDEC != null) ? tDEC : (tDEC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DEC"));
	} 

	//terminal STAREQ:
	//	"*=";
	public TerminalRule getSTAREQRule() {
		return (tSTAREQ != null) ? tSTAREQ : (tSTAREQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STAREQ"));
	} 

	//terminal SLASHEQ:
	//	"/=";
	public TerminalRule getSLASHEQRule() {
		return (tSLASHEQ != null) ? tSLASHEQ : (tSLASHEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASHEQ"));
	} 

	//terminal PLUSEQ:
	//	"+=";
	public TerminalRule getPLUSEQRule() {
		return (tPLUSEQ != null) ? tPLUSEQ : (tPLUSEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUSEQ"));
	} 

	//terminal DASHEQ:
	//	"-=";
	public TerminalRule getDASHEQRule() {
		return (tDASHEQ != null) ? tDASHEQ : (tDASHEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DASHEQ"));
	} 

	//terminal LEFT_PAREN:
	//	"(";
	public TerminalRule getLEFT_PARENRule() {
		return (tLEFT_PAREN != null) ? tLEFT_PAREN : (tLEFT_PAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_PAREN"));
	} 

	//terminal RIGHT_PAREN:
	//	")";
	public TerminalRule getRIGHT_PARENRule() {
		return (tRIGHT_PAREN != null) ? tRIGHT_PAREN : (tRIGHT_PAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_PAREN"));
	} 

	//terminal LEFT_BRACKET:
	//	"[";
	public TerminalRule getLEFT_BRACKETRule() {
		return (tLEFT_BRACKET != null) ? tLEFT_BRACKET : (tLEFT_BRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_BRACKET"));
	} 

	//terminal RIGHT_BRACKET:
	//	"]";
	public TerminalRule getRIGHT_BRACKETRule() {
		return (tRIGHT_BRACKET != null) ? tRIGHT_BRACKET : (tRIGHT_BRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_BRACKET"));
	} 

	//terminal LEFT_BRACE:
	//	"{";
	public TerminalRule getLEFT_BRACERule() {
		return (tLEFT_BRACE != null) ? tLEFT_BRACE : (tLEFT_BRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_BRACE"));
	} 

	//terminal RIGHT_BRACE:
	//	"}";
	public TerminalRule getRIGHT_BRACERule() {
		return (tRIGHT_BRACE != null) ? tRIGHT_BRACE : (tRIGHT_BRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_BRACE"));
	} 

	//terminal LEFT_FRENCH:
	//	"<<";
	public TerminalRule getLEFT_FRENCHRule() {
		return (tLEFT_FRENCH != null) ? tLEFT_FRENCH : (tLEFT_FRENCH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_FRENCH"));
	} 

	//terminal RIGHT_FRENCH:
	//	">>";
	public TerminalRule getRIGHT_FRENCHRule() {
		return (tRIGHT_FRENCH != null) ? tRIGHT_FRENCH : (tRIGHT_FRENCH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_FRENCH"));
	} 

	//terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return (tDOT != null) ? tDOT : (tDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOT"));
	} 

	//terminal COMMA:
	//	",";
	public TerminalRule getCOMMARule() {
		return (tCOMMA != null) ? tCOMMA : (tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMA"));
	} 

	//terminal EQUAL:
	//	"=";
	public TerminalRule getEQUALRule() {
		return (tEQUAL != null) ? tEQUAL : (tEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQUAL"));
	} 

	//terminal BANG:
	//	"!";
	public TerminalRule getBANGRule() {
		return (tBANG != null) ? tBANG : (tBANG = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BANG"));
	} 

	//terminal TILDE:
	//	"~";
	public TerminalRule getTILDERule() {
		return (tTILDE != null) ? tTILDE : (tTILDE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TILDE"));
	} 

	//terminal QUESTION:
	//	"?";
	public TerminalRule getQUESTIONRule() {
		return (tQUESTION != null) ? tQUESTION : (tQUESTION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "QUESTION"));
	} 

	//terminal COLON:
	//	":";
	public TerminalRule getCOLONRule() {
		return (tCOLON != null) ? tCOLON : (tCOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COLON"));
	} 

	//terminal SEMICOLON:
	//	";";
	public TerminalRule getSEMICOLONRule() {
		return (tSEMICOLON != null) ? tSEMICOLON : (tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SEMICOLON"));
	} 

	//terminal IF:
	//	"if";
	public TerminalRule getIFRule() {
		return (tIF != null) ? tIF : (tIF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "IF"));
	} 

	//terminal ELSE:
	//	"else";
	public TerminalRule getELSERule() {
		return (tELSE != null) ? tELSE : (tELSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ELSE"));
	} 

	//terminal WHILE:
	//	"while";
	public TerminalRule getWHILERule() {
		return (tWHILE != null) ? tWHILE : (tWHILE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WHILE"));
	} 

	//terminal DO:
	//	"do";
	public TerminalRule getDORule() {
		return (tDO != null) ? tDO : (tDO = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DO"));
	} 

	//terminal FOR:
	//	"for";
	public TerminalRule getFORRule() {
		return (tFOR != null) ? tFOR : (tFOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FOR"));
	} 

	//terminal UNROLL:
	//	"unroll";
	public TerminalRule getUNROLLRule() {
		return (tUNROLL != null) ? tUNROLL : (tUNROLL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UNROLL"));
	} 

	//terminal CONTINUE:
	//	"continue";
	public TerminalRule getCONTINUERule() {
		return (tCONTINUE != null) ? tCONTINUE : (tCONTINUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CONTINUE"));
	} 

	//terminal BREAK:
	//	"break";
	public TerminalRule getBREAKRule() {
		return (tBREAK != null) ? tBREAK : (tBREAK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BREAK"));
	} 

	//terminal DISCARD:
	//	"discard";
	public TerminalRule getDISCARDRule() {
		return (tDISCARD != null) ? tDISCARD : (tDISCARD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DISCARD"));
	} 

	//terminal RETURN:
	//	"return";
	public TerminalRule getRETURNRule() {
		return (tRETURN != null) ? tRETURN : (tRETURN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RETURN"));
	} 

	//terminal VOID:
	//	"void";
	public TerminalRule getVOIDRule() {
		return (tVOID != null) ? tVOID : (tVOID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "VOID"));
	} 
}
