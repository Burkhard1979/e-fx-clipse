/*
* generated by Xtext
*/

package at.bestsolution.efxclipse.tooling.decora.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class DecoraDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Assignment cUnitAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cUnitTranslation_unitParserRuleCall_0 = (RuleCall)cUnitAssignment.eContents().get(0);
		
		//Model:
		//	unit=translation_unit;
		public ParserRule getRule() { return rule; }

		//unit=translation_unit
		public Assignment getUnitAssignment() { return cUnitAssignment; }

		//translation_unit
		public RuleCall getUnitTranslation_unitParserRuleCall_0() { return cUnitTranslation_unitParserRuleCall_0; }
	}

	public class Field_selectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "field_selection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cRAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cRRGBA_FIELDSParserRuleCall_0_0 = (RuleCall)cRAssignment_0.eContents().get(0);
		private final Assignment cXAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cXXYZW_FIELDSTerminalRuleCall_1_0 = (RuleCall)cXAssignment_1.eContents().get(0);
		
		//// returns [String fields]
		//field_selection:
		//	r= // { $fields = $r.text; }
		//	RGBA_FIELDS | x= // { $fields = $x.text; }
		//	XYZW_FIELDS;
		public ParserRule getRule() { return rule; }

		//r= // { $fields = $r.text; }
		//RGBA_FIELDS | x= // { $fields = $x.text; }
		//XYZW_FIELDS
		public Alternatives getAlternatives() { return cAlternatives; }

		//r= // { $fields = $r.text; }
		//RGBA_FIELDS
		public Assignment getRAssignment_0() { return cRAssignment_0; }

		//// { $fields = $r.text; }
		//RGBA_FIELDS
		public RuleCall getRRGBA_FIELDSParserRuleCall_0_0() { return cRRGBA_FIELDSParserRuleCall_0_0; }

		//x= // { $fields = $x.text; }
		//XYZW_FIELDS
		public Assignment getXAssignment_1() { return cXAssignment_1; }

		//// { $fields = $x.text; }
		//XYZW_FIELDS
		public RuleCall getXXYZW_FIELDSTerminalRuleCall_1_0() { return cXXYZW_FIELDSTerminalRuleCall_1_0; }
	}

	public class Primary_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "primary_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cPrimary_expressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cIDENTIFIERParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPrimary_expressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cINTCONSTANTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cPrimary_expressionAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final RuleCall cFLOATCONSTANTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cPrimary_expressionAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final RuleCall cBOOLCONSTANTParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cLEFT_PARENTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cEAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_4_1_0 = (RuleCall)cEAssignment_4_1.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_4_2 = (RuleCall)cGroup_4.eContents().get(2);
		
		//// returns [Expr expr]
		//primary_expression:
		//	{primary_expression} //    { $expr = tm.variable($IDENTIFIER.text); }
		//	IDENTIFIER //{ $expr = tm.parenExpr($e.expr); }
		//	| {primary_expression} //   { $expr = tm.literal(Type.INT, Integer.valueOf($INTCONSTANT.text)); }
		//	INTCONSTANT | {primary_expression} // { $expr = tm.literal(Type.FLOAT, Float.valueOf($FLOATCONSTANT.text)); }
		//	FLOATCONSTANT | {primary_expression} //  { $expr = tm.literal(Type.BOOL, Boolean.valueOf($BOOLCONSTANT.text)); }
		//	BOOLCONSTANT | LEFT_PAREN e=expression RIGHT_PAREN;
		public ParserRule getRule() { return rule; }

		//{primary_expression} //    { $expr = tm.variable($IDENTIFIER.text); }
		//IDENTIFIER //{ $expr = tm.parenExpr($e.expr); }
		//| {primary_expression} //   { $expr = tm.literal(Type.INT, Integer.valueOf($INTCONSTANT.text)); }
		//INTCONSTANT | {primary_expression} // { $expr = tm.literal(Type.FLOAT, Float.valueOf($FLOATCONSTANT.text)); }
		//FLOATCONSTANT | {primary_expression} //  { $expr = tm.literal(Type.BOOL, Boolean.valueOf($BOOLCONSTANT.text)); }
		//BOOLCONSTANT | LEFT_PAREN e=expression RIGHT_PAREN
		public Alternatives getAlternatives() { return cAlternatives; }

		//{primary_expression} //    { $expr = tm.variable($IDENTIFIER.text); }
		//IDENTIFIER
		public Group getGroup_0() { return cGroup_0; }

		//{primary_expression}
		public Action getPrimary_expressionAction_0_0() { return cPrimary_expressionAction_0_0; }

		////    { $expr = tm.variable($IDENTIFIER.text); }
		//IDENTIFIER
		public RuleCall getIDENTIFIERParserRuleCall_0_1() { return cIDENTIFIERParserRuleCall_0_1; }

		//{primary_expression} //   { $expr = tm.literal(Type.INT, Integer.valueOf($INTCONSTANT.text)); }
		//INTCONSTANT
		public Group getGroup_1() { return cGroup_1; }

		//{primary_expression}
		public Action getPrimary_expressionAction_1_0() { return cPrimary_expressionAction_1_0; }

		////   { $expr = tm.literal(Type.INT, Integer.valueOf($INTCONSTANT.text)); }
		//INTCONSTANT
		public RuleCall getINTCONSTANTTerminalRuleCall_1_1() { return cINTCONSTANTTerminalRuleCall_1_1; }

		//{primary_expression} // { $expr = tm.literal(Type.FLOAT, Float.valueOf($FLOATCONSTANT.text)); }
		//FLOATCONSTANT
		public Group getGroup_2() { return cGroup_2; }

		//{primary_expression}
		public Action getPrimary_expressionAction_2_0() { return cPrimary_expressionAction_2_0; }

		//// { $expr = tm.literal(Type.FLOAT, Float.valueOf($FLOATCONSTANT.text)); }
		//FLOATCONSTANT
		public RuleCall getFLOATCONSTANTTerminalRuleCall_2_1() { return cFLOATCONSTANTTerminalRuleCall_2_1; }

		//{primary_expression} //  { $expr = tm.literal(Type.BOOL, Boolean.valueOf($BOOLCONSTANT.text)); }
		//BOOLCONSTANT
		public Group getGroup_3() { return cGroup_3; }

		//{primary_expression}
		public Action getPrimary_expressionAction_3_0() { return cPrimary_expressionAction_3_0; }

		////  { $expr = tm.literal(Type.BOOL, Boolean.valueOf($BOOLCONSTANT.text)); }
		//BOOLCONSTANT
		public RuleCall getBOOLCONSTANTParserRuleCall_3_1() { return cBOOLCONSTANTParserRuleCall_3_1; }

		//LEFT_PAREN e=expression RIGHT_PAREN
		public Group getGroup_4() { return cGroup_4; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_4_0() { return cLEFT_PARENTerminalRuleCall_4_0; }

		//e=expression
		public Assignment getEAssignment_4_1() { return cEAssignment_4_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_4_1_0() { return cEExpressionParserRuleCall_4_1_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_4_2() { return cRIGHT_PARENTerminalRuleCall_4_2; }
	}

	public class Primary_or_callElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "primary_or_call");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cEAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cEPrimary_expressionParserRuleCall_0_0 = (RuleCall)cEAssignment_0.eContents().get(0);
		private final Assignment cFAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFFunction_callParserRuleCall_1_0 = (RuleCall)cFAssignment_1.eContents().get(0);
		
		//// returns [Expr expr]
		//primary_or_call:
		//	e= //{ $expr = $e.expr; }
		//	primary_expression | f= //{ $expr = $f.expr; }
		//	function_call;
		public ParserRule getRule() { return rule; }

		//e= //{ $expr = $e.expr; }
		//primary_expression | f= //{ $expr = $f.expr; }
		//function_call
		public Alternatives getAlternatives() { return cAlternatives; }

		//e= //{ $expr = $e.expr; }
		//primary_expression
		public Assignment getEAssignment_0() { return cEAssignment_0; }

		////{ $expr = $e.expr; }
		//primary_expression
		public RuleCall getEPrimary_expressionParserRuleCall_0_0() { return cEPrimary_expressionParserRuleCall_0_0; }

		//f= //{ $expr = $f.expr; }
		//function_call
		public Assignment getFAssignment_1() { return cFAssignment_1; }

		////{ $expr = $f.expr; }
		//function_call
		public RuleCall getFFunction_callParserRuleCall_1_0() { return cFFunction_callParserRuleCall_1_0; }
	}

	public class Postfix_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "postfix_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cEAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cEPrimary_or_callParserRuleCall_0_0_0 = (RuleCall)cEAssignment_0_0.eContents().get(0);
		private final RuleCall cLEFT_BRACKETTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cAeAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cAeExpressionParserRuleCall_0_2_0 = (RuleCall)cAeAssignment_0_2.eContents().get(0);
		private final RuleCall cRIGHT_BRACKETTerminalRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final Assignment cFsAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cFsField_selectionParserRuleCall_0_4_0 = (RuleCall)cFsAssignment_0_4.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cEAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cEPrimary_or_callParserRuleCall_1_0_0 = (RuleCall)cEAssignment_1_0.eContents().get(0);
		private final RuleCall cLEFT_BRACKETTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cAeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cAeExpressionParserRuleCall_1_2_0 = (RuleCall)cAeAssignment_1_2.eContents().get(0);
		private final RuleCall cRIGHT_BRACKETTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cEAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cEPrimary_or_callParserRuleCall_2_0_0 = (RuleCall)cEAssignment_2_0.eContents().get(0);
		private final Assignment cFsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFsField_selectionParserRuleCall_2_1_0 = (RuleCall)cFsAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cEAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cEPrimary_or_callParserRuleCall_3_0_0 = (RuleCall)cEAssignment_3_0.eContents().get(0);
		private final RuleCall cINCTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Assignment cEAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cEPrimary_or_callParserRuleCall_4_0_0 = (RuleCall)cEAssignment_4_0.eContents().get(0);
		private final RuleCall cDECTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Assignment cEAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cEPrimary_or_callParserRuleCall_5_0 = (RuleCall)cEAssignment_5.eContents().get(0);
		
		////
		//// TODO: not sure how to do this properly without mutual left-recursion;
		//// for now we hack it to allow:
		////   arr[3].rgb
		////   arr[3]
		////   val.rgb
		////   val++
		////   val--
		////   val
		//// but not things like:
		////   arr[3].r++
		////
		////returns [Expr expr]
		////{ $expr = $e.expr; }
		//postfix_expression:
		//	e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET fs=field_selection //{ $expr = tm.fieldSelect(tm.arrayAccess($e.expr, $ae.expr), $fs.fields); }
		//	//{ $expr = tm.arrayAccess($e.expr, $ae.expr); }
		//	//{ $expr = tm.fieldSelect($e.expr, $fs.fields); }
		//	//{ $expr = tm.unary(UnaryOpType.INC, $e.expr); }
		//	//{ $expr = tm.unary(UnaryOpType.DEC, $e.expr); }
		//	| e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET | e=primary_or_call fs=field_selection | e=primary_or_call
		//	INC | e=primary_or_call DEC | e=primary_or_call;
		public ParserRule getRule() { return rule; }

		//e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET fs=field_selection //{ $expr = tm.fieldSelect(tm.arrayAccess($e.expr, $ae.expr), $fs.fields); }
		////{ $expr = tm.arrayAccess($e.expr, $ae.expr); }
		////{ $expr = tm.fieldSelect($e.expr, $fs.fields); }
		////{ $expr = tm.unary(UnaryOpType.INC, $e.expr); }
		////{ $expr = tm.unary(UnaryOpType.DEC, $e.expr); }
		//| e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET | e=primary_or_call fs=field_selection | e=primary_or_call
		//INC | e=primary_or_call DEC | e=primary_or_call
		public Alternatives getAlternatives() { return cAlternatives; }

		//e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET fs=field_selection
		public Group getGroup_0() { return cGroup_0; }

		//e=primary_or_call
		public Assignment getEAssignment_0_0() { return cEAssignment_0_0; }

		//primary_or_call
		public RuleCall getEPrimary_or_callParserRuleCall_0_0_0() { return cEPrimary_or_callParserRuleCall_0_0_0; }

		//LEFT_BRACKET
		public RuleCall getLEFT_BRACKETTerminalRuleCall_0_1() { return cLEFT_BRACKETTerminalRuleCall_0_1; }

		//ae=expression
		public Assignment getAeAssignment_0_2() { return cAeAssignment_0_2; }

		//expression
		public RuleCall getAeExpressionParserRuleCall_0_2_0() { return cAeExpressionParserRuleCall_0_2_0; }

		//RIGHT_BRACKET
		public RuleCall getRIGHT_BRACKETTerminalRuleCall_0_3() { return cRIGHT_BRACKETTerminalRuleCall_0_3; }

		//fs=field_selection
		public Assignment getFsAssignment_0_4() { return cFsAssignment_0_4; }

		//field_selection
		public RuleCall getFsField_selectionParserRuleCall_0_4_0() { return cFsField_selectionParserRuleCall_0_4_0; }

		//e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET
		public Group getGroup_1() { return cGroup_1; }

		//e=primary_or_call
		public Assignment getEAssignment_1_0() { return cEAssignment_1_0; }

		//primary_or_call
		public RuleCall getEPrimary_or_callParserRuleCall_1_0_0() { return cEPrimary_or_callParserRuleCall_1_0_0; }

		//LEFT_BRACKET
		public RuleCall getLEFT_BRACKETTerminalRuleCall_1_1() { return cLEFT_BRACKETTerminalRuleCall_1_1; }

		//ae=expression
		public Assignment getAeAssignment_1_2() { return cAeAssignment_1_2; }

		//expression
		public RuleCall getAeExpressionParserRuleCall_1_2_0() { return cAeExpressionParserRuleCall_1_2_0; }

		//RIGHT_BRACKET
		public RuleCall getRIGHT_BRACKETTerminalRuleCall_1_3() { return cRIGHT_BRACKETTerminalRuleCall_1_3; }

		//e=primary_or_call fs=field_selection
		public Group getGroup_2() { return cGroup_2; }

		//e=primary_or_call
		public Assignment getEAssignment_2_0() { return cEAssignment_2_0; }

		//primary_or_call
		public RuleCall getEPrimary_or_callParserRuleCall_2_0_0() { return cEPrimary_or_callParserRuleCall_2_0_0; }

		//fs=field_selection
		public Assignment getFsAssignment_2_1() { return cFsAssignment_2_1; }

		//field_selection
		public RuleCall getFsField_selectionParserRuleCall_2_1_0() { return cFsField_selectionParserRuleCall_2_1_0; }

		//e=primary_or_call INC
		public Group getGroup_3() { return cGroup_3; }

		//e=primary_or_call
		public Assignment getEAssignment_3_0() { return cEAssignment_3_0; }

		//primary_or_call
		public RuleCall getEPrimary_or_callParserRuleCall_3_0_0() { return cEPrimary_or_callParserRuleCall_3_0_0; }

		//INC
		public RuleCall getINCTerminalRuleCall_3_1() { return cINCTerminalRuleCall_3_1; }

		//e=primary_or_call DEC
		public Group getGroup_4() { return cGroup_4; }

		//e=primary_or_call
		public Assignment getEAssignment_4_0() { return cEAssignment_4_0; }

		//primary_or_call
		public RuleCall getEPrimary_or_callParserRuleCall_4_0_0() { return cEPrimary_or_callParserRuleCall_4_0_0; }

		//DEC
		public RuleCall getDECTerminalRuleCall_4_1() { return cDECTerminalRuleCall_4_1; }

		//e=primary_or_call
		public Assignment getEAssignment_5() { return cEAssignment_5; }

		//primary_or_call
		public RuleCall getEPrimary_or_callParserRuleCall_5_0() { return cEPrimary_or_callParserRuleCall_5_0; }
	}

	public class Function_callElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "function_call");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cIdAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cIdIDENTIFIERParserRuleCall_0_0_0 = (RuleCall)cIdAssignment_0_0.eContents().get(0);
		private final RuleCall cLEFT_PARENTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cPAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cPFunction_call_parameter_listParserRuleCall_0_2_0 = (RuleCall)cPAssignment_0_2.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTsType_specifierParserRuleCall_1_0_0 = (RuleCall)cTsAssignment_1_0.eContents().get(0);
		private final RuleCall cLEFT_PARENTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cPAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cPFunction_call_parameter_listParserRuleCall_1_2_0 = (RuleCall)cPAssignment_1_2.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		
		//// From the GLSL spec...
		//// Grammar Note: Constructors look like functions, but lexical
		//// analysis recognized most of them as keywords.  They are now
		//// recognized through "type_specifier".
		////returns [Expr expr]
		////            {
		////                Type type = Type.fromToken($ts.text);
		////                $expr = tm.vectorCtor(type, p!=null ? $p.exprList : null);
		////            }
		//function_call:
		//	id=IDENTIFIER LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN //            {
		//	//                $expr = tm.call($id.text, p!=null ? $p.exprList : null);
		//	//            }
		//	| ts=type_specifier LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN;
		public ParserRule getRule() { return rule; }

		//id=IDENTIFIER LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN //            {
		////                $expr = tm.call($id.text, p!=null ? $p.exprList : null);
		////            }
		//| ts=type_specifier LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN
		public Alternatives getAlternatives() { return cAlternatives; }

		//id=IDENTIFIER LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN
		public Group getGroup_0() { return cGroup_0; }

		//id=IDENTIFIER
		public Assignment getIdAssignment_0_0() { return cIdAssignment_0_0; }

		//IDENTIFIER
		public RuleCall getIdIDENTIFIERParserRuleCall_0_0_0() { return cIdIDENTIFIERParserRuleCall_0_0_0; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_0_1() { return cLEFT_PARENTerminalRuleCall_0_1; }

		//p=function_call_parameter_list?
		public Assignment getPAssignment_0_2() { return cPAssignment_0_2; }

		//function_call_parameter_list
		public RuleCall getPFunction_call_parameter_listParserRuleCall_0_2_0() { return cPFunction_call_parameter_listParserRuleCall_0_2_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_0_3() { return cRIGHT_PARENTerminalRuleCall_0_3; }

		//ts=type_specifier LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN
		public Group getGroup_1() { return cGroup_1; }

		//ts=type_specifier
		public Assignment getTsAssignment_1_0() { return cTsAssignment_1_0; }

		//type_specifier
		public RuleCall getTsType_specifierParserRuleCall_1_0_0() { return cTsType_specifierParserRuleCall_1_0_0; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_1_1() { return cLEFT_PARENTerminalRuleCall_1_1; }

		//p=function_call_parameter_list?
		public Assignment getPAssignment_1_2() { return cPAssignment_1_2; }

		//function_call_parameter_list
		public RuleCall getPFunction_call_parameter_listParserRuleCall_1_2_0() { return cPFunction_call_parameter_listParserRuleCall_1_2_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_1_3() { return cRIGHT_PARENTerminalRuleCall_1_3; }
	}

	public class Function_call_parameter_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "function_call_parameter_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAAssignment_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cAAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAAssignment_expressionParserRuleCall_1_1_0 = (RuleCall)cAAssignment_1_1.eContents().get(0);
		
		////returns [List<Expr> exprList = new ArrayList<Expr>()]
		//function_call_parameter_list:
		//	a+= //{ $exprList.add($a.expr); }
		//	assignment_expression (COMMA a+= //{$exprList.add($a.expr); }
		//	assignment_expression)*;
		public ParserRule getRule() { return rule; }

		//a+= //{ $exprList.add($a.expr); }
		//assignment_expression (COMMA a+= //{$exprList.add($a.expr); }
		//assignment_expression)*
		public Group getGroup() { return cGroup; }

		//a+= //{ $exprList.add($a.expr); }
		//assignment_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $exprList.add($a.expr); }
		//assignment_expression
		public RuleCall getAAssignment_expressionParserRuleCall_0_0() { return cAAssignment_expressionParserRuleCall_0_0; }

		//(COMMA a+= //{$exprList.add($a.expr); }
		//assignment_expression)*
		public Group getGroup_1() { return cGroup_1; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0() { return cCOMMATerminalRuleCall_1_0; }

		//a+= //{$exprList.add($a.expr); }
		//assignment_expression
		public Assignment getAAssignment_1_1() { return cAAssignment_1_1; }

		////{$exprList.add($a.expr); }
		//assignment_expression
		public RuleCall getAAssignment_expressionParserRuleCall_1_1_0() { return cAAssignment_expressionParserRuleCall_1_1_0; }
	}

	public class Unary_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unary_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cPAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cPPostfix_expressionParserRuleCall_0_0 = (RuleCall)cPAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cINCTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cUAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUUnary_expressionParserRuleCall_1_1_0 = (RuleCall)cUAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cDECTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cUAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUUnary_expressionParserRuleCall_2_1_0 = (RuleCall)cUAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cPLUSTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cUAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cUUnary_expressionParserRuleCall_3_1_0 = (RuleCall)cUAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cDASHTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cUAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cUUnary_expressionParserRuleCall_4_1_0 = (RuleCall)cUAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final RuleCall cBANGTerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cUAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cUUnary_expressionParserRuleCall_5_1_0 = (RuleCall)cUAssignment_5_1.eContents().get(0);
		
		////returns [Expr expr]
		//unary_expression:
		//	p=postfix_expression //{ $expr = $p.expr; }
		//	//{ $expr = tm.unary(UnaryOpType.INC,     $u.expr); }
		//	//{ $expr = tm.unary(UnaryOpType.DEC,     $u.expr); }
		//	//{ $expr = tm.unary(UnaryOpType.PLUS,    $u.expr); }
		//	//{ $expr = tm.unary(UnaryOpType.MINUS,   $u.expr); }
		//	//{ $expr = tm.unary(UnaryOpType.NOT,     $u.expr); }
		//	| INC u=unary_expression | DEC u=unary_expression | PLUS u=unary_expression | DASH u=unary_expression | BANG
		//	u=unary_expression;
		public ParserRule getRule() { return rule; }

		//p=postfix_expression //{ $expr = $p.expr; }
		////{ $expr = tm.unary(UnaryOpType.INC,     $u.expr); }
		////{ $expr = tm.unary(UnaryOpType.DEC,     $u.expr); }
		////{ $expr = tm.unary(UnaryOpType.PLUS,    $u.expr); }
		////{ $expr = tm.unary(UnaryOpType.MINUS,   $u.expr); }
		////{ $expr = tm.unary(UnaryOpType.NOT,     $u.expr); }
		//| INC u=unary_expression | DEC u=unary_expression | PLUS u=unary_expression | DASH u=unary_expression | BANG
		//u=unary_expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//p=postfix_expression
		public Assignment getPAssignment_0() { return cPAssignment_0; }

		//postfix_expression
		public RuleCall getPPostfix_expressionParserRuleCall_0_0() { return cPPostfix_expressionParserRuleCall_0_0; }

		//INC u=unary_expression
		public Group getGroup_1() { return cGroup_1; }

		//INC
		public RuleCall getINCTerminalRuleCall_1_0() { return cINCTerminalRuleCall_1_0; }

		//u=unary_expression
		public Assignment getUAssignment_1_1() { return cUAssignment_1_1; }

		//unary_expression
		public RuleCall getUUnary_expressionParserRuleCall_1_1_0() { return cUUnary_expressionParserRuleCall_1_1_0; }

		//DEC u=unary_expression
		public Group getGroup_2() { return cGroup_2; }

		//DEC
		public RuleCall getDECTerminalRuleCall_2_0() { return cDECTerminalRuleCall_2_0; }

		//u=unary_expression
		public Assignment getUAssignment_2_1() { return cUAssignment_2_1; }

		//unary_expression
		public RuleCall getUUnary_expressionParserRuleCall_2_1_0() { return cUUnary_expressionParserRuleCall_2_1_0; }

		//PLUS u=unary_expression
		public Group getGroup_3() { return cGroup_3; }

		//PLUS
		public RuleCall getPLUSTerminalRuleCall_3_0() { return cPLUSTerminalRuleCall_3_0; }

		//u=unary_expression
		public Assignment getUAssignment_3_1() { return cUAssignment_3_1; }

		//unary_expression
		public RuleCall getUUnary_expressionParserRuleCall_3_1_0() { return cUUnary_expressionParserRuleCall_3_1_0; }

		//DASH u=unary_expression
		public Group getGroup_4() { return cGroup_4; }

		//DASH
		public RuleCall getDASHTerminalRuleCall_4_0() { return cDASHTerminalRuleCall_4_0; }

		//u=unary_expression
		public Assignment getUAssignment_4_1() { return cUAssignment_4_1; }

		//unary_expression
		public RuleCall getUUnary_expressionParserRuleCall_4_1_0() { return cUUnary_expressionParserRuleCall_4_1_0; }

		//BANG u=unary_expression
		public Group getGroup_5() { return cGroup_5; }

		//BANG
		public RuleCall getBANGTerminalRuleCall_5_0() { return cBANGTerminalRuleCall_5_0; }

		//u=unary_expression
		public Assignment getUAssignment_5_1() { return cUAssignment_5_1; }

		//unary_expression
		public RuleCall getUUnary_expressionParserRuleCall_5_1_0() { return cUUnary_expressionParserRuleCall_5_1_0; }
	}

	public class Multiplicative_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "multiplicative_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAUnary_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final RuleCall cSTARTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cBAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBMultiplicative_expressionParserRuleCall_1_0_1_0 = (RuleCall)cBAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cSLASHTerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cBAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBMultiplicative_expressionParserRuleCall_1_1_1_0 = (RuleCall)cBAssignment_1_1_1.eContents().get(0);
		
		//// From the GLSL spec...
		//// Grammar Note:  No traditional style type casts.
		//// From the GLSL spec...
		//// Grammar Note:  No '*' or '&' unary ops.  Pointers are not supported.
		////returns [Expr expr]
		//multiplicative_expression:
		//	a= //{ $expr = $a.expr; }
		//	unary_expression (STAR b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.MUL, $expr, $b.expr); }
		//	//{ $expr = tm.binary(BinaryOpType.DIV, $expr, $b.expr); }
		//	| SLASH b+=multiplicative_expression)*;
		public ParserRule getRule() { return rule; }

		//a= //{ $expr = $a.expr; }
		//unary_expression (STAR b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.MUL, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.DIV, $expr, $b.expr); }
		//| SLASH b+=multiplicative_expression)*
		public Group getGroup() { return cGroup; }

		//a= //{ $expr = $a.expr; }
		//unary_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $expr = $a.expr; }
		//unary_expression
		public RuleCall getAUnary_expressionParserRuleCall_0_0() { return cAUnary_expressionParserRuleCall_0_0; }

		//(STAR b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.MUL, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.DIV, $expr, $b.expr); }
		//| SLASH b+=multiplicative_expression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//STAR b+=multiplicative_expression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//STAR
		public RuleCall getSTARTerminalRuleCall_1_0_0() { return cSTARTerminalRuleCall_1_0_0; }

		//b+=multiplicative_expression
		public Assignment getBAssignment_1_0_1() { return cBAssignment_1_0_1; }

		//multiplicative_expression
		public RuleCall getBMultiplicative_expressionParserRuleCall_1_0_1_0() { return cBMultiplicative_expressionParserRuleCall_1_0_1_0; }

		//SLASH b+=multiplicative_expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//SLASH
		public RuleCall getSLASHTerminalRuleCall_1_1_0() { return cSLASHTerminalRuleCall_1_1_0; }

		//b+=multiplicative_expression
		public Assignment getBAssignment_1_1_1() { return cBAssignment_1_1_1; }

		//multiplicative_expression
		public RuleCall getBMultiplicative_expressionParserRuleCall_1_1_1_0() { return cBMultiplicative_expressionParserRuleCall_1_1_1_0; }
	}

	public class Additive_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "additive_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAMultiplicative_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final RuleCall cPLUSTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cBAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBMultiplicative_expressionParserRuleCall_1_0_1_0 = (RuleCall)cBAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cDASHTerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cBAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBMultiplicative_expressionParserRuleCall_1_1_1_0 = (RuleCall)cBAssignment_1_1_1.eContents().get(0);
		
		////returns [Expr expr]
		//additive_expression:
		//	a= //{ $expr = $a.expr; }
		//	multiplicative_expression (PLUS b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.ADD, $expr, $b.expr); }
		//	//{ $expr = tm.binary(BinaryOpType.SUB, $expr, $b.expr); }
		//	| DASH b+=multiplicative_expression)*;
		public ParserRule getRule() { return rule; }

		//a= //{ $expr = $a.expr; }
		//multiplicative_expression (PLUS b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.ADD, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.SUB, $expr, $b.expr); }
		//| DASH b+=multiplicative_expression)*
		public Group getGroup() { return cGroup; }

		//a= //{ $expr = $a.expr; }
		//multiplicative_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $expr = $a.expr; }
		//multiplicative_expression
		public RuleCall getAMultiplicative_expressionParserRuleCall_0_0() { return cAMultiplicative_expressionParserRuleCall_0_0; }

		//(PLUS b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.ADD, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.SUB, $expr, $b.expr); }
		//| DASH b+=multiplicative_expression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//PLUS b+=multiplicative_expression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//PLUS
		public RuleCall getPLUSTerminalRuleCall_1_0_0() { return cPLUSTerminalRuleCall_1_0_0; }

		//b+=multiplicative_expression
		public Assignment getBAssignment_1_0_1() { return cBAssignment_1_0_1; }

		//multiplicative_expression
		public RuleCall getBMultiplicative_expressionParserRuleCall_1_0_1_0() { return cBMultiplicative_expressionParserRuleCall_1_0_1_0; }

		//DASH b+=multiplicative_expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//DASH
		public RuleCall getDASHTerminalRuleCall_1_1_0() { return cDASHTerminalRuleCall_1_1_0; }

		//b+=multiplicative_expression
		public Assignment getBAssignment_1_1_1() { return cBAssignment_1_1_1; }

		//multiplicative_expression
		public RuleCall getBMultiplicative_expressionParserRuleCall_1_1_1_0() { return cBMultiplicative_expressionParserRuleCall_1_1_1_0; }
	}

	public class Relational_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "relational_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAAdditive_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final RuleCall cLTEQTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cBAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBAdditive_expressionParserRuleCall_1_0_1_0 = (RuleCall)cBAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cGTEQTerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cBAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBAdditive_expressionParserRuleCall_1_1_1_0 = (RuleCall)cBAssignment_1_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final RuleCall cLTTerminalRuleCall_1_2_0 = (RuleCall)cGroup_1_2.eContents().get(0);
		private final Assignment cBAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cBAdditive_expressionParserRuleCall_1_2_1_0 = (RuleCall)cBAssignment_1_2_1.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final RuleCall cGTTerminalRuleCall_1_3_0 = (RuleCall)cGroup_1_3.eContents().get(0);
		private final Assignment cBAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cBAdditive_expressionParserRuleCall_1_3_1_0 = (RuleCall)cBAssignment_1_3_1.eContents().get(0);
		
		////returns [Expr expr]
		//relational_expression:
		//	a= //{ $expr = $a.expr; }
		//	additive_expression (LTEQ b+=additive_expression //{ $expr = tm.binary(BinaryOpType.LTEQ, $expr, $b.expr); }
		//	//{ $expr = tm.binary(BinaryOpType.GTEQ, $expr, $b.expr); }
		//	//{ $expr = tm.binary(BinaryOpType.LT,   $expr, $b.expr); }
		//	//{ $expr = tm.binary(BinaryOpType.GT,   $expr, $b.expr); }
		//	| GTEQ b+=additive_expression | LT b+=additive_expression | GT b+=additive_expression)*;
		public ParserRule getRule() { return rule; }

		//a= //{ $expr = $a.expr; }
		//additive_expression (LTEQ b+=additive_expression //{ $expr = tm.binary(BinaryOpType.LTEQ, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.GTEQ, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.LT,   $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.GT,   $expr, $b.expr); }
		//| GTEQ b+=additive_expression | LT b+=additive_expression | GT b+=additive_expression)*
		public Group getGroup() { return cGroup; }

		//a= //{ $expr = $a.expr; }
		//additive_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $expr = $a.expr; }
		//additive_expression
		public RuleCall getAAdditive_expressionParserRuleCall_0_0() { return cAAdditive_expressionParserRuleCall_0_0; }

		//(LTEQ b+=additive_expression //{ $expr = tm.binary(BinaryOpType.LTEQ, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.GTEQ, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.LT,   $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.GT,   $expr, $b.expr); }
		//| GTEQ b+=additive_expression | LT b+=additive_expression | GT b+=additive_expression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//LTEQ b+=additive_expression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//LTEQ
		public RuleCall getLTEQTerminalRuleCall_1_0_0() { return cLTEQTerminalRuleCall_1_0_0; }

		//b+=additive_expression
		public Assignment getBAssignment_1_0_1() { return cBAssignment_1_0_1; }

		//additive_expression
		public RuleCall getBAdditive_expressionParserRuleCall_1_0_1_0() { return cBAdditive_expressionParserRuleCall_1_0_1_0; }

		//GTEQ b+=additive_expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//GTEQ
		public RuleCall getGTEQTerminalRuleCall_1_1_0() { return cGTEQTerminalRuleCall_1_1_0; }

		//b+=additive_expression
		public Assignment getBAssignment_1_1_1() { return cBAssignment_1_1_1; }

		//additive_expression
		public RuleCall getBAdditive_expressionParserRuleCall_1_1_1_0() { return cBAdditive_expressionParserRuleCall_1_1_1_0; }

		//LT b+=additive_expression
		public Group getGroup_1_2() { return cGroup_1_2; }

		//LT
		public RuleCall getLTTerminalRuleCall_1_2_0() { return cLTTerminalRuleCall_1_2_0; }

		//b+=additive_expression
		public Assignment getBAssignment_1_2_1() { return cBAssignment_1_2_1; }

		//additive_expression
		public RuleCall getBAdditive_expressionParserRuleCall_1_2_1_0() { return cBAdditive_expressionParserRuleCall_1_2_1_0; }

		//GT b+=additive_expression
		public Group getGroup_1_3() { return cGroup_1_3; }

		//GT
		public RuleCall getGTTerminalRuleCall_1_3_0() { return cGTTerminalRuleCall_1_3_0; }

		//b+=additive_expression
		public Assignment getBAssignment_1_3_1() { return cBAssignment_1_3_1; }

		//additive_expression
		public RuleCall getBAdditive_expressionParserRuleCall_1_3_1_0() { return cBAdditive_expressionParserRuleCall_1_3_1_0; }
	}

	public class Equality_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "equality_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cARelational_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final RuleCall cEQEQTerminalRuleCall_1_0_0 = (RuleCall)cGroup_1_0.eContents().get(0);
		private final Assignment cBAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cBRelational_expressionParserRuleCall_1_0_1_0 = (RuleCall)cBAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cNEQTerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cBAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cBRelational_expressionParserRuleCall_1_1_1_0 = (RuleCall)cBAssignment_1_1_1.eContents().get(0);
		
		////returns [Expr expr]
		//equality_expression:
		//	a= //{ $expr = $a.expr; }
		//	relational_expression (EQEQ b+=relational_expression //{ $expr = tm.binary(BinaryOpType.EQEQ, $expr, $b.expr); }
		//	//{ $expr = tm.binary(BinaryOpType.NEQ,  $expr, $b.expr); }
		//	| NEQ b+=relational_expression)*;
		public ParserRule getRule() { return rule; }

		//a= //{ $expr = $a.expr; }
		//relational_expression (EQEQ b+=relational_expression //{ $expr = tm.binary(BinaryOpType.EQEQ, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.NEQ,  $expr, $b.expr); }
		//| NEQ b+=relational_expression)*
		public Group getGroup() { return cGroup; }

		//a= //{ $expr = $a.expr; }
		//relational_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $expr = $a.expr; }
		//relational_expression
		public RuleCall getARelational_expressionParserRuleCall_0_0() { return cARelational_expressionParserRuleCall_0_0; }

		//(EQEQ b+=relational_expression //{ $expr = tm.binary(BinaryOpType.EQEQ, $expr, $b.expr); }
		////{ $expr = tm.binary(BinaryOpType.NEQ,  $expr, $b.expr); }
		//| NEQ b+=relational_expression)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//EQEQ b+=relational_expression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//EQEQ
		public RuleCall getEQEQTerminalRuleCall_1_0_0() { return cEQEQTerminalRuleCall_1_0_0; }

		//b+=relational_expression
		public Assignment getBAssignment_1_0_1() { return cBAssignment_1_0_1; }

		//relational_expression
		public RuleCall getBRelational_expressionParserRuleCall_1_0_1_0() { return cBRelational_expressionParserRuleCall_1_0_1_0; }

		//NEQ b+=relational_expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//NEQ
		public RuleCall getNEQTerminalRuleCall_1_1_0() { return cNEQTerminalRuleCall_1_1_0; }

		//b+=relational_expression
		public Assignment getBAssignment_1_1_1() { return cBAssignment_1_1_1; }

		//relational_expression
		public RuleCall getBRelational_expressionParserRuleCall_1_1_1_0() { return cBRelational_expressionParserRuleCall_1_1_1_0; }
	}

	public class Logical_and_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "logical_and_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAEquality_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cANDTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cBAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBEquality_expressionParserRuleCall_1_1_0 = (RuleCall)cBAssignment_1_1.eContents().get(0);
		
		////returns [Expr expr]
		//logical_and_expression:
		//	a= //{ $expr = $a.expr; }
		//	equality_expression (AND b+= //{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
		//	equality_expression)*;
		public ParserRule getRule() { return rule; }

		//a= //{ $expr = $a.expr; }
		//equality_expression (AND b+= //{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
		//equality_expression)*
		public Group getGroup() { return cGroup; }

		//a= //{ $expr = $a.expr; }
		//equality_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $expr = $a.expr; }
		//equality_expression
		public RuleCall getAEquality_expressionParserRuleCall_0_0() { return cAEquality_expressionParserRuleCall_0_0; }

		//(AND b+= //{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
		//equality_expression)*
		public Group getGroup_1() { return cGroup_1; }

		//AND
		public RuleCall getANDTerminalRuleCall_1_0() { return cANDTerminalRuleCall_1_0; }

		//b+= //{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
		//equality_expression
		public Assignment getBAssignment_1_1() { return cBAssignment_1_1; }

		////{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
		//equality_expression
		public RuleCall getBEquality_expressionParserRuleCall_1_1_0() { return cBEquality_expressionParserRuleCall_1_1_0; }
	}

	public class Logical_xor_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "logical_xor_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cALogical_and_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cXORTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cBAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBLogical_and_expressionParserRuleCall_1_1_0 = (RuleCall)cBAssignment_1_1.eContents().get(0);
		
		////returns [Expr expr]
		//logical_xor_expression:
		//	a= //{ $expr = $a.expr; }
		//	logical_and_expression (XOR b+= //{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
		//	logical_and_expression)*;
		public ParserRule getRule() { return rule; }

		//a= //{ $expr = $a.expr; }
		//logical_and_expression (XOR b+= //{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
		//logical_and_expression)*
		public Group getGroup() { return cGroup; }

		//a= //{ $expr = $a.expr; }
		//logical_and_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $expr = $a.expr; }
		//logical_and_expression
		public RuleCall getALogical_and_expressionParserRuleCall_0_0() { return cALogical_and_expressionParserRuleCall_0_0; }

		//(XOR b+= //{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
		//logical_and_expression)*
		public Group getGroup_1() { return cGroup_1; }

		//XOR
		public RuleCall getXORTerminalRuleCall_1_0() { return cXORTerminalRuleCall_1_0; }

		//b+= //{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
		//logical_and_expression
		public Assignment getBAssignment_1_1() { return cBAssignment_1_1; }

		////{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
		//logical_and_expression
		public RuleCall getBLogical_and_expressionParserRuleCall_1_1_0() { return cBLogical_and_expressionParserRuleCall_1_1_0; }
	}

	public class Logical_or_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "logical_or_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cALogical_xor_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cORTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cBAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBLogical_xor_expressionParserRuleCall_1_1_0 = (RuleCall)cBAssignment_1_1.eContents().get(0);
		
		////returns [Expr expr]
		//logical_or_expression:
		//	a= //{ $expr = $a.expr; }
		//	logical_xor_expression (OR b+= //{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
		//	logical_xor_expression)*;
		public ParserRule getRule() { return rule; }

		//a= //{ $expr = $a.expr; }
		//logical_xor_expression (OR b+= //{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
		//logical_xor_expression)*
		public Group getGroup() { return cGroup; }

		//a= //{ $expr = $a.expr; }
		//logical_xor_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		////{ $expr = $a.expr; }
		//logical_xor_expression
		public RuleCall getALogical_xor_expressionParserRuleCall_0_0() { return cALogical_xor_expressionParserRuleCall_0_0; }

		//(OR b+= //{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
		//logical_xor_expression)*
		public Group getGroup_1() { return cGroup_1; }

		//OR
		public RuleCall getORTerminalRuleCall_1_0() { return cORTerminalRuleCall_1_0; }

		//b+= //{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
		//logical_xor_expression
		public Assignment getBAssignment_1_1() { return cBAssignment_1_1; }

		////{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
		//logical_xor_expression
		public RuleCall getBLogical_xor_expressionParserRuleCall_1_1_0() { return cBLogical_xor_expressionParserRuleCall_1_1_0; }
	}

	public class Ternary_partElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ternary_part");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQUESTIONTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cCOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cAAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAAssignment_expressionParserRuleCall_3_0 = (RuleCall)cAAssignment_3.eContents().get(0);
		
		//ternary_part:
		//	QUESTION expression COLON a=assignment_expression;
		public ParserRule getRule() { return rule; }

		//QUESTION expression COLON a=assignment_expression
		public Group getGroup() { return cGroup; }

		//QUESTION
		public RuleCall getQUESTIONTerminalRuleCall_0() { return cQUESTIONTerminalRuleCall_0; }

		//expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//COLON
		public RuleCall getCOLONTerminalRuleCall_2() { return cCOLONTerminalRuleCall_2; }

		//a=assignment_expression
		public Assignment getAAssignment_3() { return cAAssignment_3; }

		//assignment_expression
		public RuleCall getAAssignment_expressionParserRuleCall_3_0() { return cAAssignment_expressionParserRuleCall_3_0; }
	}

	public class Conditional_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "conditional_expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cALogical_or_expressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Assignment cTAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTTernary_partParserRuleCall_1_0 = (RuleCall)cTAssignment_1.eContents().get(0);
		
		//// TODO: handle ternary
		////returns [Expr expr]
		//conditional_expression:
		//	a=logical_or_expression //{ $expr = $a.expr; }
		//	t=ternary_part?;
		public ParserRule getRule() { return rule; }

		//a=logical_or_expression //{ $expr = $a.expr; }
		//t=ternary_part?
		public Group getGroup() { return cGroup; }

		//a=logical_or_expression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		//logical_or_expression
		public RuleCall getALogical_or_expressionParserRuleCall_0_0() { return cALogical_or_expressionParserRuleCall_0_0; }

		////{ $expr = $a.expr; }
		//t=ternary_part?
		public Assignment getTAssignment_1() { return cTAssignment_1; }

		//ternary_part
		public RuleCall getTTernary_partParserRuleCall_1_0() { return cTTernary_partParserRuleCall_1_0; }
	}

	public class Assignment_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "assignment_expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cAAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cAUnary_expressionParserRuleCall_0_0_0 = (RuleCall)cAAssignment_0_0.eContents().get(0);
		private final Assignment cOpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOpAssignment_operatorParserRuleCall_0_1_0 = (RuleCall)cOpAssignment_0_1.eContents().get(0);
		private final Assignment cBAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cBAssignment_expressionParserRuleCall_0_2_0 = (RuleCall)cBAssignment_0_2.eContents().get(0);
		private final Assignment cCAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cCConditional_expressionParserRuleCall_1_0 = (RuleCall)cCAssignment_1.eContents().get(0);
		
		////returns [Expr expr]
		////{ $expr = $c.expr; }
		//assignment_expression:
		//	a=unary_expression op=assignment_operator b=assignment_expression //{ $expr = tm.binary(BinaryOpType.forSymbol($op.text), $a.expr, $b.expr); }
		//	| c=conditional_expression;
		public ParserRule getRule() { return rule; }

		//a=unary_expression op=assignment_operator b=assignment_expression //{ $expr = tm.binary(BinaryOpType.forSymbol($op.text), $a.expr, $b.expr); }
		//| c=conditional_expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//a=unary_expression op=assignment_operator b=assignment_expression
		public Group getGroup_0() { return cGroup_0; }

		//a=unary_expression
		public Assignment getAAssignment_0_0() { return cAAssignment_0_0; }

		//unary_expression
		public RuleCall getAUnary_expressionParserRuleCall_0_0_0() { return cAUnary_expressionParserRuleCall_0_0_0; }

		//op=assignment_operator
		public Assignment getOpAssignment_0_1() { return cOpAssignment_0_1; }

		//assignment_operator
		public RuleCall getOpAssignment_operatorParserRuleCall_0_1_0() { return cOpAssignment_operatorParserRuleCall_0_1_0; }

		//b=assignment_expression
		public Assignment getBAssignment_0_2() { return cBAssignment_0_2; }

		//assignment_expression
		public RuleCall getBAssignment_expressionParserRuleCall_0_2_0() { return cBAssignment_expressionParserRuleCall_0_2_0; }

		//c=conditional_expression
		public Assignment getCAssignment_1() { return cCAssignment_1; }

		//conditional_expression
		public RuleCall getCConditional_expressionParserRuleCall_1_0() { return cCConditional_expressionParserRuleCall_1_0; }
	}

	public class Assignment_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "assignment_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEQUALTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSTAREQTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSLASHEQTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPLUSEQTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cDASHEQTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//assignment_operator:
		//	EQUAL | STAREQ | SLASHEQ | PLUSEQ | DASHEQ;
		public ParserRule getRule() { return rule; }

		//EQUAL | STAREQ | SLASHEQ | PLUSEQ | DASHEQ
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQUAL
		public RuleCall getEQUALTerminalRuleCall_0() { return cEQUALTerminalRuleCall_0; }

		//STAREQ
		public RuleCall getSTAREQTerminalRuleCall_1() { return cSTAREQTerminalRuleCall_1; }

		//SLASHEQ
		public RuleCall getSLASHEQTerminalRuleCall_2() { return cSLASHEQTerminalRuleCall_2; }

		//PLUSEQ
		public RuleCall getPLUSEQTerminalRuleCall_3() { return cPLUSEQTerminalRuleCall_3; }

		//DASHEQ
		public RuleCall getDASHEQTerminalRuleCall_4() { return cDASHEQTerminalRuleCall_4; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "expression");
		private final Assignment cEAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cEAssignment_expressionParserRuleCall_0 = (RuleCall)cEAssignment.eContents().get(0);
		
		//// TODO: handle expression lists?
		////expression returns [List<Expr> exprList = new ArrayList<Expr>()]
		////        : e=assignment_expression { $exprList.add($e.expr); }
		////          (COMMA e=assignment_expression { $exprList.add($e.expr); })*
		////        ;
		////returns [Expr expr]
		//expression:
		//	e= //{ $expr = $e.expr; }
		//	assignment_expression;
		public ParserRule getRule() { return rule; }

		//e= //{ $expr = $e.expr; }
		//assignment_expression
		public Assignment getEAssignment() { return cEAssignment; }

		////{ $expr = $e.expr; }
		//assignment_expression
		public RuleCall getEAssignment_expressionParserRuleCall_0() { return cEAssignment_expressionParserRuleCall_0; }
	}

	public class Function_prototypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "function_prototype");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTType_specifierParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cIdAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdIDENTIFIERParserRuleCall_1_0 = (RuleCall)cIdAssignment_1.eContents().get(0);
		private final RuleCall cLEFT_PARENTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cPAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPParameter_declaration_listParserRuleCall_3_0 = (RuleCall)cPAssignment_3.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		////returns [Function func]
		////            {
		////                Type type = Type.fromToken($t.text);
		////                $func = symbols.declareFunction($id.text, type, (p != null) ? $p.paramList : null);
		////            }
		//function_prototype:
		//	t=type_specifier id=IDENTIFIER LEFT_PAREN p=parameter_declaration_list? RIGHT_PAREN;
		public ParserRule getRule() { return rule; }

		//t=type_specifier id=IDENTIFIER LEFT_PAREN p=parameter_declaration_list? RIGHT_PAREN
		public Group getGroup() { return cGroup; }

		//t=type_specifier
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//type_specifier
		public RuleCall getTType_specifierParserRuleCall_0_0() { return cTType_specifierParserRuleCall_0_0; }

		//id=IDENTIFIER
		public Assignment getIdAssignment_1() { return cIdAssignment_1; }

		//IDENTIFIER
		public RuleCall getIdIDENTIFIERParserRuleCall_1_0() { return cIdIDENTIFIERParserRuleCall_1_0; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_2() { return cLEFT_PARENTerminalRuleCall_2; }

		//p=parameter_declaration_list?
		public Assignment getPAssignment_3() { return cPAssignment_3; }

		//parameter_declaration_list
		public RuleCall getPParameter_declaration_listParserRuleCall_3_0() { return cPParameter_declaration_listParserRuleCall_3_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_4() { return cRIGHT_PARENTerminalRuleCall_4; }
	}

	public class Parameter_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "parameter_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTType_specifierParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cIdAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdIDENTIFIERParserRuleCall_1_0 = (RuleCall)cIdAssignment_1.eContents().get(0);
		
		////returns [Param param]
		////            {
		////                Type type = Type.fromToken($t.text);
		////                $param = new Param($id.text, type);
		////            }
		//parameter_declaration:
		//	t=type_specifier id=IDENTIFIER;
		public ParserRule getRule() { return rule; }

		//t=type_specifier id=IDENTIFIER
		public Group getGroup() { return cGroup; }

		//t=type_specifier
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//type_specifier
		public RuleCall getTType_specifierParserRuleCall_0_0() { return cTType_specifierParserRuleCall_0_0; }

		//id=IDENTIFIER
		public Assignment getIdAssignment_1() { return cIdAssignment_1; }

		//IDENTIFIER
		public RuleCall getIdIDENTIFIERParserRuleCall_1_0() { return cIdIDENTIFIERParserRuleCall_1_0; }
	}

	public class Parameter_declaration_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "parameter_declaration_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPParameter_declarationParserRuleCall_0_0 = (RuleCall)cPAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cPAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPParameter_declarationParserRuleCall_1_1_0 = (RuleCall)cPAssignment_1_1.eContents().get(0);
		
		////returns [List<Param> paramList = new ArrayList<Param>()]
		//parameter_declaration_list:
		//	p+= //{ $paramList.add($p.param); }
		//	parameter_declaration (COMMA p+=parameter_declaration)* / *{ $paramList.add($p.param); }* /;
		public ParserRule getRule() { return rule; }

		//p+= //{ $paramList.add($p.param); }
		//parameter_declaration (COMMA p+=parameter_declaration)* / *{ $paramList.add($p.param); }* /
		public Group getGroup() { return cGroup; }

		//p+= //{ $paramList.add($p.param); }
		//parameter_declaration
		public Assignment getPAssignment_0() { return cPAssignment_0; }

		////{ $paramList.add($p.param); }
		//parameter_declaration
		public RuleCall getPParameter_declarationParserRuleCall_0_0() { return cPParameter_declarationParserRuleCall_0_0; }

		//(COMMA p+=parameter_declaration)*
		public Group getGroup_1() { return cGroup_1; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0() { return cCOMMATerminalRuleCall_1_0; }

		//p+=parameter_declaration
		public Assignment getPAssignment_1_1() { return cPAssignment_1_1; }

		//parameter_declaration
		public RuleCall getPParameter_declarationParserRuleCall_1_1_0() { return cPParameter_declarationParserRuleCall_1_1_0; }
	}

	public class Declaration_identifier_and_initElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "declaration_identifier_and_init");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdIDENTIFIERParserRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cLEFT_BRACKETTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cAeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAeConstant_expressionParserRuleCall_1_1_0 = (RuleCall)cAeAssignment_1_1.eContents().get(0);
		private final RuleCall cRIGHT_BRACKETTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cEQUALTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cEAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEInitializerParserRuleCall_2_1_0 = (RuleCall)cEAssignment_2_1.eContents().get(0);
		
		////returns [String name, Expr arrayInit, Expr init]
		//declaration_identifier_and_init:
		//	id= //{ $name = $id.text; }
		//	IDENTIFIER (LEFT_BRACKET ae=constant_expression / *{ $arrayInit = $ae.expr; }* / RIGHT_BRACKET)? (EQUAL e=initializer)?
		//	/ *{ $init = $e.expr; }* /;
		public ParserRule getRule() { return rule; }

		//id= //{ $name = $id.text; }
		//IDENTIFIER (LEFT_BRACKET ae=constant_expression / *{ $arrayInit = $ae.expr; }* / RIGHT_BRACKET)? (EQUAL e=initializer)?
		/// *{ $init = $e.expr; }* /
		public Group getGroup() { return cGroup; }

		//id= //{ $name = $id.text; }
		//IDENTIFIER
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }

		////{ $name = $id.text; }
		//IDENTIFIER
		public RuleCall getIdIDENTIFIERParserRuleCall_0_0() { return cIdIDENTIFIERParserRuleCall_0_0; }

		//(LEFT_BRACKET ae=constant_expression / *{ $arrayInit = $ae.expr; }* / RIGHT_BRACKET)?
		public Group getGroup_1() { return cGroup_1; }

		//LEFT_BRACKET
		public RuleCall getLEFT_BRACKETTerminalRuleCall_1_0() { return cLEFT_BRACKETTerminalRuleCall_1_0; }

		//ae=constant_expression
		public Assignment getAeAssignment_1_1() { return cAeAssignment_1_1; }

		//constant_expression
		public RuleCall getAeConstant_expressionParserRuleCall_1_1_0() { return cAeConstant_expressionParserRuleCall_1_1_0; }

		/// *{ $arrayInit = $ae.expr; }* / RIGHT_BRACKET
		public RuleCall getRIGHT_BRACKETTerminalRuleCall_1_2() { return cRIGHT_BRACKETTerminalRuleCall_1_2; }

		//(EQUAL e=initializer)?
		public Group getGroup_2() { return cGroup_2; }

		//EQUAL
		public RuleCall getEQUALTerminalRuleCall_2_0() { return cEQUALTerminalRuleCall_2_0; }

		//e=initializer
		public Assignment getEAssignment_2_1() { return cEAssignment_2_1; }

		//initializer
		public RuleCall getEInitializerParserRuleCall_2_1_0() { return cEInitializerParserRuleCall_2_1_0; }
	}

	public class Single_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "single_declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTFully_specified_typeParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDDeclaration_identifier_and_initParserRuleCall_1_0 = (RuleCall)cDAssignment_1.eContents().get(0);
		
		////returns [VarDecl decl]
		////          {
		////              int arraySize = -1;
		////              Expr ainit = $d.arrayInit;
		////              if (ainit != null) {
		////                  if (ainit instanceof LiteralExpr) {
		////                      Object val = ((LiteralExpr)ainit).getValue();
		////                      if (!(val instanceof Integer)) {
		////                          throw new RuntimeException("Array size must be an integer");
		////                      }
		////                      arraySize = ((Integer)val).intValue();
		////                  } else if (ainit instanceof VariableExpr) {
		////                      Variable var = ((VariableExpr)ainit).getVariable();
		////                      Object val = var.getConstValue();
		////                      if (!(val instanceof Integer) || var.getQualifier() != Qualifier.CONST) {
		////                          throw new RuntimeException("Array size must be a constant integer");
		////                      }
		////                      arraySize = ((Integer)val).intValue();
		////                  }
		////              }
		////
		////              Object constValue = null;
		////              if ($t.qual == Qualifier.CONST) {
		////                  Expr cinit = $d.init;
		////                  if (cinit == null) {
		////                      throw new RuntimeException("Constant value must be initialized");
		////                  }
		////                  // TODO: for now, allow some basic expressions on the rhs
		////                  // of the constant declaration...
		////                  //if (!(cinit instanceof LiteralExpr)) {
		////                  //    throw new RuntimeException("Constant initializer must be a literal (for now)");
		////                  //}
		////                  Type ctype = cinit.getResultType();
		////                  if (ctype != $t.type) {
		////                      throw new RuntimeException("Constant type must match that of initializer");
		////                  }
		////                  if (cinit instanceof LiteralExpr) {
		////                      constValue = ((LiteralExpr)cinit).getValue();
		////                  } else {
		////                      // TODO: This is gross, but to support complex constant
		////                      // initializers (such as "const FOO = BAR / 42.0;") we
		////                      // will just save the full text of the rhs and hope that
		////                      // the backend does the right thing with it.  The real
		////                      // solution obviously would be to evaluate the expression
		////                      // now and reduce it to a single value.
		////                      constValue = $d.init.toString();
		////                  }
		////              }
		////
		////              Variable var =
		////                  symbols.declareVariable($d.name,
		////                                          $t.type, $t.qual, $t.precision,
		////                                          arraySize, constValue);
		////              $decl = tm.varDecl(var, $d.init);
		////          }
		//single_declaration:
		//	t=fully_specified_type d=declaration_identifier_and_init;
		public ParserRule getRule() { return rule; }

		//t=fully_specified_type d=declaration_identifier_and_init
		public Group getGroup() { return cGroup; }

		//t=fully_specified_type
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//fully_specified_type
		public RuleCall getTFully_specified_typeParserRuleCall_0_0() { return cTFully_specified_typeParserRuleCall_0_0; }

		//d=declaration_identifier_and_init
		public Assignment getDAssignment_1() { return cDAssignment_1; }

		//declaration_identifier_and_init
		public RuleCall getDDeclaration_identifier_and_initParserRuleCall_1_0() { return cDDeclaration_identifier_and_initParserRuleCall_1_0; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSSingle_declarationParserRuleCall_0_0 = (RuleCall)cSAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cDAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cDDeclaration_identifier_and_initParserRuleCall_1_1_0 = (RuleCall)cDAssignment_1_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		////returns [List<VarDecl> declList = new ArrayList<VarDecl>()]
		//declaration:
		//	s= //{ $declList.add($s.decl); }
		//	single_declaration (COMMA d+=declaration_identifier_and_init)* //          {
		//	//              Variable base = $s.decl.getVariable();
		//	//              Variable var =
		//	//                  symbols.declareVariable($d.name,
		//	//                                          base.getType(),
		//	//                                          base.getQualifier(),
		//	//                                          base.getPrecision());
		//	//              $declList.add(tm.varDecl(var, $d.init));
		//	//          }
		//	SEMICOLON;
		public ParserRule getRule() { return rule; }

		//s= //{ $declList.add($s.decl); }
		//single_declaration (COMMA d+=declaration_identifier_and_init)* //          {
		////              Variable base = $s.decl.getVariable();
		////              Variable var =
		////                  symbols.declareVariable($d.name,
		////                                          base.getType(),
		////                                          base.getQualifier(),
		////                                          base.getPrecision());
		////              $declList.add(tm.varDecl(var, $d.init));
		////          }
		//SEMICOLON
		public Group getGroup() { return cGroup; }

		//s= //{ $declList.add($s.decl); }
		//single_declaration
		public Assignment getSAssignment_0() { return cSAssignment_0; }

		////{ $declList.add($s.decl); }
		//single_declaration
		public RuleCall getSSingle_declarationParserRuleCall_0_0() { return cSSingle_declarationParserRuleCall_0_0; }

		//(COMMA d+=declaration_identifier_and_init)*
		public Group getGroup_1() { return cGroup_1; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_0() { return cCOMMATerminalRuleCall_1_0; }

		//d+=declaration_identifier_and_init
		public Assignment getDAssignment_1_1() { return cDAssignment_1_1; }

		//declaration_identifier_and_init
		public RuleCall getDDeclaration_identifier_and_initParserRuleCall_1_1_0() { return cDDeclaration_identifier_and_initParserRuleCall_1_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2() { return cSEMICOLONTerminalRuleCall_2; }
	}

	public class Fully_specified_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fully_specified_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cTqAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cTqType_qualifierParserRuleCall_0_0_0 = (RuleCall)cTqAssignment_0_0.eContents().get(0);
		private final Assignment cTpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTpType_precisionParserRuleCall_0_1_0 = (RuleCall)cTpAssignment_0_1.eContents().get(0);
		private final Assignment cTsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cTsType_specifierParserRuleCall_0_2_0 = (RuleCall)cTsAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cTqAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cTqType_qualifierParserRuleCall_1_0_0 = (RuleCall)cTqAssignment_1_0.eContents().get(0);
		private final Assignment cTsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTsType_specifierParserRuleCall_1_1_0 = (RuleCall)cTsAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cTpAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cTpType_precisionParserRuleCall_2_0_0 = (RuleCall)cTpAssignment_2_0.eContents().get(0);
		private final Assignment cTsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTsType_specifierParserRuleCall_2_1_0 = (RuleCall)cTsAssignment_2_1.eContents().get(0);
		private final Assignment cTsAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cTsType_specifierParserRuleCall_3_0 = (RuleCall)cTsAssignment_3.eContents().get(0);
		
		//// From GLSL spec...
		//// Grammar Note:  No 'enum', or 'typedef'. 
		////returns [Qualifier qual, Precision precision, Type type]
		////            {
		////                $type = Type.fromToken($ts.text);
		////            }
		//fully_specified_type:
		//	tq=type_qualifier tp=type_precision ts=type_specifier //            {
		//	//                $qual = Qualifier.fromToken($tq.text);
		//	//                $precision = Precision.fromToken($tp.text);
		//	//                $type = Type.fromToken($ts.text);
		//	//            }
		//	//            {
		//	//                $qual = Qualifier.fromToken($tq.text);
		//	//                $type = Type.fromToken($ts.text);
		//	//            }
		//	//            {
		//	//                $precision = Precision.fromToken($tp.text);
		//	//                $type = Type.fromToken($ts.text);
		//	//            }
		//	| tq=type_qualifier ts=type_specifier | tp=type_precision ts=type_specifier | ts=type_specifier;
		public ParserRule getRule() { return rule; }

		//tq=type_qualifier tp=type_precision ts=type_specifier //            {
		////                $qual = Qualifier.fromToken($tq.text);
		////                $precision = Precision.fromToken($tp.text);
		////                $type = Type.fromToken($ts.text);
		////            }
		////            {
		////                $qual = Qualifier.fromToken($tq.text);
		////                $type = Type.fromToken($ts.text);
		////            }
		////            {
		////                $precision = Precision.fromToken($tp.text);
		////                $type = Type.fromToken($ts.text);
		////            }
		//| tq=type_qualifier ts=type_specifier | tp=type_precision ts=type_specifier | ts=type_specifier
		public Alternatives getAlternatives() { return cAlternatives; }

		//tq=type_qualifier tp=type_precision ts=type_specifier
		public Group getGroup_0() { return cGroup_0; }

		//tq=type_qualifier
		public Assignment getTqAssignment_0_0() { return cTqAssignment_0_0; }

		//type_qualifier
		public RuleCall getTqType_qualifierParserRuleCall_0_0_0() { return cTqType_qualifierParserRuleCall_0_0_0; }

		//tp=type_precision
		public Assignment getTpAssignment_0_1() { return cTpAssignment_0_1; }

		//type_precision
		public RuleCall getTpType_precisionParserRuleCall_0_1_0() { return cTpType_precisionParserRuleCall_0_1_0; }

		//ts=type_specifier
		public Assignment getTsAssignment_0_2() { return cTsAssignment_0_2; }

		//type_specifier
		public RuleCall getTsType_specifierParserRuleCall_0_2_0() { return cTsType_specifierParserRuleCall_0_2_0; }

		//tq=type_qualifier ts=type_specifier
		public Group getGroup_1() { return cGroup_1; }

		//tq=type_qualifier
		public Assignment getTqAssignment_1_0() { return cTqAssignment_1_0; }

		//type_qualifier
		public RuleCall getTqType_qualifierParserRuleCall_1_0_0() { return cTqType_qualifierParserRuleCall_1_0_0; }

		//ts=type_specifier
		public Assignment getTsAssignment_1_1() { return cTsAssignment_1_1; }

		//type_specifier
		public RuleCall getTsType_specifierParserRuleCall_1_1_0() { return cTsType_specifierParserRuleCall_1_1_0; }

		//tp=type_precision ts=type_specifier
		public Group getGroup_2() { return cGroup_2; }

		//tp=type_precision
		public Assignment getTpAssignment_2_0() { return cTpAssignment_2_0; }

		//type_precision
		public RuleCall getTpType_precisionParserRuleCall_2_0_0() { return cTpType_precisionParserRuleCall_2_0_0; }

		//ts=type_specifier
		public Assignment getTsAssignment_2_1() { return cTsAssignment_2_1; }

		//type_specifier
		public RuleCall getTsType_specifierParserRuleCall_2_1_0() { return cTsType_specifierParserRuleCall_2_1_0; }

		//ts=type_specifier
		public Assignment getTsAssignment_3() { return cTsAssignment_3; }

		//type_specifier
		public RuleCall getTsType_specifierParserRuleCall_3_0() { return cTsType_specifierParserRuleCall_3_0; }
	}

	public class Type_qualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "type_qualifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cParamKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//type_qualifier:
		//	"const" | "param";
		public ParserRule getRule() { return rule; }

		//"const" | "param"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"const"
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }

		//"param"
		public Keyword getParamKeyword_1() { return cParamKeyword_1; }
	}

	public class Type_precisionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "type_precision");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLowpKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMediumpKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cHighpKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//type_precision:
		//	"lowp" | "mediump" | "highp";
		public ParserRule getRule() { return rule; }

		//"lowp" | "mediump" | "highp"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"lowp"
		public Keyword getLowpKeyword_0() { return cLowpKeyword_0; }

		//"mediump"
		public Keyword getMediumpKeyword_1() { return cMediumpKeyword_1; }

		//"highp"
		public Keyword getHighpKeyword_2() { return cHighpKeyword_2; }
	}

	public class Type_specifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "type_specifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cType_specifierAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cType_specifier_nonarrayParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cArray_bracketsParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//type_specifier:
		//	{type_specifier} type_specifier_nonarray array_brackets?;
		public ParserRule getRule() { return rule; }

		//{type_specifier} type_specifier_nonarray array_brackets?
		public Group getGroup() { return cGroup; }

		//{type_specifier}
		public Action getType_specifierAction_0() { return cType_specifierAction_0; }

		//type_specifier_nonarray
		public RuleCall getType_specifier_nonarrayParserRuleCall_1() { return cType_specifier_nonarrayParserRuleCall_1; }

		//array_brackets?
		public RuleCall getArray_bracketsParserRuleCall_2() { return cArray_bracketsParserRuleCall_2; }
	}

	public class Array_bracketsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "array_brackets");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLEFT_BRACKETTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cConstant_expressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cRIGHT_BRACKETTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//array_brackets:
		//	LEFT_BRACKET constant_expression RIGHT_BRACKET;
		public ParserRule getRule() { return rule; }

		//LEFT_BRACKET constant_expression RIGHT_BRACKET
		public Group getGroup() { return cGroup; }

		//LEFT_BRACKET
		public RuleCall getLEFT_BRACKETTerminalRuleCall_0() { return cLEFT_BRACKETTerminalRuleCall_0; }

		//constant_expression
		public RuleCall getConstant_expressionParserRuleCall_1() { return cConstant_expressionParserRuleCall_1; }

		//RIGHT_BRACKET
		public RuleCall getRIGHT_BRACKETTerminalRuleCall_2() { return cRIGHT_BRACKETTerminalRuleCall_2; }
	}

	public class Type_specifier_nonarrayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "type_specifier_nonarray");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTYPEParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVOIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//type_specifier_nonarray:
		//	TYPE | VOID;
		public ParserRule getRule() { return rule; }

		//TYPE | VOID
		public Alternatives getAlternatives() { return cAlternatives; }

		//TYPE
		public RuleCall getTYPEParserRuleCall_0() { return cTYPEParserRuleCall_0; }

		//VOID
		public RuleCall getVOIDTerminalRuleCall_1() { return cVOIDTerminalRuleCall_1; }
	}

	public class InitializerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "initializer");
		private final Assignment cEAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cEAssignment_expressionParserRuleCall_0 = (RuleCall)cEAssignment.eContents().get(0);
		
		////returns [Expr expr]
		//initializer:
		//	e= //{ $expr = $e.expr; }
		//	assignment_expression;
		public ParserRule getRule() { return rule; }

		//e= //{ $expr = $e.expr; }
		//assignment_expression
		public Assignment getEAssignment() { return cEAssignment; }

		////{ $expr = $e.expr; }
		//assignment_expression
		public RuleCall getEAssignment_expressionParserRuleCall_0() { return cEAssignment_expressionParserRuleCall_0; }
	}

	public class Declaration_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "declaration_statement");
		private final Assignment cDAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDDeclarationParserRuleCall_0 = (RuleCall)cDAssignment.eContents().get(0);
		
		////returns [Stmt stmt]
		//declaration_statement:
		//	d= //{ $stmt = tm.declStmt($d.declList); }
		//	declaration;
		public ParserRule getRule() { return rule; }

		//d= //{ $stmt = tm.declStmt($d.declList); }
		//declaration
		public Assignment getDAssignment() { return cDAssignment; }

		////{ $stmt = tm.declStmt($d.declList); }
		//declaration
		public RuleCall getDDeclarationParserRuleCall_0() { return cDDeclarationParserRuleCall_0; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cCAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cCCompound_statementParserRuleCall_0_0 = (RuleCall)cCAssignment_0.eContents().get(0);
		private final Assignment cSAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cSSimple_statementParserRuleCall_1_0 = (RuleCall)cSAssignment_1.eContents().get(0);
		
		////returns [Stmt stmt]
		//statement:
		//	c= //{ $stmt = $c.stmt; }
		//	compound_statement | s= //{ $stmt = $s.stmt; }
		//	simple_statement;
		public ParserRule getRule() { return rule; }

		//c= //{ $stmt = $c.stmt; }
		//compound_statement | s= //{ $stmt = $s.stmt; }
		//simple_statement
		public Alternatives getAlternatives() { return cAlternatives; }

		//c= //{ $stmt = $c.stmt; }
		//compound_statement
		public Assignment getCAssignment_0() { return cCAssignment_0; }

		////{ $stmt = $c.stmt; }
		//compound_statement
		public RuleCall getCCompound_statementParserRuleCall_0_0() { return cCCompound_statementParserRuleCall_0_0; }

		//s= //{ $stmt = $s.stmt; }
		//simple_statement
		public Assignment getSAssignment_1() { return cSAssignment_1; }

		////{ $stmt = $s.stmt; }
		//simple_statement
		public RuleCall getSSimple_statementParserRuleCall_1_0() { return cSSimple_statementParserRuleCall_1_0; }
	}

	public class Simple_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "simple_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cDAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cDDeclaration_statementParserRuleCall_0_0 = (RuleCall)cDAssignment_0.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cEExpression_statementParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		private final Assignment cSAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cSSelection_statementParserRuleCall_2_0 = (RuleCall)cSAssignment_2.eContents().get(0);
		private final Assignment cIAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cIIteration_statementParserRuleCall_3_0 = (RuleCall)cIAssignment_3.eContents().get(0);
		private final Assignment cJAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cJJump_statementParserRuleCall_4_0 = (RuleCall)cJAssignment_4.eContents().get(0);
		
		//// From GLSL spec...
		//// Grammar Note:  No labeled statements; 'goto' is not supported. 
		////returns [Stmt stmt]
		//simple_statement:
		//	d= //{ $stmt = $d.stmt; }
		//	declaration_statement | e= //{ $stmt = $e.stmt; }
		//	expression_statement | s= //{ $stmt = $s.stmt; }
		//	selection_statement | i= //{ $stmt = $i.stmt; }
		//	iteration_statement | j= //{ $stmt = $j.stmt; }
		//	jump_statement;
		public ParserRule getRule() { return rule; }

		//d= //{ $stmt = $d.stmt; }
		//declaration_statement | e= //{ $stmt = $e.stmt; }
		//expression_statement | s= //{ $stmt = $s.stmt; }
		//selection_statement | i= //{ $stmt = $i.stmt; }
		//iteration_statement | j= //{ $stmt = $j.stmt; }
		//jump_statement
		public Alternatives getAlternatives() { return cAlternatives; }

		//d= //{ $stmt = $d.stmt; }
		//declaration_statement
		public Assignment getDAssignment_0() { return cDAssignment_0; }

		////{ $stmt = $d.stmt; }
		//declaration_statement
		public RuleCall getDDeclaration_statementParserRuleCall_0_0() { return cDDeclaration_statementParserRuleCall_0_0; }

		//e= //{ $stmt = $e.stmt; }
		//expression_statement
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		////{ $stmt = $e.stmt; }
		//expression_statement
		public RuleCall getEExpression_statementParserRuleCall_1_0() { return cEExpression_statementParserRuleCall_1_0; }

		//s= //{ $stmt = $s.stmt; }
		//selection_statement
		public Assignment getSAssignment_2() { return cSAssignment_2; }

		////{ $stmt = $s.stmt; }
		//selection_statement
		public RuleCall getSSelection_statementParserRuleCall_2_0() { return cSSelection_statementParserRuleCall_2_0; }

		//i= //{ $stmt = $i.stmt; }
		//iteration_statement
		public Assignment getIAssignment_3() { return cIAssignment_3; }

		////{ $stmt = $i.stmt; }
		//iteration_statement
		public RuleCall getIIteration_statementParserRuleCall_3_0() { return cIIteration_statementParserRuleCall_3_0; }

		//j= //{ $stmt = $j.stmt; }
		//jump_statement
		public Assignment getJAssignment_4() { return cJAssignment_4; }

		////{ $stmt = $j.stmt; }
		//jump_statement
		public RuleCall getJJump_statementParserRuleCall_4_0() { return cJJump_statementParserRuleCall_4_0; }
	}

	public class Compound_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "compound_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCompound_statementAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLEFT_BRACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cSAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSStatementParserRuleCall_2_0 = (RuleCall)cSAssignment_2.eContents().get(0);
		private final RuleCall cRIGHT_BRACETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		////returns [Stmt stmt]
		////@init {
		////    List<Stmt> stmtList = new ArrayList<Stmt>();
		////}
		////{ $stmt = tm.compoundStmt(stmtList); }
		//compound_statement:
		//	{compound_statement} LEFT_BRACE s+=statement* / *{ stmtList.add($s.stmt); }* / RIGHT_BRACE;
		public ParserRule getRule() { return rule; }

		//{compound_statement} LEFT_BRACE s+=statement* / *{ stmtList.add($s.stmt); }* / RIGHT_BRACE
		public Group getGroup() { return cGroup; }

		//{compound_statement}
		public Action getCompound_statementAction_0() { return cCompound_statementAction_0; }

		//LEFT_BRACE
		public RuleCall getLEFT_BRACETerminalRuleCall_1() { return cLEFT_BRACETerminalRuleCall_1; }

		//s+=statement*
		public Assignment getSAssignment_2() { return cSAssignment_2; }

		//statement
		public RuleCall getSStatementParserRuleCall_2_0() { return cSStatementParserRuleCall_2_0; }

		//RIGHT_BRACE
		public RuleCall getRIGHT_BRACETerminalRuleCall_3() { return cRIGHT_BRACETerminalRuleCall_3; }
	}

	public class Statement_no_new_scopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "statement_no_new_scope");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cCAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cCCompound_statement_no_new_scopeParserRuleCall_0_0 = (RuleCall)cCAssignment_0.eContents().get(0);
		private final Assignment cSAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cSSimple_statementParserRuleCall_1_0 = (RuleCall)cSAssignment_1.eContents().get(0);
		
		////returns [Stmt stmt]
		//statement_no_new_scope:
		//	c= //{ $stmt = $c.stmt; }
		//	compound_statement_no_new_scope | s= //{ $stmt = $s.stmt; }
		//	simple_statement;
		public ParserRule getRule() { return rule; }

		//c= //{ $stmt = $c.stmt; }
		//compound_statement_no_new_scope | s= //{ $stmt = $s.stmt; }
		//simple_statement
		public Alternatives getAlternatives() { return cAlternatives; }

		//c= //{ $stmt = $c.stmt; }
		//compound_statement_no_new_scope
		public Assignment getCAssignment_0() { return cCAssignment_0; }

		////{ $stmt = $c.stmt; }
		//compound_statement_no_new_scope
		public RuleCall getCCompound_statement_no_new_scopeParserRuleCall_0_0() { return cCCompound_statement_no_new_scopeParserRuleCall_0_0; }

		//s= //{ $stmt = $s.stmt; }
		//simple_statement
		public Assignment getSAssignment_1() { return cSAssignment_1; }

		////{ $stmt = $s.stmt; }
		//simple_statement
		public RuleCall getSSimple_statementParserRuleCall_1_0() { return cSSimple_statementParserRuleCall_1_0; }
	}

	public class Compound_statement_no_new_scopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "compound_statement_no_new_scope");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCompound_statement_no_new_scopeAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cLEFT_BRACETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cSAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSStatementParserRuleCall_2_0 = (RuleCall)cSAssignment_2.eContents().get(0);
		private final RuleCall cRIGHT_BRACETerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		////returns [Stmt stmt]
		////@init {
		////    List<Stmt> stmtList = new ArrayList<Stmt>();
		////}
		////{ $stmt = tm.compoundStmt(stmtList); }
		//compound_statement_no_new_scope:
		//	{compound_statement_no_new_scope} LEFT_BRACE s+=statement* / *{ stmtList.add($s.stmt); }* / RIGHT_BRACE;
		public ParserRule getRule() { return rule; }

		//{compound_statement_no_new_scope} LEFT_BRACE s+=statement* / *{ stmtList.add($s.stmt); }* / RIGHT_BRACE
		public Group getGroup() { return cGroup; }

		//{compound_statement_no_new_scope}
		public Action getCompound_statement_no_new_scopeAction_0() { return cCompound_statement_no_new_scopeAction_0; }

		//LEFT_BRACE
		public RuleCall getLEFT_BRACETerminalRuleCall_1() { return cLEFT_BRACETerminalRuleCall_1; }

		//s+=statement*
		public Assignment getSAssignment_2() { return cSAssignment_2; }

		//statement
		public RuleCall getSStatementParserRuleCall_2_0() { return cSStatementParserRuleCall_2_0; }

		//RIGHT_BRACE
		public RuleCall getRIGHT_BRACETerminalRuleCall_3() { return cRIGHT_BRACETerminalRuleCall_3; }
	}

	public class Expression_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "expression_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cExpression_statementAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cEAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cEExpressionParserRuleCall_1_0_0 = (RuleCall)cEAssignment_1_0.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		////returns [Stmt stmt]
		//expression_statement:
		//	{expression_statement} SEMICOLON //{ $stmt = tm.exprStmt(null); }
		//	//{ $stmt = tm.exprStmt($e.expr); }
		//	| e=expression SEMICOLON;
		public ParserRule getRule() { return rule; }

		//{expression_statement} SEMICOLON //{ $stmt = tm.exprStmt(null); }
		////{ $stmt = tm.exprStmt($e.expr); }
		//| e=expression SEMICOLON
		public Alternatives getAlternatives() { return cAlternatives; }

		//{expression_statement} SEMICOLON
		public Group getGroup_0() { return cGroup_0; }

		//{expression_statement}
		public Action getExpression_statementAction_0_0() { return cExpression_statementAction_0_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_0_1() { return cSEMICOLONTerminalRuleCall_0_1; }

		//e=expression SEMICOLON
		public Group getGroup_1() { return cGroup_1; }

		//e=expression
		public Assignment getEAssignment_1_0() { return cEAssignment_1_0; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0_0() { return cEExpressionParserRuleCall_1_0_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_1() { return cSEMICOLONTerminalRuleCall_1_1; }
	}

	public class Constant_expressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "constant_expression");
		private final Assignment cCAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCConditional_expressionParserRuleCall_0 = (RuleCall)cCAssignment.eContents().get(0);
		
		////returns [Expr expr]
		//constant_expression:
		//	c= //{ $expr = $c.expr; }
		//	conditional_expression;
		public ParserRule getRule() { return rule; }

		//c= //{ $expr = $c.expr; }
		//conditional_expression
		public Assignment getCAssignment() { return cCAssignment; }

		////{ $expr = $c.expr; }
		//conditional_expression
		public RuleCall getCConditional_expressionParserRuleCall_0() { return cCConditional_expressionParserRuleCall_0; }
	}

	public class Selection_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "selection_statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIFTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cLEFT_PARENTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cEAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEExpressionParserRuleCall_2_0 = (RuleCall)cEAssignment_2.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cAAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAStatementParserRuleCall_4_0 = (RuleCall)cAAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final RuleCall cELSETerminalRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Assignment cBAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cBStatementParserRuleCall_5_1_0 = (RuleCall)cBAssignment_5_1.eContents().get(0);
		
		////returns [Stmt stmt]
		////{ $stmt = tm.selectStmt($e.expr, $a.stmt, (b != null) ? $b.stmt : null); }
		//selection_statement:
		//	IF LEFT_PAREN e=expression RIGHT_PAREN a=statement (ELSE b=statement)?;
		public ParserRule getRule() { return rule; }

		//IF LEFT_PAREN e=expression RIGHT_PAREN a=statement (ELSE b=statement)?
		public Group getGroup() { return cGroup; }

		//IF
		public RuleCall getIFTerminalRuleCall_0() { return cIFTerminalRuleCall_0; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_1() { return cLEFT_PARENTerminalRuleCall_1; }

		//e=expression
		public Assignment getEAssignment_2() { return cEAssignment_2; }

		//expression
		public RuleCall getEExpressionParserRuleCall_2_0() { return cEExpressionParserRuleCall_2_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_3() { return cRIGHT_PARENTerminalRuleCall_3; }

		//a=statement
		public Assignment getAAssignment_4() { return cAAssignment_4; }

		//statement
		public RuleCall getAStatementParserRuleCall_4_0() { return cAStatementParserRuleCall_4_0; }

		//(ELSE b=statement)?
		public Group getGroup_5() { return cGroup_5; }

		//ELSE
		public RuleCall getELSETerminalRuleCall_5_0() { return cELSETerminalRuleCall_5_0; }

		//b=statement
		public Assignment getBAssignment_5_1() { return cBAssignment_5_1; }

		//statement
		public RuleCall getBStatementParserRuleCall_5_1_0() { return cBStatementParserRuleCall_5_1_0; }
	}

	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "condition");
		private final Assignment cEAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_0 = (RuleCall)cEAssignment.eContents().get(0);
		
		//// TODO: implement second half?
		////returns [Expr expr]
		////        | fully_specified_type IDENTIFIER EQUAL initializer
		//condition:
		//	e= //{$expr = $e.expr; }
		//	expression;
		public ParserRule getRule() { return rule; }

		//e= //{$expr = $e.expr; }
		//expression
		public Assignment getEAssignment() { return cEAssignment; }

		////{$expr = $e.expr; }
		//expression
		public RuleCall getEExpressionParserRuleCall_0() { return cEExpressionParserRuleCall_0; }
	}

	public class Iteration_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "iteration_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cWHILETerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cLEFT_PARENTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cCAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cCConditionParserRuleCall_0_2_0 = (RuleCall)cCAssignment_0_2.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final Assignment cSnnsAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cSnnsStatement_no_new_scopeParserRuleCall_0_4_0 = (RuleCall)cSnnsAssignment_0_4.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cDOTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cSAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSStatementParserRuleCall_1_1_0 = (RuleCall)cSAssignment_1_1.eContents().get(0);
		private final RuleCall cWHILETerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cLEFT_PARENTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Assignment cEAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cEExpressionParserRuleCall_1_4_0 = (RuleCall)cEAssignment_1_4.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_1_5 = (RuleCall)cGroup_1.eContents().get(5);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_6 = (RuleCall)cGroup_1.eContents().get(6);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cUAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cUUnroll_modifierParserRuleCall_2_0_0 = (RuleCall)cUAssignment_2_0.eContents().get(0);
		private final RuleCall cFORTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cLEFT_PARENTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Assignment cInitAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cInitFor_init_statementParserRuleCall_2_3_0 = (RuleCall)cInitAssignment_2_3.eContents().get(0);
		private final Assignment cRemAssignment_2_4 = (Assignment)cGroup_2.eContents().get(4);
		private final RuleCall cRemFor_rest_statementParserRuleCall_2_4_0 = (RuleCall)cRemAssignment_2_4.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_2_5 = (RuleCall)cGroup_2.eContents().get(5);
		private final Assignment cSnnsAssignment_2_6 = (Assignment)cGroup_2.eContents().get(6);
		private final RuleCall cSnnsStatement_no_new_scopeParserRuleCall_2_6_0 = (RuleCall)cSnnsAssignment_2_6.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cFORTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cLEFT_PARENTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Assignment cInitAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cInitFor_init_statementParserRuleCall_3_2_0 = (RuleCall)cInitAssignment_3_2.eContents().get(0);
		private final Assignment cRemAssignment_3_3 = (Assignment)cGroup_3.eContents().get(3);
		private final RuleCall cRemFor_rest_statementParserRuleCall_3_3_0 = (RuleCall)cRemAssignment_3_3.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_3_4 = (RuleCall)cGroup_3.eContents().get(4);
		private final Assignment cSnnsAssignment_3_5 = (Assignment)cGroup_3.eContents().get(5);
		private final RuleCall cSnnsStatement_no_new_scopeParserRuleCall_3_5_0 = (RuleCall)cSnnsAssignment_3_5.eContents().get(0);
		
		////returns [Stmt stmt]
		////{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, -1, -1); }
		//iteration_statement:
		//	WHILE LEFT_PAREN c=condition RIGHT_PAREN snns=statement_no_new_scope //{ $stmt = tm.whileStmt($c.expr, $snns.stmt); }
		//	//{ $stmt = tm.doWhileStmt($s.stmt, $e.expr); }
		//	//{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, $u.max, $u.check); }
		//	| DO s=statement WHILE LEFT_PAREN e=expression RIGHT_PAREN SEMICOLON | u=unroll_modifier FOR LEFT_PAREN
		//	init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope | FOR LEFT_PAREN
		//	init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope;
		public ParserRule getRule() { return rule; }

		//WHILE LEFT_PAREN c=condition RIGHT_PAREN snns=statement_no_new_scope //{ $stmt = tm.whileStmt($c.expr, $snns.stmt); }
		////{ $stmt = tm.doWhileStmt($s.stmt, $e.expr); }
		////{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, $u.max, $u.check); }
		//| DO s=statement WHILE LEFT_PAREN e=expression RIGHT_PAREN SEMICOLON | u=unroll_modifier FOR LEFT_PAREN
		//init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope | FOR LEFT_PAREN
		//init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope
		public Alternatives getAlternatives() { return cAlternatives; }

		//WHILE LEFT_PAREN c=condition RIGHT_PAREN snns=statement_no_new_scope
		public Group getGroup_0() { return cGroup_0; }

		//WHILE
		public RuleCall getWHILETerminalRuleCall_0_0() { return cWHILETerminalRuleCall_0_0; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_0_1() { return cLEFT_PARENTerminalRuleCall_0_1; }

		//c=condition
		public Assignment getCAssignment_0_2() { return cCAssignment_0_2; }

		//condition
		public RuleCall getCConditionParserRuleCall_0_2_0() { return cCConditionParserRuleCall_0_2_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_0_3() { return cRIGHT_PARENTerminalRuleCall_0_3; }

		//snns=statement_no_new_scope
		public Assignment getSnnsAssignment_0_4() { return cSnnsAssignment_0_4; }

		//statement_no_new_scope
		public RuleCall getSnnsStatement_no_new_scopeParserRuleCall_0_4_0() { return cSnnsStatement_no_new_scopeParserRuleCall_0_4_0; }

		//DO s=statement WHILE LEFT_PAREN e=expression RIGHT_PAREN SEMICOLON
		public Group getGroup_1() { return cGroup_1; }

		//DO
		public RuleCall getDOTerminalRuleCall_1_0() { return cDOTerminalRuleCall_1_0; }

		//s=statement
		public Assignment getSAssignment_1_1() { return cSAssignment_1_1; }

		//statement
		public RuleCall getSStatementParserRuleCall_1_1_0() { return cSStatementParserRuleCall_1_1_0; }

		//WHILE
		public RuleCall getWHILETerminalRuleCall_1_2() { return cWHILETerminalRuleCall_1_2; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_1_3() { return cLEFT_PARENTerminalRuleCall_1_3; }

		//e=expression
		public Assignment getEAssignment_1_4() { return cEAssignment_1_4; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_4_0() { return cEExpressionParserRuleCall_1_4_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_1_5() { return cRIGHT_PARENTerminalRuleCall_1_5; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_6() { return cSEMICOLONTerminalRuleCall_1_6; }

		//u=unroll_modifier FOR LEFT_PAREN init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope
		public Group getGroup_2() { return cGroup_2; }

		//u=unroll_modifier
		public Assignment getUAssignment_2_0() { return cUAssignment_2_0; }

		//unroll_modifier
		public RuleCall getUUnroll_modifierParserRuleCall_2_0_0() { return cUUnroll_modifierParserRuleCall_2_0_0; }

		//FOR
		public RuleCall getFORTerminalRuleCall_2_1() { return cFORTerminalRuleCall_2_1; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_2_2() { return cLEFT_PARENTerminalRuleCall_2_2; }

		//init=for_init_statement
		public Assignment getInitAssignment_2_3() { return cInitAssignment_2_3; }

		//for_init_statement
		public RuleCall getInitFor_init_statementParserRuleCall_2_3_0() { return cInitFor_init_statementParserRuleCall_2_3_0; }

		//rem=for_rest_statement
		public Assignment getRemAssignment_2_4() { return cRemAssignment_2_4; }

		//for_rest_statement
		public RuleCall getRemFor_rest_statementParserRuleCall_2_4_0() { return cRemFor_rest_statementParserRuleCall_2_4_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_2_5() { return cRIGHT_PARENTerminalRuleCall_2_5; }

		//snns=statement_no_new_scope
		public Assignment getSnnsAssignment_2_6() { return cSnnsAssignment_2_6; }

		//statement_no_new_scope
		public RuleCall getSnnsStatement_no_new_scopeParserRuleCall_2_6_0() { return cSnnsStatement_no_new_scopeParserRuleCall_2_6_0; }

		//FOR LEFT_PAREN init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope
		public Group getGroup_3() { return cGroup_3; }

		//FOR
		public RuleCall getFORTerminalRuleCall_3_0() { return cFORTerminalRuleCall_3_0; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_3_1() { return cLEFT_PARENTerminalRuleCall_3_1; }

		//init=for_init_statement
		public Assignment getInitAssignment_3_2() { return cInitAssignment_3_2; }

		//for_init_statement
		public RuleCall getInitFor_init_statementParserRuleCall_3_2_0() { return cInitFor_init_statementParserRuleCall_3_2_0; }

		//rem=for_rest_statement
		public Assignment getRemAssignment_3_3() { return cRemAssignment_3_3; }

		//for_rest_statement
		public RuleCall getRemFor_rest_statementParserRuleCall_3_3_0() { return cRemFor_rest_statementParserRuleCall_3_3_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_3_4() { return cRIGHT_PARENTerminalRuleCall_3_4; }

		//snns=statement_no_new_scope
		public Assignment getSnnsAssignment_3_5() { return cSnnsAssignment_3_5; }

		//statement_no_new_scope
		public RuleCall getSnnsStatement_no_new_scopeParserRuleCall_3_5_0() { return cSnnsStatement_no_new_scopeParserRuleCall_3_5_0; }
	}

	public class Unroll_modifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unroll_modifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUNROLLTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cLEFT_PARENTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cMAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMINTCONSTANTTerminalRuleCall_2_0 = (RuleCall)cMAssignment_2.eContents().get(0);
		private final RuleCall cCOMMATerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cCAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCINTCONSTANTTerminalRuleCall_4_0 = (RuleCall)cCAssignment_4.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		////returns [int max, int check]
		////{ $max = Integer.valueOf($m.text); $check = Integer.valueOf($c.text); }
		//unroll_modifier:
		//	UNROLL LEFT_PAREN m=INTCONSTANT COMMA c=INTCONSTANT RIGHT_PAREN;
		public ParserRule getRule() { return rule; }

		//UNROLL LEFT_PAREN m=INTCONSTANT COMMA c=INTCONSTANT RIGHT_PAREN
		public Group getGroup() { return cGroup; }

		//UNROLL
		public RuleCall getUNROLLTerminalRuleCall_0() { return cUNROLLTerminalRuleCall_0; }

		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_1() { return cLEFT_PARENTerminalRuleCall_1; }

		//m=INTCONSTANT
		public Assignment getMAssignment_2() { return cMAssignment_2; }

		//INTCONSTANT
		public RuleCall getMINTCONSTANTTerminalRuleCall_2_0() { return cMINTCONSTANTTerminalRuleCall_2_0; }

		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3() { return cCOMMATerminalRuleCall_3; }

		//c=INTCONSTANT
		public Assignment getCAssignment_4() { return cCAssignment_4; }

		//INTCONSTANT
		public RuleCall getCINTCONSTANTTerminalRuleCall_4_0() { return cCINTCONSTANTTerminalRuleCall_4_0; }

		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_5() { return cRIGHT_PARENTerminalRuleCall_5; }
	}

	public class For_init_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "for_init_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cEAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cEExpression_statementParserRuleCall_0_0 = (RuleCall)cEAssignment_0.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDDeclaration_statementParserRuleCall_1_0 = (RuleCall)cDAssignment_1.eContents().get(0);
		
		////returns [Stmt stmt]
		//for_init_statement:
		//	e= //{ $stmt = $e.stmt; }
		//	expression_statement | d= //{ $stmt = $d.stmt; }
		//	declaration_statement;
		public ParserRule getRule() { return rule; }

		//e= //{ $stmt = $e.stmt; }
		//expression_statement | d= //{ $stmt = $d.stmt; }
		//declaration_statement
		public Alternatives getAlternatives() { return cAlternatives; }

		//e= //{ $stmt = $e.stmt; }
		//expression_statement
		public Assignment getEAssignment_0() { return cEAssignment_0; }

		////{ $stmt = $e.stmt; }
		//expression_statement
		public RuleCall getEExpression_statementParserRuleCall_0_0() { return cEExpression_statementParserRuleCall_0_0; }

		//d= //{ $stmt = $d.stmt; }
		//declaration_statement
		public Assignment getDAssignment_1() { return cDAssignment_1; }

		////{ $stmt = $d.stmt; }
		//declaration_statement
		public RuleCall getDDeclaration_statementParserRuleCall_1_0() { return cDDeclaration_statementParserRuleCall_1_0; }
	}

	public class For_rest_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "for_rest_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cFor_rest_statementAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cCAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cCConditionParserRuleCall_0_1_0 = (RuleCall)cCAssignment_0_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Assignment cEAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cEExpressionParserRuleCall_0_3_0 = (RuleCall)cEAssignment_0_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cFor_rest_statementAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cEAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cEExpressionParserRuleCall_1_2_0 = (RuleCall)cEAssignment_1_2.eContents().get(0);
		
		////returns [Expr cond, Expr expr]
		//for_rest_statement:
		//	{for_rest_statement} c=condition SEMICOLON e=expression? //{ $cond = $c.expr; if (e != null) $expr = $e.expr; }
		//	//{ if (e != null) $expr = $e.expr; }
		//	| {for_rest_statement} SEMICOLON e=expression?;
		public ParserRule getRule() { return rule; }

		//{for_rest_statement} c=condition SEMICOLON e=expression? //{ $cond = $c.expr; if (e != null) $expr = $e.expr; }
		////{ if (e != null) $expr = $e.expr; }
		//| {for_rest_statement} SEMICOLON e=expression?
		public Alternatives getAlternatives() { return cAlternatives; }

		//{for_rest_statement} c=condition SEMICOLON e=expression?
		public Group getGroup_0() { return cGroup_0; }

		//{for_rest_statement}
		public Action getFor_rest_statementAction_0_0() { return cFor_rest_statementAction_0_0; }

		//c=condition
		public Assignment getCAssignment_0_1() { return cCAssignment_0_1; }

		//condition
		public RuleCall getCConditionParserRuleCall_0_1_0() { return cCConditionParserRuleCall_0_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_0_2() { return cSEMICOLONTerminalRuleCall_0_2; }

		//e=expression?
		public Assignment getEAssignment_0_3() { return cEAssignment_0_3; }

		//expression
		public RuleCall getEExpressionParserRuleCall_0_3_0() { return cEExpressionParserRuleCall_0_3_0; }

		//{for_rest_statement} SEMICOLON e=expression?
		public Group getGroup_1() { return cGroup_1; }

		//{for_rest_statement}
		public Action getFor_rest_statementAction_1_0() { return cFor_rest_statementAction_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_1() { return cSEMICOLONTerminalRuleCall_1_1; }

		//e=expression?
		public Assignment getEAssignment_1_2() { return cEAssignment_1_2; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_2_0() { return cEExpressionParserRuleCall_1_2_0; }
	}

	public class Jump_statementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "jump_statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cJump_statementAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cCONTINUETerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cSEMICOLONTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cJump_statementAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cBREAKTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cJump_statementAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final RuleCall cDISCARDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cJump_statementAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final RuleCall cRETURNTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final RuleCall cSEMICOLONTerminalRuleCall_3_2 = (RuleCall)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cRETURNTerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cEAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_4_1_0 = (RuleCall)cEAssignment_4_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_4_2 = (RuleCall)cGroup_4.eContents().get(2);
		
		////returns [Stmt stmt]
		//jump_statement:
		//	{jump_statement} CONTINUE //{ $stmt = tm.continueStmt(); }
		//	SEMICOLON //{ $stmt = tm.returnStmt($e.expr); }
		//	| {jump_statement} BREAK //{ $stmt = tm.breakStmt(); }
		//	SEMICOLON | {jump_statement} DISCARD //{ $stmt = tm.discardStmt(); }
		//	SEMICOLON | {jump_statement} RETURN //{ $stmt = tm.returnStmt(null); }
		//	SEMICOLON | RETURN e=expression SEMICOLON;
		public ParserRule getRule() { return rule; }

		//{jump_statement} CONTINUE //{ $stmt = tm.continueStmt(); }
		//SEMICOLON //{ $stmt = tm.returnStmt($e.expr); }
		//| {jump_statement} BREAK //{ $stmt = tm.breakStmt(); }
		//SEMICOLON | {jump_statement} DISCARD //{ $stmt = tm.discardStmt(); }
		//SEMICOLON | {jump_statement} RETURN //{ $stmt = tm.returnStmt(null); }
		//SEMICOLON | RETURN e=expression SEMICOLON
		public Alternatives getAlternatives() { return cAlternatives; }

		//{jump_statement} CONTINUE //{ $stmt = tm.continueStmt(); }
		//SEMICOLON
		public Group getGroup_0() { return cGroup_0; }

		//{jump_statement}
		public Action getJump_statementAction_0_0() { return cJump_statementAction_0_0; }

		//CONTINUE
		public RuleCall getCONTINUETerminalRuleCall_0_1() { return cCONTINUETerminalRuleCall_0_1; }

		////{ $stmt = tm.continueStmt(); }
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_0_2() { return cSEMICOLONTerminalRuleCall_0_2; }

		//{jump_statement} BREAK //{ $stmt = tm.breakStmt(); }
		//SEMICOLON
		public Group getGroup_1() { return cGroup_1; }

		//{jump_statement}
		public Action getJump_statementAction_1_0() { return cJump_statementAction_1_0; }

		//BREAK
		public RuleCall getBREAKTerminalRuleCall_1_1() { return cBREAKTerminalRuleCall_1_1; }

		////{ $stmt = tm.breakStmt(); }
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_2() { return cSEMICOLONTerminalRuleCall_1_2; }

		//{jump_statement} DISCARD //{ $stmt = tm.discardStmt(); }
		//SEMICOLON
		public Group getGroup_2() { return cGroup_2; }

		//{jump_statement}
		public Action getJump_statementAction_2_0() { return cJump_statementAction_2_0; }

		//DISCARD
		public RuleCall getDISCARDTerminalRuleCall_2_1() { return cDISCARDTerminalRuleCall_2_1; }

		////{ $stmt = tm.discardStmt(); }
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_2() { return cSEMICOLONTerminalRuleCall_2_2; }

		//{jump_statement} RETURN //{ $stmt = tm.returnStmt(null); }
		//SEMICOLON
		public Group getGroup_3() { return cGroup_3; }

		//{jump_statement}
		public Action getJump_statementAction_3_0() { return cJump_statementAction_3_0; }

		//RETURN
		public RuleCall getRETURNTerminalRuleCall_3_1() { return cRETURNTerminalRuleCall_3_1; }

		////{ $stmt = tm.returnStmt(null); }
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_3_2() { return cSEMICOLONTerminalRuleCall_3_2; }

		//RETURN e=expression SEMICOLON
		public Group getGroup_4() { return cGroup_4; }

		//RETURN
		public RuleCall getRETURNTerminalRuleCall_4_0() { return cRETURNTerminalRuleCall_4_0; }

		//e=expression
		public Assignment getEAssignment_4_1() { return cEAssignment_4_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_4_1_0() { return cEExpressionParserRuleCall_4_1_0; }

		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_4_2() { return cSEMICOLONTerminalRuleCall_4_2; }
	}

	public class Translation_unitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "translation_unit");
		private final Assignment cEAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cEExternal_declarationParserRuleCall_0 = (RuleCall)cEAssignment.eContents().get(0);
		
		//// From GLSL spec...
		//// Grammar Note:  No 'goto'.  Gotos are not supported. 
		////returns [ProgramUnit prog]
		////@init {
		////    List<ExtDecl> declList = new ArrayList<ExtDecl>();
		////}
		/// *{ declList.addAll($e.res); }* / //{ $prog = tm.programUnit(declList); }
		//translation_unit:
		//	e+=external_declaration+;
		public ParserRule getRule() { return rule; }

		//e+=external_declaration+
		public Assignment getEAssignment() { return cEAssignment; }

		//external_declaration
		public RuleCall getEExternal_declarationParserRuleCall_0() { return cEExternal_declarationParserRuleCall_0; }
	}

	public class External_declarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "external_declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFFunction_definitionParserRuleCall_0_0 = (RuleCall)cFAssignment_0.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cDDeclarationParserRuleCall_1_0 = (RuleCall)cDAssignment_1.eContents().get(0);
		private final Assignment cGAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cGGlue_blockParserRuleCall_2_0 = (RuleCall)cGAssignment_2.eContents().get(0);
		
		////returns [List<ExtDecl> res = new ArrayList<ExtDecl>()]
		//external_declaration:
		//	f= //{ $res.add($f.def); }
		//	function_definition | d= //{ $res.addAll($d.declList); }
		//	declaration | g= //{ $res.add($g.block); }
		//	glue_block;
		public ParserRule getRule() { return rule; }

		//f= //{ $res.add($f.def); }
		//function_definition | d= //{ $res.addAll($d.declList); }
		//declaration | g= //{ $res.add($g.block); }
		//glue_block
		public Alternatives getAlternatives() { return cAlternatives; }

		//f= //{ $res.add($f.def); }
		//function_definition
		public Assignment getFAssignment_0() { return cFAssignment_0; }

		////{ $res.add($f.def); }
		//function_definition
		public RuleCall getFFunction_definitionParserRuleCall_0_0() { return cFFunction_definitionParserRuleCall_0_0; }

		//d= //{ $res.addAll($d.declList); }
		//declaration
		public Assignment getDAssignment_1() { return cDAssignment_1; }

		////{ $res.addAll($d.declList); }
		//declaration
		public RuleCall getDDeclarationParserRuleCall_1_0() { return cDDeclarationParserRuleCall_1_0; }

		//g= //{ $res.add($g.block); }
		//glue_block
		public Assignment getGAssignment_2() { return cGAssignment_2; }

		////{ $res.add($g.block); }
		//glue_block
		public RuleCall getGGlue_blockParserRuleCall_2_0() { return cGGlue_blockParserRuleCall_2_0; }
	}

	public class Function_definitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "function_definition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPFunction_prototypeParserRuleCall_0_0 = (RuleCall)cPAssignment_0.eContents().get(0);
		private final Assignment cSAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSCompound_statement_no_new_scopeParserRuleCall_1_0 = (RuleCall)cSAssignment_1.eContents().get(0);
		
		//// From GLSL spec...
		//// Grammar Note:  No 'switch'.  Switch statements not supported. 
		////returns [FuncDef def]
		////@init {
		////	symbols.enterFrame();
		////}
		//function_definition:
		//	p=function_prototype s= //{ $def = tm.funcDef($p.func, $s.stmt); }
		//	compound_statement_no_new_scope;
		public ParserRule getRule() { return rule; }

		//p=function_prototype s= //{ $def = tm.funcDef($p.func, $s.stmt); }
		//compound_statement_no_new_scope
		public Group getGroup() { return cGroup; }

		//p=function_prototype
		public Assignment getPAssignment_0() { return cPAssignment_0; }

		//function_prototype
		public RuleCall getPFunction_prototypeParserRuleCall_0_0() { return cPFunction_prototypeParserRuleCall_0_0; }

		//s= //{ $def = tm.funcDef($p.func, $s.stmt); }
		//compound_statement_no_new_scope
		public Assignment getSAssignment_1() { return cSAssignment_1; }

		////{ $def = tm.funcDef($p.func, $s.stmt); }
		//compound_statement_no_new_scope
		public RuleCall getSCompound_statement_no_new_scopeParserRuleCall_1_0() { return cSCompound_statement_no_new_scopeParserRuleCall_1_0; }
	}

	public class Glue_blockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glue_block");
		private final Assignment cGAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cGT_GLUE_BLOCKTerminalRuleCall_0 = (RuleCall)cGAssignment.eContents().get(0);
		
		////finally {
		////        symbols.exitFrame();
		////}
		////returns [GlueBlock block]
		//glue_block:
		//	g= //{ $block = tm.glueBlock($g.text.substring(2, $g.text.length()-2)); }
		//	T_GLUE_BLOCK;
		public ParserRule getRule() { return rule; }

		//g= //{ $block = tm.glueBlock($g.text.substring(2, $g.text.length()-2)); }
		//T_GLUE_BLOCK
		public Assignment getGAssignment() { return cGAssignment; }

		////{ $block = tm.glueBlock($g.text.substring(2, $g.text.length()-2)); }
		//T_GLUE_BLOCK
		public RuleCall getGT_GLUE_BLOCKTerminalRuleCall_0() { return cGT_GLUE_BLOCKTerminalRuleCall_0; }
	}

	public class TYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFloat2Keyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFloat3Keyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFloat4Keyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cFloatKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cInt2Keyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cInt3Keyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cInt4Keyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cIntKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cBool2Keyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cBool3Keyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cBool4Keyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cBoolKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cSamplerKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cLsamplerKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cFsamplerKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		
		//TYPE:
		//	"float2" | "float3" | "float4" | "float" | "int2" | "int3" | "int4" | "int" | "bool2" | "bool3" | "bool4" | "bool" |
		//	"sampler" | "lsampler" | "fsampler";
		public ParserRule getRule() { return rule; }

		//"float2" | "float3" | "float4" | "float" | "int2" | "int3" | "int4" | "int" | "bool2" | "bool3" | "bool4" | "bool" |
		//"sampler" | "lsampler" | "fsampler"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"float2"
		public Keyword getFloat2Keyword_0() { return cFloat2Keyword_0; }

		//"float3"
		public Keyword getFloat3Keyword_1() { return cFloat3Keyword_1; }

		//"float4"
		public Keyword getFloat4Keyword_2() { return cFloat4Keyword_2; }

		//"float"
		public Keyword getFloatKeyword_3() { return cFloatKeyword_3; }

		//"int2"
		public Keyword getInt2Keyword_4() { return cInt2Keyword_4; }

		//"int3"
		public Keyword getInt3Keyword_5() { return cInt3Keyword_5; }

		//"int4"
		public Keyword getInt4Keyword_6() { return cInt4Keyword_6; }

		//"int"
		public Keyword getIntKeyword_7() { return cIntKeyword_7; }

		//"bool2"
		public Keyword getBool2Keyword_8() { return cBool2Keyword_8; }

		//"bool3"
		public Keyword getBool3Keyword_9() { return cBool3Keyword_9; }

		//"bool4"
		public Keyword getBool4Keyword_10() { return cBool4Keyword_10; }

		//"bool"
		public Keyword getBoolKeyword_11() { return cBoolKeyword_11; }

		//"sampler"
		public Keyword getSamplerKeyword_12() { return cSamplerKeyword_12; }

		//"lsampler"
		public Keyword getLsamplerKeyword_13() { return cLsamplerKeyword_13; }

		//"fsampler"
		public Keyword getFsamplerKeyword_14() { return cFsamplerKeyword_14; }
	}

	public class BOOLCONSTANTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLCONSTANT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BOOLCONSTANT:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class RGBA_FIELDSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RGBA_FIELDS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cRFIELDTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final RuleCall cRFIELDTerminalRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final RuleCall cRFIELDTerminalRuleCall_0_4 = (RuleCall)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cDOTTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cRFIELDTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final RuleCall cRFIELDTerminalRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cDOTTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cRFIELDTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cDOTTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final RuleCall cRFIELDTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		
		//RGBA_FIELDS:
		//	DOT RFIELD RFIELD RFIELD RFIELD | DOT RFIELD RFIELD RFIELD | DOT RFIELD RFIELD | DOT RFIELD;
		public ParserRule getRule() { return rule; }

		//DOT RFIELD RFIELD RFIELD RFIELD | DOT RFIELD RFIELD RFIELD | DOT RFIELD RFIELD | DOT RFIELD
		public Alternatives getAlternatives() { return cAlternatives; }

		//DOT RFIELD RFIELD RFIELD RFIELD
		public Group getGroup_0() { return cGroup_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_0_0() { return cDOTTerminalRuleCall_0_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_1() { return cRFIELDTerminalRuleCall_0_1; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_2() { return cRFIELDTerminalRuleCall_0_2; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_3() { return cRFIELDTerminalRuleCall_0_3; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_0_4() { return cRFIELDTerminalRuleCall_0_4; }

		//DOT RFIELD RFIELD RFIELD
		public Group getGroup_1() { return cGroup_1; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_1_0() { return cDOTTerminalRuleCall_1_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_1_1() { return cRFIELDTerminalRuleCall_1_1; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_1_2() { return cRFIELDTerminalRuleCall_1_2; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_1_3() { return cRFIELDTerminalRuleCall_1_3; }

		//DOT RFIELD RFIELD
		public Group getGroup_2() { return cGroup_2; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_2_0() { return cDOTTerminalRuleCall_2_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_2_1() { return cRFIELDTerminalRuleCall_2_1; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_2_2() { return cRFIELDTerminalRuleCall_2_2; }

		//DOT RFIELD
		public Group getGroup_3() { return cGroup_3; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_3_0() { return cDOTTerminalRuleCall_3_0; }

		//RFIELD
		public RuleCall getRFIELDTerminalRuleCall_3_1() { return cRFIELDTerminalRuleCall_3_1; }
	}

	public class IDENTIFIERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IDENTIFIER");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLETTERTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cLETTERTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cDIGITTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//IDENTIFIER:
		//	LETTER (LETTER | DIGIT)*;
		public ParserRule getRule() { return rule; }

		//LETTER (LETTER | DIGIT)*
		public Group getGroup() { return cGroup; }

		//LETTER
		public RuleCall getLETTERTerminalRuleCall_0() { return cLETTERTerminalRuleCall_0; }

		//(LETTER | DIGIT)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//LETTER
		public RuleCall getLETTERTerminalRuleCall_1_0() { return cLETTERTerminalRuleCall_1_0; }

		//DIGIT
		public RuleCall getDIGITTerminalRuleCall_1_1() { return cDIGITTerminalRuleCall_1_1; }
	}
	
	
	private ModelElements pModel;
	private Field_selectionElements pField_selection;
	private Primary_expressionElements pPrimary_expression;
	private Primary_or_callElements pPrimary_or_call;
	private Postfix_expressionElements pPostfix_expression;
	private Function_callElements pFunction_call;
	private Function_call_parameter_listElements pFunction_call_parameter_list;
	private Unary_expressionElements pUnary_expression;
	private Multiplicative_expressionElements pMultiplicative_expression;
	private Additive_expressionElements pAdditive_expression;
	private Relational_expressionElements pRelational_expression;
	private Equality_expressionElements pEquality_expression;
	private Logical_and_expressionElements pLogical_and_expression;
	private Logical_xor_expressionElements pLogical_xor_expression;
	private Logical_or_expressionElements pLogical_or_expression;
	private Ternary_partElements pTernary_part;
	private Conditional_expressionElements pConditional_expression;
	private Assignment_expressionElements pAssignment_expression;
	private Assignment_operatorElements pAssignment_operator;
	private ExpressionElements pExpression;
	private Function_prototypeElements pFunction_prototype;
	private Parameter_declarationElements pParameter_declaration;
	private Parameter_declaration_listElements pParameter_declaration_list;
	private Declaration_identifier_and_initElements pDeclaration_identifier_and_init;
	private Single_declarationElements pSingle_declaration;
	private DeclarationElements pDeclaration;
	private Fully_specified_typeElements pFully_specified_type;
	private Type_qualifierElements pType_qualifier;
	private Type_precisionElements pType_precision;
	private Type_specifierElements pType_specifier;
	private Array_bracketsElements pArray_brackets;
	private Type_specifier_nonarrayElements pType_specifier_nonarray;
	private InitializerElements pInitializer;
	private Declaration_statementElements pDeclaration_statement;
	private StatementElements pStatement;
	private Simple_statementElements pSimple_statement;
	private Compound_statementElements pCompound_statement;
	private Statement_no_new_scopeElements pStatement_no_new_scope;
	private Compound_statement_no_new_scopeElements pCompound_statement_no_new_scope;
	private Expression_statementElements pExpression_statement;
	private Constant_expressionElements pConstant_expression;
	private Selection_statementElements pSelection_statement;
	private ConditionElements pCondition;
	private Iteration_statementElements pIteration_statement;
	private Unroll_modifierElements pUnroll_modifier;
	private For_init_statementElements pFor_init_statement;
	private For_rest_statementElements pFor_rest_statement;
	private Jump_statementElements pJump_statement;
	private Translation_unitElements pTranslation_unit;
	private External_declarationElements pExternal_declaration;
	private Function_definitionElements pFunction_definition;
	private Glue_blockElements pGlue_block;
	private TYPEElements pTYPE;
	private BOOLCONSTANTElements pBOOLCONSTANT;
	private RGBA_FIELDSElements pRGBA_FIELDS;
	private TerminalRule tRFIELD;
	private TerminalRule tXYZW_FIELDS;
	private TerminalRule tXFIELD;
	private IDENTIFIERElements pIDENTIFIER;
	private TerminalRule tLETTER;
	private TerminalRule tDIGIT;
	private TerminalRule tINTCONSTANT;
	private TerminalRule tFLOATCONSTANT;
	private TerminalRule tWS;
	private TerminalRule tCOMMENT;
	private TerminalRule tLINE_COMMENT;
	private TerminalRule tT_GLUE_BLOCK;
	private TerminalRule tSTAR;
	private TerminalRule tSLASH;
	private TerminalRule tPLUS;
	private TerminalRule tDASH;
	private TerminalRule tLT;
	private TerminalRule tGT;
	private TerminalRule tLTEQ;
	private TerminalRule tGTEQ;
	private TerminalRule tEQEQ;
	private TerminalRule tNEQ;
	private TerminalRule tAND;
	private TerminalRule tXOR;
	private TerminalRule tOR;
	private TerminalRule tINC;
	private TerminalRule tDEC;
	private TerminalRule tSTAREQ;
	private TerminalRule tSLASHEQ;
	private TerminalRule tPLUSEQ;
	private TerminalRule tDASHEQ;
	private TerminalRule tLEFT_PAREN;
	private TerminalRule tRIGHT_PAREN;
	private TerminalRule tLEFT_BRACKET;
	private TerminalRule tRIGHT_BRACKET;
	private TerminalRule tLEFT_BRACE;
	private TerminalRule tRIGHT_BRACE;
	private TerminalRule tLEFT_FRENCH;
	private TerminalRule tRIGHT_FRENCH;
	private TerminalRule tDOT;
	private TerminalRule tCOMMA;
	private TerminalRule tEQUAL;
	private TerminalRule tBANG;
	private TerminalRule tTILDE;
	private TerminalRule tQUESTION;
	private TerminalRule tCOLON;
	private TerminalRule tSEMICOLON;
	private TerminalRule tIF;
	private TerminalRule tELSE;
	private TerminalRule tWHILE;
	private TerminalRule tDO;
	private TerminalRule tFOR;
	private TerminalRule tUNROLL;
	private TerminalRule tCONTINUE;
	private TerminalRule tBREAK;
	private TerminalRule tDISCARD;
	private TerminalRule tRETURN;
	private TerminalRule tVOID;
	
	private final Grammar grammar;

	@Inject
	public DecoraDslGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("at.bestsolution.efxclipse.tooling.decora.DecoraDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Model:
	//	unit=translation_unit;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//// returns [String fields]
	//field_selection:
	//	r= // { $fields = $r.text; }
	//	RGBA_FIELDS | x= // { $fields = $x.text; }
	//	XYZW_FIELDS;
	public Field_selectionElements getField_selectionAccess() {
		return (pField_selection != null) ? pField_selection : (pField_selection = new Field_selectionElements());
	}
	
	public ParserRule getField_selectionRule() {
		return getField_selectionAccess().getRule();
	}

	//// returns [Expr expr]
	//primary_expression:
	//	{primary_expression} //    { $expr = tm.variable($IDENTIFIER.text); }
	//	IDENTIFIER //{ $expr = tm.parenExpr($e.expr); }
	//	| {primary_expression} //   { $expr = tm.literal(Type.INT, Integer.valueOf($INTCONSTANT.text)); }
	//	INTCONSTANT | {primary_expression} // { $expr = tm.literal(Type.FLOAT, Float.valueOf($FLOATCONSTANT.text)); }
	//	FLOATCONSTANT | {primary_expression} //  { $expr = tm.literal(Type.BOOL, Boolean.valueOf($BOOLCONSTANT.text)); }
	//	BOOLCONSTANT | LEFT_PAREN e=expression RIGHT_PAREN;
	public Primary_expressionElements getPrimary_expressionAccess() {
		return (pPrimary_expression != null) ? pPrimary_expression : (pPrimary_expression = new Primary_expressionElements());
	}
	
	public ParserRule getPrimary_expressionRule() {
		return getPrimary_expressionAccess().getRule();
	}

	//// returns [Expr expr]
	//primary_or_call:
	//	e= //{ $expr = $e.expr; }
	//	primary_expression | f= //{ $expr = $f.expr; }
	//	function_call;
	public Primary_or_callElements getPrimary_or_callAccess() {
		return (pPrimary_or_call != null) ? pPrimary_or_call : (pPrimary_or_call = new Primary_or_callElements());
	}
	
	public ParserRule getPrimary_or_callRule() {
		return getPrimary_or_callAccess().getRule();
	}

	////
	//// TODO: not sure how to do this properly without mutual left-recursion;
	//// for now we hack it to allow:
	////   arr[3].rgb
	////   arr[3]
	////   val.rgb
	////   val++
	////   val--
	////   val
	//// but not things like:
	////   arr[3].r++
	////
	////returns [Expr expr]
	////{ $expr = $e.expr; }
	//postfix_expression:
	//	e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET fs=field_selection //{ $expr = tm.fieldSelect(tm.arrayAccess($e.expr, $ae.expr), $fs.fields); }
	//	//{ $expr = tm.arrayAccess($e.expr, $ae.expr); }
	//	//{ $expr = tm.fieldSelect($e.expr, $fs.fields); }
	//	//{ $expr = tm.unary(UnaryOpType.INC, $e.expr); }
	//	//{ $expr = tm.unary(UnaryOpType.DEC, $e.expr); }
	//	| e=primary_or_call LEFT_BRACKET ae=expression RIGHT_BRACKET | e=primary_or_call fs=field_selection | e=primary_or_call
	//	INC | e=primary_or_call DEC | e=primary_or_call;
	public Postfix_expressionElements getPostfix_expressionAccess() {
		return (pPostfix_expression != null) ? pPostfix_expression : (pPostfix_expression = new Postfix_expressionElements());
	}
	
	public ParserRule getPostfix_expressionRule() {
		return getPostfix_expressionAccess().getRule();
	}

	//// From the GLSL spec...
	//// Grammar Note: Constructors look like functions, but lexical
	//// analysis recognized most of them as keywords.  They are now
	//// recognized through "type_specifier".
	////returns [Expr expr]
	////            {
	////                Type type = Type.fromToken($ts.text);
	////                $expr = tm.vectorCtor(type, p!=null ? $p.exprList : null);
	////            }
	//function_call:
	//	id=IDENTIFIER LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN //            {
	//	//                $expr = tm.call($id.text, p!=null ? $p.exprList : null);
	//	//            }
	//	| ts=type_specifier LEFT_PAREN p=function_call_parameter_list? RIGHT_PAREN;
	public Function_callElements getFunction_callAccess() {
		return (pFunction_call != null) ? pFunction_call : (pFunction_call = new Function_callElements());
	}
	
	public ParserRule getFunction_callRule() {
		return getFunction_callAccess().getRule();
	}

	////returns [List<Expr> exprList = new ArrayList<Expr>()]
	//function_call_parameter_list:
	//	a+= //{ $exprList.add($a.expr); }
	//	assignment_expression (COMMA a+= //{$exprList.add($a.expr); }
	//	assignment_expression)*;
	public Function_call_parameter_listElements getFunction_call_parameter_listAccess() {
		return (pFunction_call_parameter_list != null) ? pFunction_call_parameter_list : (pFunction_call_parameter_list = new Function_call_parameter_listElements());
	}
	
	public ParserRule getFunction_call_parameter_listRule() {
		return getFunction_call_parameter_listAccess().getRule();
	}

	////returns [Expr expr]
	//unary_expression:
	//	p=postfix_expression //{ $expr = $p.expr; }
	//	//{ $expr = tm.unary(UnaryOpType.INC,     $u.expr); }
	//	//{ $expr = tm.unary(UnaryOpType.DEC,     $u.expr); }
	//	//{ $expr = tm.unary(UnaryOpType.PLUS,    $u.expr); }
	//	//{ $expr = tm.unary(UnaryOpType.MINUS,   $u.expr); }
	//	//{ $expr = tm.unary(UnaryOpType.NOT,     $u.expr); }
	//	| INC u=unary_expression | DEC u=unary_expression | PLUS u=unary_expression | DASH u=unary_expression | BANG
	//	u=unary_expression;
	public Unary_expressionElements getUnary_expressionAccess() {
		return (pUnary_expression != null) ? pUnary_expression : (pUnary_expression = new Unary_expressionElements());
	}
	
	public ParserRule getUnary_expressionRule() {
		return getUnary_expressionAccess().getRule();
	}

	//// From the GLSL spec...
	//// Grammar Note:  No traditional style type casts.
	//// From the GLSL spec...
	//// Grammar Note:  No '*' or '&' unary ops.  Pointers are not supported.
	////returns [Expr expr]
	//multiplicative_expression:
	//	a= //{ $expr = $a.expr; }
	//	unary_expression (STAR b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.MUL, $expr, $b.expr); }
	//	//{ $expr = tm.binary(BinaryOpType.DIV, $expr, $b.expr); }
	//	| SLASH b+=multiplicative_expression)*;
	public Multiplicative_expressionElements getMultiplicative_expressionAccess() {
		return (pMultiplicative_expression != null) ? pMultiplicative_expression : (pMultiplicative_expression = new Multiplicative_expressionElements());
	}
	
	public ParserRule getMultiplicative_expressionRule() {
		return getMultiplicative_expressionAccess().getRule();
	}

	////returns [Expr expr]
	//additive_expression:
	//	a= //{ $expr = $a.expr; }
	//	multiplicative_expression (PLUS b+=multiplicative_expression //{ $expr = tm.binary(BinaryOpType.ADD, $expr, $b.expr); }
	//	//{ $expr = tm.binary(BinaryOpType.SUB, $expr, $b.expr); }
	//	| DASH b+=multiplicative_expression)*;
	public Additive_expressionElements getAdditive_expressionAccess() {
		return (pAdditive_expression != null) ? pAdditive_expression : (pAdditive_expression = new Additive_expressionElements());
	}
	
	public ParserRule getAdditive_expressionRule() {
		return getAdditive_expressionAccess().getRule();
	}

	////returns [Expr expr]
	//relational_expression:
	//	a= //{ $expr = $a.expr; }
	//	additive_expression (LTEQ b+=additive_expression //{ $expr = tm.binary(BinaryOpType.LTEQ, $expr, $b.expr); }
	//	//{ $expr = tm.binary(BinaryOpType.GTEQ, $expr, $b.expr); }
	//	//{ $expr = tm.binary(BinaryOpType.LT,   $expr, $b.expr); }
	//	//{ $expr = tm.binary(BinaryOpType.GT,   $expr, $b.expr); }
	//	| GTEQ b+=additive_expression | LT b+=additive_expression | GT b+=additive_expression)*;
	public Relational_expressionElements getRelational_expressionAccess() {
		return (pRelational_expression != null) ? pRelational_expression : (pRelational_expression = new Relational_expressionElements());
	}
	
	public ParserRule getRelational_expressionRule() {
		return getRelational_expressionAccess().getRule();
	}

	////returns [Expr expr]
	//equality_expression:
	//	a= //{ $expr = $a.expr; }
	//	relational_expression (EQEQ b+=relational_expression //{ $expr = tm.binary(BinaryOpType.EQEQ, $expr, $b.expr); }
	//	//{ $expr = tm.binary(BinaryOpType.NEQ,  $expr, $b.expr); }
	//	| NEQ b+=relational_expression)*;
	public Equality_expressionElements getEquality_expressionAccess() {
		return (pEquality_expression != null) ? pEquality_expression : (pEquality_expression = new Equality_expressionElements());
	}
	
	public ParserRule getEquality_expressionRule() {
		return getEquality_expressionAccess().getRule();
	}

	////returns [Expr expr]
	//logical_and_expression:
	//	a= //{ $expr = $a.expr; }
	//	equality_expression (AND b+= //{ $expr = tm.binary(BinaryOpType.AND, $expr, $b.expr); }
	//	equality_expression)*;
	public Logical_and_expressionElements getLogical_and_expressionAccess() {
		return (pLogical_and_expression != null) ? pLogical_and_expression : (pLogical_and_expression = new Logical_and_expressionElements());
	}
	
	public ParserRule getLogical_and_expressionRule() {
		return getLogical_and_expressionAccess().getRule();
	}

	////returns [Expr expr]
	//logical_xor_expression:
	//	a= //{ $expr = $a.expr; }
	//	logical_and_expression (XOR b+= //{ $expr = tm.binary(BinaryOpType.XOR, $expr, $b.expr); }
	//	logical_and_expression)*;
	public Logical_xor_expressionElements getLogical_xor_expressionAccess() {
		return (pLogical_xor_expression != null) ? pLogical_xor_expression : (pLogical_xor_expression = new Logical_xor_expressionElements());
	}
	
	public ParserRule getLogical_xor_expressionRule() {
		return getLogical_xor_expressionAccess().getRule();
	}

	////returns [Expr expr]
	//logical_or_expression:
	//	a= //{ $expr = $a.expr; }
	//	logical_xor_expression (OR b+= //{ $expr = tm.binary(BinaryOpType.OR, $expr, $b.expr); }
	//	logical_xor_expression)*;
	public Logical_or_expressionElements getLogical_or_expressionAccess() {
		return (pLogical_or_expression != null) ? pLogical_or_expression : (pLogical_or_expression = new Logical_or_expressionElements());
	}
	
	public ParserRule getLogical_or_expressionRule() {
		return getLogical_or_expressionAccess().getRule();
	}

	//ternary_part:
	//	QUESTION expression COLON a=assignment_expression;
	public Ternary_partElements getTernary_partAccess() {
		return (pTernary_part != null) ? pTernary_part : (pTernary_part = new Ternary_partElements());
	}
	
	public ParserRule getTernary_partRule() {
		return getTernary_partAccess().getRule();
	}

	//// TODO: handle ternary
	////returns [Expr expr]
	//conditional_expression:
	//	a=logical_or_expression //{ $expr = $a.expr; }
	//	t=ternary_part?;
	public Conditional_expressionElements getConditional_expressionAccess() {
		return (pConditional_expression != null) ? pConditional_expression : (pConditional_expression = new Conditional_expressionElements());
	}
	
	public ParserRule getConditional_expressionRule() {
		return getConditional_expressionAccess().getRule();
	}

	////returns [Expr expr]
	////{ $expr = $c.expr; }
	//assignment_expression:
	//	a=unary_expression op=assignment_operator b=assignment_expression //{ $expr = tm.binary(BinaryOpType.forSymbol($op.text), $a.expr, $b.expr); }
	//	| c=conditional_expression;
	public Assignment_expressionElements getAssignment_expressionAccess() {
		return (pAssignment_expression != null) ? pAssignment_expression : (pAssignment_expression = new Assignment_expressionElements());
	}
	
	public ParserRule getAssignment_expressionRule() {
		return getAssignment_expressionAccess().getRule();
	}

	//assignment_operator:
	//	EQUAL | STAREQ | SLASHEQ | PLUSEQ | DASHEQ;
	public Assignment_operatorElements getAssignment_operatorAccess() {
		return (pAssignment_operator != null) ? pAssignment_operator : (pAssignment_operator = new Assignment_operatorElements());
	}
	
	public ParserRule getAssignment_operatorRule() {
		return getAssignment_operatorAccess().getRule();
	}

	//// TODO: handle expression lists?
	////expression returns [List<Expr> exprList = new ArrayList<Expr>()]
	////        : e=assignment_expression { $exprList.add($e.expr); }
	////          (COMMA e=assignment_expression { $exprList.add($e.expr); })*
	////        ;
	////returns [Expr expr]
	//expression:
	//	e= //{ $expr = $e.expr; }
	//	assignment_expression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	////returns [Function func]
	////            {
	////                Type type = Type.fromToken($t.text);
	////                $func = symbols.declareFunction($id.text, type, (p != null) ? $p.paramList : null);
	////            }
	//function_prototype:
	//	t=type_specifier id=IDENTIFIER LEFT_PAREN p=parameter_declaration_list? RIGHT_PAREN;
	public Function_prototypeElements getFunction_prototypeAccess() {
		return (pFunction_prototype != null) ? pFunction_prototype : (pFunction_prototype = new Function_prototypeElements());
	}
	
	public ParserRule getFunction_prototypeRule() {
		return getFunction_prototypeAccess().getRule();
	}

	////returns [Param param]
	////            {
	////                Type type = Type.fromToken($t.text);
	////                $param = new Param($id.text, type);
	////            }
	//parameter_declaration:
	//	t=type_specifier id=IDENTIFIER;
	public Parameter_declarationElements getParameter_declarationAccess() {
		return (pParameter_declaration != null) ? pParameter_declaration : (pParameter_declaration = new Parameter_declarationElements());
	}
	
	public ParserRule getParameter_declarationRule() {
		return getParameter_declarationAccess().getRule();
	}

	////returns [List<Param> paramList = new ArrayList<Param>()]
	//parameter_declaration_list:
	//	p+= //{ $paramList.add($p.param); }
	//	parameter_declaration (COMMA p+=parameter_declaration)* / *{ $paramList.add($p.param); }* /;
	public Parameter_declaration_listElements getParameter_declaration_listAccess() {
		return (pParameter_declaration_list != null) ? pParameter_declaration_list : (pParameter_declaration_list = new Parameter_declaration_listElements());
	}
	
	public ParserRule getParameter_declaration_listRule() {
		return getParameter_declaration_listAccess().getRule();
	}

	////returns [String name, Expr arrayInit, Expr init]
	//declaration_identifier_and_init:
	//	id= //{ $name = $id.text; }
	//	IDENTIFIER (LEFT_BRACKET ae=constant_expression / *{ $arrayInit = $ae.expr; }* / RIGHT_BRACKET)? (EQUAL e=initializer)?
	//	/ *{ $init = $e.expr; }* /;
	public Declaration_identifier_and_initElements getDeclaration_identifier_and_initAccess() {
		return (pDeclaration_identifier_and_init != null) ? pDeclaration_identifier_and_init : (pDeclaration_identifier_and_init = new Declaration_identifier_and_initElements());
	}
	
	public ParserRule getDeclaration_identifier_and_initRule() {
		return getDeclaration_identifier_and_initAccess().getRule();
	}

	////returns [VarDecl decl]
	////          {
	////              int arraySize = -1;
	////              Expr ainit = $d.arrayInit;
	////              if (ainit != null) {
	////                  if (ainit instanceof LiteralExpr) {
	////                      Object val = ((LiteralExpr)ainit).getValue();
	////                      if (!(val instanceof Integer)) {
	////                          throw new RuntimeException("Array size must be an integer");
	////                      }
	////                      arraySize = ((Integer)val).intValue();
	////                  } else if (ainit instanceof VariableExpr) {
	////                      Variable var = ((VariableExpr)ainit).getVariable();
	////                      Object val = var.getConstValue();
	////                      if (!(val instanceof Integer) || var.getQualifier() != Qualifier.CONST) {
	////                          throw new RuntimeException("Array size must be a constant integer");
	////                      }
	////                      arraySize = ((Integer)val).intValue();
	////                  }
	////              }
	////
	////              Object constValue = null;
	////              if ($t.qual == Qualifier.CONST) {
	////                  Expr cinit = $d.init;
	////                  if (cinit == null) {
	////                      throw new RuntimeException("Constant value must be initialized");
	////                  }
	////                  // TODO: for now, allow some basic expressions on the rhs
	////                  // of the constant declaration...
	////                  //if (!(cinit instanceof LiteralExpr)) {
	////                  //    throw new RuntimeException("Constant initializer must be a literal (for now)");
	////                  //}
	////                  Type ctype = cinit.getResultType();
	////                  if (ctype != $t.type) {
	////                      throw new RuntimeException("Constant type must match that of initializer");
	////                  }
	////                  if (cinit instanceof LiteralExpr) {
	////                      constValue = ((LiteralExpr)cinit).getValue();
	////                  } else {
	////                      // TODO: This is gross, but to support complex constant
	////                      // initializers (such as "const FOO = BAR / 42.0;") we
	////                      // will just save the full text of the rhs and hope that
	////                      // the backend does the right thing with it.  The real
	////                      // solution obviously would be to evaluate the expression
	////                      // now and reduce it to a single value.
	////                      constValue = $d.init.toString();
	////                  }
	////              }
	////
	////              Variable var =
	////                  symbols.declareVariable($d.name,
	////                                          $t.type, $t.qual, $t.precision,
	////                                          arraySize, constValue);
	////              $decl = tm.varDecl(var, $d.init);
	////          }
	//single_declaration:
	//	t=fully_specified_type d=declaration_identifier_and_init;
	public Single_declarationElements getSingle_declarationAccess() {
		return (pSingle_declaration != null) ? pSingle_declaration : (pSingle_declaration = new Single_declarationElements());
	}
	
	public ParserRule getSingle_declarationRule() {
		return getSingle_declarationAccess().getRule();
	}

	////returns [List<VarDecl> declList = new ArrayList<VarDecl>()]
	//declaration:
	//	s= //{ $declList.add($s.decl); }
	//	single_declaration (COMMA d+=declaration_identifier_and_init)* //          {
	//	//              Variable base = $s.decl.getVariable();
	//	//              Variable var =
	//	//                  symbols.declareVariable($d.name,
	//	//                                          base.getType(),
	//	//                                          base.getQualifier(),
	//	//                                          base.getPrecision());
	//	//              $declList.add(tm.varDecl(var, $d.init));
	//	//          }
	//	SEMICOLON;
	public DeclarationElements getDeclarationAccess() {
		return (pDeclaration != null) ? pDeclaration : (pDeclaration = new DeclarationElements());
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//// From GLSL spec...
	//// Grammar Note:  No 'enum', or 'typedef'. 
	////returns [Qualifier qual, Precision precision, Type type]
	////            {
	////                $type = Type.fromToken($ts.text);
	////            }
	//fully_specified_type:
	//	tq=type_qualifier tp=type_precision ts=type_specifier //            {
	//	//                $qual = Qualifier.fromToken($tq.text);
	//	//                $precision = Precision.fromToken($tp.text);
	//	//                $type = Type.fromToken($ts.text);
	//	//            }
	//	//            {
	//	//                $qual = Qualifier.fromToken($tq.text);
	//	//                $type = Type.fromToken($ts.text);
	//	//            }
	//	//            {
	//	//                $precision = Precision.fromToken($tp.text);
	//	//                $type = Type.fromToken($ts.text);
	//	//            }
	//	| tq=type_qualifier ts=type_specifier | tp=type_precision ts=type_specifier | ts=type_specifier;
	public Fully_specified_typeElements getFully_specified_typeAccess() {
		return (pFully_specified_type != null) ? pFully_specified_type : (pFully_specified_type = new Fully_specified_typeElements());
	}
	
	public ParserRule getFully_specified_typeRule() {
		return getFully_specified_typeAccess().getRule();
	}

	//type_qualifier:
	//	"const" | "param";
	public Type_qualifierElements getType_qualifierAccess() {
		return (pType_qualifier != null) ? pType_qualifier : (pType_qualifier = new Type_qualifierElements());
	}
	
	public ParserRule getType_qualifierRule() {
		return getType_qualifierAccess().getRule();
	}

	//type_precision:
	//	"lowp" | "mediump" | "highp";
	public Type_precisionElements getType_precisionAccess() {
		return (pType_precision != null) ? pType_precision : (pType_precision = new Type_precisionElements());
	}
	
	public ParserRule getType_precisionRule() {
		return getType_precisionAccess().getRule();
	}

	//type_specifier:
	//	{type_specifier} type_specifier_nonarray array_brackets?;
	public Type_specifierElements getType_specifierAccess() {
		return (pType_specifier != null) ? pType_specifier : (pType_specifier = new Type_specifierElements());
	}
	
	public ParserRule getType_specifierRule() {
		return getType_specifierAccess().getRule();
	}

	//array_brackets:
	//	LEFT_BRACKET constant_expression RIGHT_BRACKET;
	public Array_bracketsElements getArray_bracketsAccess() {
		return (pArray_brackets != null) ? pArray_brackets : (pArray_brackets = new Array_bracketsElements());
	}
	
	public ParserRule getArray_bracketsRule() {
		return getArray_bracketsAccess().getRule();
	}

	//type_specifier_nonarray:
	//	TYPE | VOID;
	public Type_specifier_nonarrayElements getType_specifier_nonarrayAccess() {
		return (pType_specifier_nonarray != null) ? pType_specifier_nonarray : (pType_specifier_nonarray = new Type_specifier_nonarrayElements());
	}
	
	public ParserRule getType_specifier_nonarrayRule() {
		return getType_specifier_nonarrayAccess().getRule();
	}

	////returns [Expr expr]
	//initializer:
	//	e= //{ $expr = $e.expr; }
	//	assignment_expression;
	public InitializerElements getInitializerAccess() {
		return (pInitializer != null) ? pInitializer : (pInitializer = new InitializerElements());
	}
	
	public ParserRule getInitializerRule() {
		return getInitializerAccess().getRule();
	}

	////returns [Stmt stmt]
	//declaration_statement:
	//	d= //{ $stmt = tm.declStmt($d.declList); }
	//	declaration;
	public Declaration_statementElements getDeclaration_statementAccess() {
		return (pDeclaration_statement != null) ? pDeclaration_statement : (pDeclaration_statement = new Declaration_statementElements());
	}
	
	public ParserRule getDeclaration_statementRule() {
		return getDeclaration_statementAccess().getRule();
	}

	////returns [Stmt stmt]
	//statement:
	//	c= //{ $stmt = $c.stmt; }
	//	compound_statement | s= //{ $stmt = $s.stmt; }
	//	simple_statement;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//// From GLSL spec...
	//// Grammar Note:  No labeled statements; 'goto' is not supported. 
	////returns [Stmt stmt]
	//simple_statement:
	//	d= //{ $stmt = $d.stmt; }
	//	declaration_statement | e= //{ $stmt = $e.stmt; }
	//	expression_statement | s= //{ $stmt = $s.stmt; }
	//	selection_statement | i= //{ $stmt = $i.stmt; }
	//	iteration_statement | j= //{ $stmt = $j.stmt; }
	//	jump_statement;
	public Simple_statementElements getSimple_statementAccess() {
		return (pSimple_statement != null) ? pSimple_statement : (pSimple_statement = new Simple_statementElements());
	}
	
	public ParserRule getSimple_statementRule() {
		return getSimple_statementAccess().getRule();
	}

	////returns [Stmt stmt]
	////@init {
	////    List<Stmt> stmtList = new ArrayList<Stmt>();
	////}
	////{ $stmt = tm.compoundStmt(stmtList); }
	//compound_statement:
	//	{compound_statement} LEFT_BRACE s+=statement* / *{ stmtList.add($s.stmt); }* / RIGHT_BRACE;
	public Compound_statementElements getCompound_statementAccess() {
		return (pCompound_statement != null) ? pCompound_statement : (pCompound_statement = new Compound_statementElements());
	}
	
	public ParserRule getCompound_statementRule() {
		return getCompound_statementAccess().getRule();
	}

	////returns [Stmt stmt]
	//statement_no_new_scope:
	//	c= //{ $stmt = $c.stmt; }
	//	compound_statement_no_new_scope | s= //{ $stmt = $s.stmt; }
	//	simple_statement;
	public Statement_no_new_scopeElements getStatement_no_new_scopeAccess() {
		return (pStatement_no_new_scope != null) ? pStatement_no_new_scope : (pStatement_no_new_scope = new Statement_no_new_scopeElements());
	}
	
	public ParserRule getStatement_no_new_scopeRule() {
		return getStatement_no_new_scopeAccess().getRule();
	}

	////returns [Stmt stmt]
	////@init {
	////    List<Stmt> stmtList = new ArrayList<Stmt>();
	////}
	////{ $stmt = tm.compoundStmt(stmtList); }
	//compound_statement_no_new_scope:
	//	{compound_statement_no_new_scope} LEFT_BRACE s+=statement* / *{ stmtList.add($s.stmt); }* / RIGHT_BRACE;
	public Compound_statement_no_new_scopeElements getCompound_statement_no_new_scopeAccess() {
		return (pCompound_statement_no_new_scope != null) ? pCompound_statement_no_new_scope : (pCompound_statement_no_new_scope = new Compound_statement_no_new_scopeElements());
	}
	
	public ParserRule getCompound_statement_no_new_scopeRule() {
		return getCompound_statement_no_new_scopeAccess().getRule();
	}

	////returns [Stmt stmt]
	//expression_statement:
	//	{expression_statement} SEMICOLON //{ $stmt = tm.exprStmt(null); }
	//	//{ $stmt = tm.exprStmt($e.expr); }
	//	| e=expression SEMICOLON;
	public Expression_statementElements getExpression_statementAccess() {
		return (pExpression_statement != null) ? pExpression_statement : (pExpression_statement = new Expression_statementElements());
	}
	
	public ParserRule getExpression_statementRule() {
		return getExpression_statementAccess().getRule();
	}

	////returns [Expr expr]
	//constant_expression:
	//	c= //{ $expr = $c.expr; }
	//	conditional_expression;
	public Constant_expressionElements getConstant_expressionAccess() {
		return (pConstant_expression != null) ? pConstant_expression : (pConstant_expression = new Constant_expressionElements());
	}
	
	public ParserRule getConstant_expressionRule() {
		return getConstant_expressionAccess().getRule();
	}

	////returns [Stmt stmt]
	////{ $stmt = tm.selectStmt($e.expr, $a.stmt, (b != null) ? $b.stmt : null); }
	//selection_statement:
	//	IF LEFT_PAREN e=expression RIGHT_PAREN a=statement (ELSE b=statement)?;
	public Selection_statementElements getSelection_statementAccess() {
		return (pSelection_statement != null) ? pSelection_statement : (pSelection_statement = new Selection_statementElements());
	}
	
	public ParserRule getSelection_statementRule() {
		return getSelection_statementAccess().getRule();
	}

	//// TODO: implement second half?
	////returns [Expr expr]
	////        | fully_specified_type IDENTIFIER EQUAL initializer
	//condition:
	//	e= //{$expr = $e.expr; }
	//	expression;
	public ConditionElements getConditionAccess() {
		return (pCondition != null) ? pCondition : (pCondition = new ConditionElements());
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}

	////returns [Stmt stmt]
	////{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, -1, -1); }
	//iteration_statement:
	//	WHILE LEFT_PAREN c=condition RIGHT_PAREN snns=statement_no_new_scope //{ $stmt = tm.whileStmt($c.expr, $snns.stmt); }
	//	//{ $stmt = tm.doWhileStmt($s.stmt, $e.expr); }
	//	//{ $stmt = tm.forStmt($init.stmt, $rem.cond, $rem.expr, $snns.stmt, $u.max, $u.check); }
	//	| DO s=statement WHILE LEFT_PAREN e=expression RIGHT_PAREN SEMICOLON | u=unroll_modifier FOR LEFT_PAREN
	//	init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope | FOR LEFT_PAREN
	//	init=for_init_statement rem=for_rest_statement RIGHT_PAREN snns=statement_no_new_scope;
	public Iteration_statementElements getIteration_statementAccess() {
		return (pIteration_statement != null) ? pIteration_statement : (pIteration_statement = new Iteration_statementElements());
	}
	
	public ParserRule getIteration_statementRule() {
		return getIteration_statementAccess().getRule();
	}

	////returns [int max, int check]
	////{ $max = Integer.valueOf($m.text); $check = Integer.valueOf($c.text); }
	//unroll_modifier:
	//	UNROLL LEFT_PAREN m=INTCONSTANT COMMA c=INTCONSTANT RIGHT_PAREN;
	public Unroll_modifierElements getUnroll_modifierAccess() {
		return (pUnroll_modifier != null) ? pUnroll_modifier : (pUnroll_modifier = new Unroll_modifierElements());
	}
	
	public ParserRule getUnroll_modifierRule() {
		return getUnroll_modifierAccess().getRule();
	}

	////returns [Stmt stmt]
	//for_init_statement:
	//	e= //{ $stmt = $e.stmt; }
	//	expression_statement | d= //{ $stmt = $d.stmt; }
	//	declaration_statement;
	public For_init_statementElements getFor_init_statementAccess() {
		return (pFor_init_statement != null) ? pFor_init_statement : (pFor_init_statement = new For_init_statementElements());
	}
	
	public ParserRule getFor_init_statementRule() {
		return getFor_init_statementAccess().getRule();
	}

	////returns [Expr cond, Expr expr]
	//for_rest_statement:
	//	{for_rest_statement} c=condition SEMICOLON e=expression? //{ $cond = $c.expr; if (e != null) $expr = $e.expr; }
	//	//{ if (e != null) $expr = $e.expr; }
	//	| {for_rest_statement} SEMICOLON e=expression?;
	public For_rest_statementElements getFor_rest_statementAccess() {
		return (pFor_rest_statement != null) ? pFor_rest_statement : (pFor_rest_statement = new For_rest_statementElements());
	}
	
	public ParserRule getFor_rest_statementRule() {
		return getFor_rest_statementAccess().getRule();
	}

	////returns [Stmt stmt]
	//jump_statement:
	//	{jump_statement} CONTINUE //{ $stmt = tm.continueStmt(); }
	//	SEMICOLON //{ $stmt = tm.returnStmt($e.expr); }
	//	| {jump_statement} BREAK //{ $stmt = tm.breakStmt(); }
	//	SEMICOLON | {jump_statement} DISCARD //{ $stmt = tm.discardStmt(); }
	//	SEMICOLON | {jump_statement} RETURN //{ $stmt = tm.returnStmt(null); }
	//	SEMICOLON | RETURN e=expression SEMICOLON;
	public Jump_statementElements getJump_statementAccess() {
		return (pJump_statement != null) ? pJump_statement : (pJump_statement = new Jump_statementElements());
	}
	
	public ParserRule getJump_statementRule() {
		return getJump_statementAccess().getRule();
	}

	//// From GLSL spec...
	//// Grammar Note:  No 'goto'.  Gotos are not supported. 
	////returns [ProgramUnit prog]
	////@init {
	////    List<ExtDecl> declList = new ArrayList<ExtDecl>();
	////}
	/// *{ declList.addAll($e.res); }* / //{ $prog = tm.programUnit(declList); }
	//translation_unit:
	//	e+=external_declaration+;
	public Translation_unitElements getTranslation_unitAccess() {
		return (pTranslation_unit != null) ? pTranslation_unit : (pTranslation_unit = new Translation_unitElements());
	}
	
	public ParserRule getTranslation_unitRule() {
		return getTranslation_unitAccess().getRule();
	}

	////returns [List<ExtDecl> res = new ArrayList<ExtDecl>()]
	//external_declaration:
	//	f= //{ $res.add($f.def); }
	//	function_definition | d= //{ $res.addAll($d.declList); }
	//	declaration | g= //{ $res.add($g.block); }
	//	glue_block;
	public External_declarationElements getExternal_declarationAccess() {
		return (pExternal_declaration != null) ? pExternal_declaration : (pExternal_declaration = new External_declarationElements());
	}
	
	public ParserRule getExternal_declarationRule() {
		return getExternal_declarationAccess().getRule();
	}

	//// From GLSL spec...
	//// Grammar Note:  No 'switch'.  Switch statements not supported. 
	////returns [FuncDef def]
	////@init {
	////	symbols.enterFrame();
	////}
	//function_definition:
	//	p=function_prototype s= //{ $def = tm.funcDef($p.func, $s.stmt); }
	//	compound_statement_no_new_scope;
	public Function_definitionElements getFunction_definitionAccess() {
		return (pFunction_definition != null) ? pFunction_definition : (pFunction_definition = new Function_definitionElements());
	}
	
	public ParserRule getFunction_definitionRule() {
		return getFunction_definitionAccess().getRule();
	}

	////finally {
	////        symbols.exitFrame();
	////}
	////returns [GlueBlock block]
	//glue_block:
	//	g= //{ $block = tm.glueBlock($g.text.substring(2, $g.text.length()-2)); }
	//	T_GLUE_BLOCK;
	public Glue_blockElements getGlue_blockAccess() {
		return (pGlue_block != null) ? pGlue_block : (pGlue_block = new Glue_blockElements());
	}
	
	public ParserRule getGlue_blockRule() {
		return getGlue_blockAccess().getRule();
	}

	//TYPE:
	//	"float2" | "float3" | "float4" | "float" | "int2" | "int3" | "int4" | "int" | "bool2" | "bool3" | "bool4" | "bool" |
	//	"sampler" | "lsampler" | "fsampler";
	public TYPEElements getTYPEAccess() {
		return (pTYPE != null) ? pTYPE : (pTYPE = new TYPEElements());
	}
	
	public ParserRule getTYPERule() {
		return getTYPEAccess().getRule();
	}

	//BOOLCONSTANT:
	//	"true" | "false";
	public BOOLCONSTANTElements getBOOLCONSTANTAccess() {
		return (pBOOLCONSTANT != null) ? pBOOLCONSTANT : (pBOOLCONSTANT = new BOOLCONSTANTElements());
	}
	
	public ParserRule getBOOLCONSTANTRule() {
		return getBOOLCONSTANTAccess().getRule();
	}

	//RGBA_FIELDS:
	//	DOT RFIELD RFIELD RFIELD RFIELD | DOT RFIELD RFIELD RFIELD | DOT RFIELD RFIELD | DOT RFIELD;
	public RGBA_FIELDSElements getRGBA_FIELDSAccess() {
		return (pRGBA_FIELDS != null) ? pRGBA_FIELDS : (pRGBA_FIELDS = new RGBA_FIELDSElements());
	}
	
	public ParserRule getRGBA_FIELDSRule() {
		return getRGBA_FIELDSAccess().getRule();
	}

	//// fragment
	//terminal RFIELD:
	//	"r" | "g" | "b" | "a";
	public TerminalRule getRFIELDRule() {
		return (tRFIELD != null) ? tRFIELD : (tRFIELD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RFIELD"));
	} 

	//terminal XYZW_FIELDS:
	//	DOT XFIELD XFIELD XFIELD XFIELD | DOT XFIELD XFIELD XFIELD | DOT XFIELD XFIELD | DOT XFIELD;
	public TerminalRule getXYZW_FIELDSRule() {
		return (tXYZW_FIELDS != null) ? tXYZW_FIELDS : (tXYZW_FIELDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "XYZW_FIELDS"));
	} 

	//terminal XFIELD:
	//	"x" | "y" | "z" | "w";
	public TerminalRule getXFIELDRule() {
		return (tXFIELD != null) ? tXFIELD : (tXFIELD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "XFIELD"));
	} 

	//IDENTIFIER:
	//	LETTER (LETTER | DIGIT)*;
	public IDENTIFIERElements getIDENTIFIERAccess() {
		return (pIDENTIFIER != null) ? pIDENTIFIER : (pIDENTIFIER = new IDENTIFIERElements());
	}
	
	public ParserRule getIDENTIFIERRule() {
		return getIDENTIFIERAccess().getRule();
	}

	//terminal LETTER:
	//	"$" | "A".."Z" | "a".."z" | "_";
	public TerminalRule getLETTERRule() {
		return (tLETTER != null) ? tLETTER : (tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LETTER"));
	} 

	////fragment
	//terminal DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return (tDIGIT != null) ? tDIGIT : (tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DIGIT"));
	} 

	//terminal INTCONSTANT:
	//	"0" | "1".."9" DIGIT*;
	public TerminalRule getINTCONSTANTRule() {
		return (tINTCONSTANT != null) ? tINTCONSTANT : (tINTCONSTANT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INTCONSTANT"));
	} 

	//terminal FLOATCONSTANT:
	//	DIGIT+ "." DIGIT* | "." DIGIT+;
	public TerminalRule getFLOATCONSTANTRule() {
		return (tFLOATCONSTANT != null) ? tFLOATCONSTANT : (tFLOATCONSTANT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOATCONSTANT"));
	} 

	//terminal WS:
	//	" " / * |'\u000C'* / | "\r" | "\t" | "\n";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getCOMMENTRule() {
		return (tCOMMENT != null) ? tCOMMENT : (tCOMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMENT"));
	} 

	//terminal LINE_COMMENT:
	//	"//" !("\n" | "\r")* "\r"? "\n";
	public TerminalRule getLINE_COMMENTRule() {
		return (tLINE_COMMENT != null) ? tLINE_COMMENT : (tLINE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LINE_COMMENT"));
	} 

	//terminal T_GLUE_BLOCK:
	//	LEFT_FRENCH .* RIGHT_FRENCH;
	public TerminalRule getT_GLUE_BLOCKRule() {
		return (tT_GLUE_BLOCK != null) ? tT_GLUE_BLOCK : (tT_GLUE_BLOCK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "T_GLUE_BLOCK"));
	} 

	//terminal STAR:
	//	"*";
	public TerminalRule getSTARRule() {
		return (tSTAR != null) ? tSTAR : (tSTAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STAR"));
	} 

	//terminal SLASH:
	//	"/";
	public TerminalRule getSLASHRule() {
		return (tSLASH != null) ? tSLASH : (tSLASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASH"));
	} 

	//terminal PLUS:
	//	"+";
	public TerminalRule getPLUSRule() {
		return (tPLUS != null) ? tPLUS : (tPLUS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUS"));
	} 

	//terminal DASH:
	//	"-";
	public TerminalRule getDASHRule() {
		return (tDASH != null) ? tDASH : (tDASH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DASH"));
	} 

	//terminal LT:
	//	"<";
	public TerminalRule getLTRule() {
		return (tLT != null) ? tLT : (tLT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LT"));
	} 

	//terminal GT:
	//	">";
	public TerminalRule getGTRule() {
		return (tGT != null) ? tGT : (tGT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GT"));
	} 

	//terminal LTEQ:
	//	"<=";
	public TerminalRule getLTEQRule() {
		return (tLTEQ != null) ? tLTEQ : (tLTEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LTEQ"));
	} 

	//terminal GTEQ:
	//	">=";
	public TerminalRule getGTEQRule() {
		return (tGTEQ != null) ? tGTEQ : (tGTEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "GTEQ"));
	} 

	//terminal EQEQ:
	//	"==";
	public TerminalRule getEQEQRule() {
		return (tEQEQ != null) ? tEQEQ : (tEQEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQEQ"));
	} 

	//terminal NEQ:
	//	"!=";
	public TerminalRule getNEQRule() {
		return (tNEQ != null) ? tNEQ : (tNEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NEQ"));
	} 

	//terminal AND:
	//	"&&";
	public TerminalRule getANDRule() {
		return (tAND != null) ? tAND : (tAND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "AND"));
	} 

	//terminal XOR:
	//	"^^";
	public TerminalRule getXORRule() {
		return (tXOR != null) ? tXOR : (tXOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "XOR"));
	} 

	//terminal OR:
	//	"||";
	public TerminalRule getORRule() {
		return (tOR != null) ? tOR : (tOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "OR"));
	} 

	//terminal INC:
	//	"++";
	public TerminalRule getINCRule() {
		return (tINC != null) ? tINC : (tINC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INC"));
	} 

	//terminal DEC:
	//	"--";
	public TerminalRule getDECRule() {
		return (tDEC != null) ? tDEC : (tDEC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DEC"));
	} 

	//terminal STAREQ:
	//	"*=";
	public TerminalRule getSTAREQRule() {
		return (tSTAREQ != null) ? tSTAREQ : (tSTAREQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STAREQ"));
	} 

	//terminal SLASHEQ:
	//	"/=";
	public TerminalRule getSLASHEQRule() {
		return (tSLASHEQ != null) ? tSLASHEQ : (tSLASHEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SLASHEQ"));
	} 

	//terminal PLUSEQ:
	//	"+=";
	public TerminalRule getPLUSEQRule() {
		return (tPLUSEQ != null) ? tPLUSEQ : (tPLUSEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "PLUSEQ"));
	} 

	//terminal DASHEQ:
	//	"-=";
	public TerminalRule getDASHEQRule() {
		return (tDASHEQ != null) ? tDASHEQ : (tDASHEQ = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DASHEQ"));
	} 

	//terminal LEFT_PAREN:
	//	"(";
	public TerminalRule getLEFT_PARENRule() {
		return (tLEFT_PAREN != null) ? tLEFT_PAREN : (tLEFT_PAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_PAREN"));
	} 

	//terminal RIGHT_PAREN:
	//	")";
	public TerminalRule getRIGHT_PARENRule() {
		return (tRIGHT_PAREN != null) ? tRIGHT_PAREN : (tRIGHT_PAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_PAREN"));
	} 

	//terminal LEFT_BRACKET:
	//	"[";
	public TerminalRule getLEFT_BRACKETRule() {
		return (tLEFT_BRACKET != null) ? tLEFT_BRACKET : (tLEFT_BRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_BRACKET"));
	} 

	//terminal RIGHT_BRACKET:
	//	"]";
	public TerminalRule getRIGHT_BRACKETRule() {
		return (tRIGHT_BRACKET != null) ? tRIGHT_BRACKET : (tRIGHT_BRACKET = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_BRACKET"));
	} 

	//terminal LEFT_BRACE:
	//	"{";
	public TerminalRule getLEFT_BRACERule() {
		return (tLEFT_BRACE != null) ? tLEFT_BRACE : (tLEFT_BRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_BRACE"));
	} 

	//terminal RIGHT_BRACE:
	//	"}";
	public TerminalRule getRIGHT_BRACERule() {
		return (tRIGHT_BRACE != null) ? tRIGHT_BRACE : (tRIGHT_BRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_BRACE"));
	} 

	//terminal LEFT_FRENCH:
	//	"<<";
	public TerminalRule getLEFT_FRENCHRule() {
		return (tLEFT_FRENCH != null) ? tLEFT_FRENCH : (tLEFT_FRENCH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT_FRENCH"));
	} 

	//terminal RIGHT_FRENCH:
	//	">>";
	public TerminalRule getRIGHT_FRENCHRule() {
		return (tRIGHT_FRENCH != null) ? tRIGHT_FRENCH : (tRIGHT_FRENCH = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT_FRENCH"));
	} 

	//terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return (tDOT != null) ? tDOT : (tDOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DOT"));
	} 

	//terminal COMMA:
	//	",";
	public TerminalRule getCOMMARule() {
		return (tCOMMA != null) ? tCOMMA : (tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMA"));
	} 

	//terminal EQUAL:
	//	"=";
	public TerminalRule getEQUALRule() {
		return (tEQUAL != null) ? tEQUAL : (tEQUAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "EQUAL"));
	} 

	//terminal BANG:
	//	"!";
	public TerminalRule getBANGRule() {
		return (tBANG != null) ? tBANG : (tBANG = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BANG"));
	} 

	//terminal TILDE:
	//	"~";
	public TerminalRule getTILDERule() {
		return (tTILDE != null) ? tTILDE : (tTILDE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "TILDE"));
	} 

	//terminal QUESTION:
	//	"?";
	public TerminalRule getQUESTIONRule() {
		return (tQUESTION != null) ? tQUESTION : (tQUESTION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "QUESTION"));
	} 

	//terminal COLON:
	//	":";
	public TerminalRule getCOLONRule() {
		return (tCOLON != null) ? tCOLON : (tCOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COLON"));
	} 

	//terminal SEMICOLON:
	//	";";
	public TerminalRule getSEMICOLONRule() {
		return (tSEMICOLON != null) ? tSEMICOLON : (tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SEMICOLON"));
	} 

	//terminal IF:
	//	"if";
	public TerminalRule getIFRule() {
		return (tIF != null) ? tIF : (tIF = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "IF"));
	} 

	//terminal ELSE:
	//	"else";
	public TerminalRule getELSERule() {
		return (tELSE != null) ? tELSE : (tELSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ELSE"));
	} 

	//terminal WHILE:
	//	"while";
	public TerminalRule getWHILERule() {
		return (tWHILE != null) ? tWHILE : (tWHILE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WHILE"));
	} 

	//terminal DO:
	//	"do";
	public TerminalRule getDORule() {
		return (tDO != null) ? tDO : (tDO = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DO"));
	} 

	//terminal FOR:
	//	"for";
	public TerminalRule getFORRule() {
		return (tFOR != null) ? tFOR : (tFOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FOR"));
	} 

	//terminal UNROLL:
	//	"unroll";
	public TerminalRule getUNROLLRule() {
		return (tUNROLL != null) ? tUNROLL : (tUNROLL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UNROLL"));
	} 

	//terminal CONTINUE:
	//	"continue";
	public TerminalRule getCONTINUERule() {
		return (tCONTINUE != null) ? tCONTINUE : (tCONTINUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "CONTINUE"));
	} 

	//terminal BREAK:
	//	"break";
	public TerminalRule getBREAKRule() {
		return (tBREAK != null) ? tBREAK : (tBREAK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BREAK"));
	} 

	//terminal DISCARD:
	//	"discard";
	public TerminalRule getDISCARDRule() {
		return (tDISCARD != null) ? tDISCARD : (tDISCARD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "DISCARD"));
	} 

	//terminal RETURN:
	//	"return";
	public TerminalRule getRETURNRule() {
		return (tRETURN != null) ? tRETURN : (tRETURN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "RETURN"));
	} 

	//terminal VOID:
	//	"void";
	public TerminalRule getVOIDRule() {
		return (tVOID != null) ? tVOID : (tVOID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "VOID"));
	} 
}
