/*
 * generated by Xtext
 */
package at.bestsolution.efxclipse.tooling.efxbean.generator

import at.bestsolution.efxclipse.tooling.efxbean.fXBean.BeanPropertyDecl
import at.bestsolution.efxclipse.tooling.efxbean.fXBean.FXBeanUnit
import at.bestsolution.efxclipse.tooling.efxbean.fXBean.MapTypeDef
import at.bestsolution.efxclipse.tooling.efxbean.fXBean.TypeDef
import at.bestsolution.efxclipse.tooling.efxbean.fXBean.ValueListTypeDef
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.xbase.compiler.ImportManager

class FXBeanGenerator implements IGenerator { 
	var ImportManager manager;
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		val FXBeanUnit u = resource.contents.get(0) as FXBeanUnit;
		
		{
			val filePath = u.getPackage().name.replace('.','/') + "/" + u.bean.name + ".java";
			manager  = new ImportManager(true);
			fsa.generateFile(filePath,generateBeanFile(u));
			
		}
		
		if( u.bean.reflective ) {
			manager  = new ImportManager(true);
			val filePath = u.getPackage().name.replace('.','/') + "/reflective/" + u.bean.name + "Access.java";
			fsa.generateFile(filePath,generateReflectiveAccessFile(u));
		}
	}
	
	def generateReflectiveAccessFile(FXBeanUnit u) '''
	package «u.getPackage().name».reflective;
	
	import at.bestsolution.efxclipse.runtime.model.*;
	import javafx.collections.*;
	import java.util.List;
	import java.util.ArrayList;
	import «u.getPackage().name».«u.bean.name»;
	
	«val c = generateReflectiveAccessClassBody(u)»
	«FOR i : manager.imports»
		import «i»;
	«ENDFOR»
	
	«c»
	'''
	def generateReflectiveAccessClassBody(FXBeanUnit u) '''
	public class «u.bean.name»Access {
		«FOR p : u.bean.properties»
		«IF p.type instanceof ValueListTypeDef»
		«IF p.valDef.multi != null»
		public static final EFXListProperty<«u.bean.name»,ObservableList<«p.valDef.singleType.shortName»>,«p.valDef.singleType.shortName»> «p.name.toUpperCase» = new EFXListProperty<«u.bean.name»,ObservableList<«p.valDef.singleType.shortName»>,«p.valDef.singleType.shortName»>("«p.name»",ObservableList.class,«p.valDef.singleType.shortName».class,«p.readonly»,«p.lazy»);
		«ELSE»
		public static final EFXProperty<«u.bean.name»,«p.valDef.singleType.objectShortType»> «p.name.toUpperCase» = new EFXProperty<«u.bean.name»,«p.valDef.singleType.objectShortType»>("«p.name»",«p.valDef.singleType.shortName».class,«p.readonly»,«p.lazy»);
		«ENDIF»
		«ELSE»
		public static final EFXMapProperty<?,?,«p.mapDef.keyType.shortName»,«p.mapDef.valueType.shortName»> «p.name.toUpperCase» = new EFXMapProperty<?,?,«p.mapDef.keyType.shortName»,«p.mapDef.valueType.shortName»>("«p.name»");
		«ENDIF»
		«ENDFOR»
		
		public static final EFXBeanClass<«u.bean.name»> CLAZZ;
		
		static {
			List<EFXFeature<«u.bean.name»,?>> features = new ArrayList<EFXFeature<«u.bean.name»,?>>();
			«FOR p: u.bean.properties»
			features.add(«p.name.toUpperCase»);
			«ENDFOR»
			CLAZZ = new EFXBeanClass<«u.bean.name»>(features);
		}
	}
	'''
	
	def generateBeanFile(FXBeanUnit u) '''
	package «u.getPackage().name»;
	
	import javafx.beans.property.*;
	import javafx.collections.*;
	import java.util.ArrayList;
	
	«val c = generateClassBody(u)»
	«FOR i : manager.imports»
		import «i»;
	«ENDFOR»
	
	«c»
	'''
	
	def generateClassBody(FXBeanUnit u) '''
	public class «u.bean.name» {
		«FOR p : u.bean.properties»
		private «IF ! p.lazy»final «ENDIF»«p.type.propertyDefinition» «p.name»Property «IF ! p.lazy» = «p.type.propertyCreate»«ENDIF»;
		«ENDFOR»
		
		«FOR p : u.bean.properties»
			«accessMethods(p.type)»

		«ENDFOR»
	}
	'''
	
	def dispatch accessMethods(ValueListTypeDef p)'''
		// -------------------------------
		// Property: «p.property.name»; lazy: «p.property.lazy»; readonly: «p.property.readonly»
		// -------------------------------
		public «p.apiPropertyDefinition()» «p.property.name»Property() {
			«IF p.property.lazy»
				if( this.«p.property.name»Property == null ) {
					this.«p.property.name»Property = «propertyCreate(p)»;
				}
			«ENDIF»
			return this.«p.property.name»Property;
		}

		«IF ! p.property.readonly»
			public void set«p.property.name.camelCase»(«IF p.multi != null»ObservableList<«ENDIF»«p.singleType.shortName»«IF p.multi != null»>«ENDIF» «p.property.name») {
				this.«p.property.name»Property().set(«p.property.name»);
			}
		«ENDIF»

		public «IF p.multi != null»ObservableList<«ENDIF»«p.singleType.shortName»«IF p.multi!=null»>«ENDIF» get«p.property.name.camelCase»() {
			«IF p.property.lazy»
			if( this.«p.property.name»Property == null ) {
				return «defaultValue(p)»;
			}
			«ENDIF»
			return this.«p.property.name»Property.get();
		}
	'''
	
	def dispatch accessMethods(MapTypeDef p)'''
	'''
	
	def dispatch propertyCreate(ValueListTypeDef p) {
		if( p.multi == null ) {
			return "new " +p.propertyDefinition + "(this,\""+p.property.name+"\")"	
		} else {
			return "new " +p.propertyDefinition + "(this,\""+p.property.name+"\",FXCollections.observableArrayList(new ArrayList<"+p.singleType.shortName+">()))"
		}
	}
	
	def dispatch propertyCreate(MapTypeDef p) {
		return "(ObservableMap<"+p.keyType+","+p.valueType+">)FXCollections.observableHashMap()";
	}
	
	def dispatch defaultValue(ValueListTypeDef p) {
		if( p.multi == null ) {
			switch(p.singleType.qualifiedName) {
				case "int":
					return "0"
				case "double":
					return "0.0"
			}
		} 
		
		return "null";
	}
	
	def dispatch defaultValue(MapTypeDef p) {
		return "null";
	}
	
	def camelCase(String value) {
		return Character::toUpperCase(value.charAt(0)) + value.substring(1);
	}
	
	def apiPropertyDefinition(MapTypeDef t) {
		
	}
	
	def apiPropertyDefinition(ValueListTypeDef t) {
		var ro = "";
		if( t.property.readonly ) {
			ro = "ReadOnly";
		}
		
		if( t.multi != null ) {
			return ro+"ObjectProperty<ObservableList<"+t.singleType.shortName+">>"
		} else {
			switch(t.singleType.qualifiedName) {
				case "java.lang.String":
					return ro+"StringProperty"
				case "int":
					return ro+"IntegerProperty"
				case "double":
					return ro+"DoubleProperty"
			}
			return ro+"ObjectProperty<"+t.singleType.qualifiedName+">"
		}
	}
	
	def dispatch propertyDefinition(MapTypeDef t) {
		return "SimpleObjectProperty<ObservableMap<"+t.keyType.shortName+","+t.valueType.shortName+">>";
	}
	
	def dispatch propertyDefinition(ValueListTypeDef t) {
		if( t.multi == null ) {
			switch(t.singleType.qualifiedName) {
				case "java.lang.String":
					return "SimpleStringProperty"
				case "int":
					return "SimpleIntegerProperty"
				case "double":
					return "SimpleDoubleProperty"
			}
			return "SimpleObjectProperty<"+t.singleType.shortName+">"	
		} else {
			return "SimpleObjectProperty<ObservableList<"+t.singleType.shortName+">>"
		}
	}
	
	def objectShortType(JvmTypeReference r) {
		if( r.qualifiedName.equals("int") ) {
			return "Integer";
		} else if( r.qualifiedName.equals("double") ) {
			return "Double";
		}
		return r.shortName;
	}
	
	def property(TypeDef t) {
		return (t.eContainer as BeanPropertyDecl);
	}
	
	def mapDef(BeanPropertyDecl b) {
		return b.type as MapTypeDef;
	}
	
	def valDef(BeanPropertyDecl b) {
		return b.type as ValueListTypeDef;
	}
	
	def shortName(JvmTypeReference r) {
		val builder = new StringBuilder()
		manager.appendType(r.type, builder)
		builder.toString
	}
}
